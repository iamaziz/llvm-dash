

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Garbage Collection with LLVM &#8212; LLVM 9 documentation</title>
    <link rel="stylesheet" href="_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Writing an LLVM Pass" href="WritingAnLLVMPass.html" />
    <link rel="prev" title="How To Use Instruction Mappings" href="HowToUseInstrMappings.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="WritingAnLLVMPass.html" title="Writing an LLVM Pass"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="HowToUseInstrMappings.html" title="How To Use Instruction Mappings"
             accesskey="P">previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="garbage-collection-with-llvm">
<h1>Garbage Collection with LLVM<a class="headerlink" href="#garbage-collection-with-llvm" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#abstract" id="id1">Abstract</a></p></li>
<li><p><a class="reference internal" href="#quick-start" id="id2">Quick Start</a></p></li>
<li><p><a class="reference internal" href="#introduction" id="id3">Introduction</a></p>
<ul>
<li><p><a class="reference internal" href="#what-is-garbage-collection" id="id4">What is Garbage Collection?</a></p></li>
<li><p><a class="reference internal" href="#goals-and-non-goals" id="id5">Goals and non-goals</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#llvm-ir-features" id="id6">LLVM IR Features</a></p>
<ul>
<li><p><a class="reference internal" href="#specifying-gc-code-generation-gc" id="id7">Specifying GC code generation: <code class="docutils literal notranslate"><span class="pre">gc</span> <span class="pre">&quot;...&quot;</span></code></a></p></li>
<li><p><a class="reference internal" href="#gcroot" id="id8">Identifying GC roots on the stack</a></p>
<ul>
<li><p><a class="reference internal" href="#using-gc-statepoint" id="id9">Using <code class="docutils literal notranslate"><span class="pre">gc.statepoint</span></code></a></p></li>
<li><p><a class="reference internal" href="#using-llvm-gcwrite" id="id10">Using <code class="docutils literal notranslate"><span class="pre">llvm.gcwrite</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#reading-and-writing-references-in-the-heap" id="id11">Reading and writing references in the heap</a></p>
<ul>
<li><p><a class="reference internal" href="#write-barrier-llvm-gcwrite" id="id12">Write barrier: <code class="docutils literal notranslate"><span class="pre">llvm.gcwrite</span></code></a></p></li>
<li><p><a class="reference internal" href="#read-barrier-llvm-gcread" id="id13">Read barrier: <code class="docutils literal notranslate"><span class="pre">llvm.gcread</span></code></a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#built-in-gc-strategies" id="id14">Built In GC Strategies</a></p>
<ul>
<li><p><a class="reference internal" href="#the-shadow-stack-gc" id="id15">The Shadow Stack GC</a></p></li>
<li><p><a class="reference internal" href="#the-erlang-and-ocaml-gcs" id="id16">The ‘Erlang’ and ‘Ocaml’ GCs</a></p></li>
<li><p><a class="reference internal" href="#the-statepoint-example-gc" id="id17">The Statepoint Example GC</a></p></li>
<li><p><a class="reference internal" href="#the-coreclr-gc" id="id18">The CoreCLR GC</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#custom-gc-strategies" id="id19">Custom GC Strategies</a></p>
<ul>
<li><p><a class="reference internal" href="#collector-requirements" id="id20">Collector Requirements</a></p></li>
<li><p><a class="reference internal" href="#implementing-a-collector-plugin" id="id21">Implementing a collector plugin</a></p></li>
<li><p><a class="reference internal" href="#overview-of-available-features" id="id22">Overview of available features</a></p></li>
<li><p><a class="reference internal" href="#computing-stack-maps" id="id23">Computing stack maps</a></p></li>
<li><p><a class="reference internal" href="#initializing-roots-to-null" id="id24">Initializing roots to null</a></p></li>
<li><p><a class="reference internal" href="#custom-lowering-of-intrinsics" id="id25">Custom lowering of intrinsics</a></p></li>
<li><p><a class="reference internal" href="#generating-safe-points" id="id26">Generating safe points</a></p></li>
<li><p><a class="reference internal" href="#emitting-assembly-code-gcmetadataprinter" id="id27">Emitting assembly code: <code class="docutils literal notranslate"><span class="pre">GCMetadataPrinter</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#references" id="id28">References</a></p></li>
</ul>
</div>
<div class="section" id="abstract">
<h2><a class="toc-backref" href="#id1">Abstract</a><a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
<p>This document covers how to integrate LLVM into a compiler for a language which
supports garbage collection.  <strong>Note that LLVM itself does not provide a
garbage collector.</strong>  You must provide your own.</p>
</div>
<div class="section" id="quick-start">
<h2><a class="toc-backref" href="#id2">Quick Start</a><a class="headerlink" href="#quick-start" title="Permalink to this headline">¶</a></h2>
<p>First, you should pick a collector strategy.  LLVM includes a number of built
in ones, but you can also implement a loadable plugin with a custom definition.
Note that the collector strategy is a description of how LLVM should generate
code such that it interacts with your collector and runtime, not a description
of the collector itself.</p>
<p>Next, mark your generated functions as using your chosen collector strategy.
From c++, you can call:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">F</span><span class="p">.</span><span class="n">setGC</span><span class="p">(</span><span class="o">&lt;</span><span class="n">collector</span> <span class="n">description</span> <span class="n">name</span><span class="o">&gt;</span><span class="p">);</span>
</pre></div>
</div>
<p>This will produce IR like the following fragment:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="k">void</span> <span class="vg">@foo</span><span class="p">()</span> <span class="k">gc</span> <span class="s">&quot;&lt;collector description name&gt;&quot;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>When generating LLVM IR for your functions, you will need to:</p>
<ul class="simple">
<li><p>Use <code class="docutils literal notranslate"><span class="pre">&#64;llvm.gcread</span></code> and/or <code class="docutils literal notranslate"><span class="pre">&#64;llvm.gcwrite</span></code> in place of standard load and
store instructions.  These intrinsics are used to represent load and store
barriers.  If you collector does not require such barriers, you can skip
this step.</p></li>
<li><p>Use the memory allocation routines provided by your garbage collector’s
runtime library.</p></li>
<li><p>If your collector requires them, generate type maps according to your
runtime’s binary interface.  LLVM is not involved in the process.  In
particular, the LLVM type system is not suitable for conveying such
information though the compiler.</p></li>
<li><p>Insert any coordination code required for interacting with your collector.
Many collectors require running application code to periodically check a
flag and conditionally call a runtime function.  This is often referred to
as a safepoint poll.</p></li>
</ul>
<p>You will need to identify roots (i.e. references to heap objects your collector
needs to know about) in your generated IR, so that LLVM can encode them into
your final stack maps.  Depending on the collector strategy chosen, this is
accomplished by using either the <code class="docutils literal notranslate"><span class="pre">&#64;llvm.gcroot</span></code> intrinsics or an
<code class="docutils literal notranslate"><span class="pre">gc.statepoint</span></code> relocation sequence.</p>
<p>Don’t forget to create a root for each intermediate value that is generated when
evaluating an expression.  In <code class="docutils literal notranslate"><span class="pre">h(f(),</span> <span class="pre">g())</span></code>, the result of <code class="docutils literal notranslate"><span class="pre">f()</span></code> could
easily be collected if evaluating <code class="docutils literal notranslate"><span class="pre">g()</span></code> triggers a collection.</p>
<p>Finally, you need to link your runtime library with the generated program
executable (for a static compiler) or ensure the appropriate symbols are
available for the runtime linker (for a JIT compiler).</p>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id3">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<div class="section" id="what-is-garbage-collection">
<h3><a class="toc-backref" href="#id4">What is Garbage Collection?</a><a class="headerlink" href="#what-is-garbage-collection" title="Permalink to this headline">¶</a></h3>
<p>Garbage collection is a widely used technique that frees the programmer from
having to know the lifetimes of heap objects, making software easier to produce
and maintain.  Many programming languages rely on garbage collection for
automatic memory management.  There are two primary forms of garbage collection:
conservative and accurate.</p>
<p>Conservative garbage collection often does not require any special support from
either the language or the compiler: it can handle non-type-safe programming
languages (such as C/C++) and does not require any special information from the
compiler.  The <a class="reference external" href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/">Boehm collector</a> is an example of a
state-of-the-art conservative collector.</p>
<p>Accurate garbage collection requires the ability to identify all pointers in the
program at run-time (which requires that the source-language be type-safe in
most cases).  Identifying pointers at run-time requires compiler support to
locate all places that hold live pointer variables at run-time, including the
<a class="reference internal" href="#gcroot"><span class="std std-ref">processor stack and registers</span></a>.</p>
<p>Conservative garbage collection is attractive because it does not require any
special compiler support, but it does have problems.  In particular, because the
conservative garbage collector cannot <em>know</em> that a particular word in the
machine is a pointer, it cannot move live objects in the heap (preventing the
use of compacting and generational GC algorithms) and it can occasionally suffer
from memory leaks due to integer values that happen to point to objects in the
program.  In addition, some aggressive compiler transformations can break
conservative garbage collectors (though these seem rare in practice).</p>
<p>Accurate garbage collectors do not suffer from any of these problems, but they
can suffer from degraded scalar optimization of the program.  In particular,
because the runtime must be able to identify and update all pointers active in
the program, some optimizations are less effective.  In practice, however, the
locality and performance benefits of using aggressive garbage collection
techniques dominates any low-level losses.</p>
<p>This document describes the mechanisms and interfaces provided by LLVM to
support accurate garbage collection.</p>
</div>
<div class="section" id="goals-and-non-goals">
<h3><a class="toc-backref" href="#id5">Goals and non-goals</a><a class="headerlink" href="#goals-and-non-goals" title="Permalink to this headline">¶</a></h3>
<p>LLVM’s intermediate representation provides <a class="reference internal" href="#gc-intrinsics"><span class="std std-ref">garbage collection intrinsics</span></a> that offer support for a broad class of collector models.  For
instance, the intrinsics permit:</p>
<ul class="simple">
<li><p>semi-space collectors</p></li>
<li><p>mark-sweep collectors</p></li>
<li><p>generational collectors</p></li>
<li><p>incremental collectors</p></li>
<li><p>concurrent collectors</p></li>
<li><p>cooperative collectors</p></li>
<li><p>reference counting</p></li>
</ul>
<p>We hope that the support built into the LLVM IR is sufficient to support a
broad class of garbage collected languages including Scheme, ML, Java, C#,
Perl, Python, Lua, Ruby, other scripting languages, and more.</p>
<p>Note that LLVM <strong>does not itself provide a garbage collector</strong> — this should
be part of your language’s runtime library.  LLVM provides a framework for
describing the garbage collectors requirements to the compiler.  In particular,
LLVM provides support for generating stack maps at call sites, polling for a
safepoint, and emitting load and store barriers.  You can also extend LLVM -
possibly through a loadable <a class="reference internal" href="#plugin"><span class="std std-ref">code generation plugins</span></a> - to
generate code and data structures which conforms to the <em>binary interface</em>
specified by the <em>runtime library</em>.  This is similar to the relationship between
LLVM and DWARF debugging info, for example.  The difference primarily lies in
the lack of an established standard in the domain of garbage collection — thus
the need for a flexible extension mechanism.</p>
<p>The aspects of the binary interface with which LLVM’s GC support is
concerned are:</p>
<ul class="simple">
<li><p>Creation of GC safepoints within code where collection is allowed to execute
safely.</p></li>
<li><p>Computation of the stack map.  For each safe point in the code, object
references within the stack frame must be identified so that the collector may
traverse and perhaps update them.</p></li>
<li><p>Write barriers when storing object references to the heap.  These are commonly
used to optimize incremental scans in generational collectors.</p></li>
<li><p>Emission of read barriers when loading object references.  These are useful
for interoperating with concurrent collectors.</p></li>
</ul>
<p>There are additional areas that LLVM does not directly address:</p>
<ul class="simple">
<li><p>Registration of global roots with the runtime.</p></li>
<li><p>Registration of stack map entries with the runtime.</p></li>
<li><p>The functions used by the program to allocate memory, trigger a collection,
etc.</p></li>
<li><p>Computation or compilation of type maps, or registration of them with the
runtime.  These are used to crawl the heap for object references.</p></li>
</ul>
<p>In general, LLVM’s support for GC does not include features which can be
adequately addressed with other features of the IR and does not specify a
particular binary interface.  On the plus side, this means that you should be
able to integrate LLVM with an existing runtime.  On the other hand, it can
have the effect of leaving a lot of work for the developer of a novel
language.  We try to mitigate this by providing built in collector strategy
descriptions that can work with many common collector designs and easy
extension points.  If you don’t already have a specific binary interface
you need to support, we recommend trying to use one of these built in collector
strategies.</p>
</div>
</div>
<div class="section" id="llvm-ir-features">
<span id="gc-intrinsics"></span><h2><a class="toc-backref" href="#id6">LLVM IR Features</a><a class="headerlink" href="#llvm-ir-features" title="Permalink to this headline">¶</a></h2>
<p>This section describes the garbage collection facilities provided by the
<a class="reference internal" href="LangRef.html"><span class="doc">LLVM intermediate representation</span></a>.  The exact behavior of these
IR features is specified by the selected <a class="reference internal" href="#plugin"><span class="std std-ref">GC strategy description</span></a>.</p>
<div class="section" id="specifying-gc-code-generation-gc">
<h3><a class="toc-backref" href="#id7">Specifying GC code generation: <code class="docutils literal notranslate"><span class="pre">gc</span> <span class="pre">&quot;...&quot;</span></code></a><a class="headerlink" href="#specifying-gc-code-generation-gc" title="Permalink to this headline">¶</a></h3>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>define &lt;returntype&gt; @name(...) gc &quot;name&quot; { ... }
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">gc</span></code> function attribute is used to specify the desired GC strategy to the
compiler.  Its programmatic equivalent is the <code class="docutils literal notranslate"><span class="pre">setGC</span></code> method of <code class="docutils literal notranslate"><span class="pre">Function</span></code>.</p>
<p>Setting <code class="docutils literal notranslate"><span class="pre">gc</span> <span class="pre">&quot;name&quot;</span></code> on a function triggers a search for a matching subclass
of GCStrategy.  Some collector strategies are built in.  You can add others
using either the loadable plugin mechanism, or by patching your copy of LLVM.
It is the selected GC strategy which defines the exact nature of the code
generated to support GC.  If none is found, the compiler will raise an error.</p>
<p>Specifying the GC style on a per-function basis allows LLVM to link together
programs that use different garbage collection algorithms (or none at all).</p>
</div>
<div class="section" id="gcroot">
<span id="identifying-gc-roots-on-the-stack"></span><h3><a class="toc-backref" href="#id8">Identifying GC roots on the stack</a><a class="headerlink" href="#gcroot" title="Permalink to this headline">¶</a></h3>
<p>LLVM currently supports two different mechanisms for describing references in
compiled code at safepoints.  <code class="docutils literal notranslate"><span class="pre">llvm.gcroot</span></code> is the older mechanism;
<code class="docutils literal notranslate"><span class="pre">gc.statepoint</span></code> has been added more recently.  At the moment, you can choose
either implementation (on a per <a class="reference internal" href="#plugin"><span class="std std-ref">GC strategy</span></a> basis).  Longer
term, we will probably either migrate away from <code class="docutils literal notranslate"><span class="pre">llvm.gcroot</span></code> entirely, or
substantially merge their implementations. Note that most new development
work is focused on <code class="docutils literal notranslate"><span class="pre">gc.statepoint</span></code>.</p>
<div class="section" id="using-gc-statepoint">
<h4><a class="toc-backref" href="#id9">Using <code class="docutils literal notranslate"><span class="pre">gc.statepoint</span></code></a><a class="headerlink" href="#using-gc-statepoint" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="Statepoints.html"><span class="doc">This page</span></a> contains detailed documentation for
<code class="docutils literal notranslate"><span class="pre">gc.statepoint</span></code>.</p>
</div>
<div class="section" id="using-llvm-gcwrite">
<h4><a class="toc-backref" href="#id10">Using <code class="docutils literal notranslate"><span class="pre">llvm.gcwrite</span></code></a><a class="headerlink" href="#using-llvm-gcwrite" title="Permalink to this headline">¶</a></h4>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">void</span> <span class="vg">@llvm.gcroot</span><span class="p">(</span><span class="k">i8</span><span class="p">**</span> <span class="nv">%ptrloc</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%metadata</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">llvm.gcroot</span></code> intrinsic is used to inform LLVM that a stack variable
references an object on the heap and is to be tracked for garbage collection.
The exact impact on generated code is specified by the Function’s selected
<a class="reference internal" href="#plugin"><span class="std std-ref">GC strategy</span></a>.  All calls to <code class="docutils literal notranslate"><span class="pre">llvm.gcroot</span></code> <strong>must</strong> reside
inside the first basic block.</p>
<p>The first argument <strong>must</strong> be a value referring to an alloca instruction or a
bitcast of an alloca.  The second contains a pointer to metadata that should be
associated with the pointer, and <strong>must</strong> be a constant or global value
address.  If your target collector uses tags, use a null pointer for metadata.</p>
<p>A compiler which performs manual SSA construction <strong>must</strong> ensure that SSA
values representing GC references are stored in to the alloca passed to the
respective <code class="docutils literal notranslate"><span class="pre">gcroot</span></code> before every call site and reloaded after every call.
A compiler which uses mem2reg to raise imperative code using <code class="docutils literal notranslate"><span class="pre">alloca</span></code> into
SSA form need only add a call to <code class="docutils literal notranslate"><span class="pre">&#64;llvm.gcroot</span></code> for those variables which
are pointers into the GC heap.</p>
<p>It is also important to mark intermediate values with <code class="docutils literal notranslate"><span class="pre">llvm.gcroot</span></code>.  For
example, consider <code class="docutils literal notranslate"><span class="pre">h(f(),</span> <span class="pre">g())</span></code>.  Beware leaking the result of <code class="docutils literal notranslate"><span class="pre">f()</span></code> in the
case that <code class="docutils literal notranslate"><span class="pre">g()</span></code> triggers a collection.  Note, that stack variables must be
initialized and marked with <code class="docutils literal notranslate"><span class="pre">llvm.gcroot</span></code> in function’s prologue.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">%metadata</span></code> argument can be used to avoid requiring heap objects to have
‘isa’ pointers or tag bits. [<a class="reference internal" href="#appel89">Appel89</a>, <a class="reference internal" href="#goldberg91">Goldberg91</a>, <a class="reference internal" href="#tolmach94">Tolmach94</a>] If specified,
its value will be tracked along with the location of the pointer in the stack
frame.</p>
<p>Consider the following fragment of Java code:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="o">{</span>
  <span class="n">Object</span> <span class="n">X</span><span class="o">;</span>   <span class="c1">// A null-initialized reference to an object</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>This block (which may be located in the middle of a function or in a loop nest),
could be compiled to this LLVM code:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nl">Entry:</span>
   <span class="c">;; In the entry block for the function, allocate the</span>
   <span class="c">;; stack space for X, which is an LLVM pointer.</span>
   <span class="nv">%X</span> <span class="p">=</span> <span class="k">alloca</span> <span class="nv">%Object</span><span class="p">*</span>

   <span class="c">;; Tell LLVM that the stack space is a stack root.</span>
   <span class="c">;; Java has type-tags on objects, so we pass null as metadata.</span>
   <span class="nv">%tmp</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="nv">%Object</span><span class="p">**</span> <span class="nv">%X</span> <span class="k">to</span> <span class="k">i8</span><span class="p">**</span>
   <span class="k">call</span> <span class="k">void</span> <span class="vg">@llvm.gcroot</span><span class="p">(</span><span class="k">i8</span><span class="p">**</span> <span class="nv">%tmp</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="k">null</span><span class="p">)</span>
   <span class="p">...</span>

   <span class="c">;; &quot;CodeBlock&quot; is the block corresponding to the start</span>
   <span class="c">;;  of the scope above.</span>
<span class="nl">CodeBlock:</span>
   <span class="c">;; Java null-initializes pointers.</span>
   <span class="k">store</span> <span class="nv">%Object</span><span class="p">*</span> <span class="k">null</span><span class="p">,</span> <span class="nv">%Object</span><span class="p">**</span> <span class="nv">%X</span>

   <span class="p">...</span>

   <span class="c">;; As the pointer goes out of scope, store a null value into</span>
   <span class="c">;; it, to indicate that the value is no longer live.</span>
   <span class="k">store</span> <span class="nv">%Object</span><span class="p">*</span> <span class="k">null</span><span class="p">,</span> <span class="nv">%Object</span><span class="p">**</span> <span class="nv">%X</span>
   <span class="p">...</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="reading-and-writing-references-in-the-heap">
<h3><a class="toc-backref" href="#id11">Reading and writing references in the heap</a><a class="headerlink" href="#reading-and-writing-references-in-the-heap" title="Permalink to this headline">¶</a></h3>
<p>Some collectors need to be informed when the mutator (the program that needs
garbage collection) either reads a pointer from or writes a pointer to a field
of a heap object.  The code fragments inserted at these points are called <em>read
barriers</em> and <em>write barriers</em>, respectively.  The amount of code that needs to
be executed is usually quite small and not on the critical path of any
computation, so the overall performance impact of the barrier is tolerable.</p>
<p>Barriers often require access to the <em>object pointer</em> rather than the <em>derived
pointer</em> (which is a pointer to the field within the object).  Accordingly,
these intrinsics take both pointers as separate arguments for completeness.  In
this snippet, <code class="docutils literal notranslate"><span class="pre">%object</span></code> is the object pointer, and <code class="docutils literal notranslate"><span class="pre">%derived</span></code> is the derived
pointer:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="c">;; An array type.</span>
<span class="nv">%class.Array</span> <span class="p">=</span> <span class="k">type</span> <span class="p">{</span> <span class="nv">%class.Object</span><span class="p">,</span> <span class="k">i32</span><span class="p">,</span> <span class="p">[</span><span class="m">0</span> <span class="k">x</span> <span class="nv">%class.Object</span><span class="p">*]</span> <span class="p">}</span>
<span class="p">...</span>

<span class="c">;; Load the object pointer from a gcroot.</span>
<span class="nv">%object</span> <span class="p">=</span> <span class="k">load</span> <span class="nv">%class.Array</span><span class="p">**</span> <span class="nv">%object_addr</span>

<span class="c">;; Compute the derived pointer.</span>
<span class="nv">%derived</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="nv">%object</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">2</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%n</span>
</pre></div>
</div>
<p>LLVM does not enforce this relationship between the object and derived pointer
(although a particular <a class="reference internal" href="#plugin"><span class="std std-ref">collector strategy</span></a> might).  However, it
would be an unusual collector that violated it.</p>
<p>The use of these intrinsics is naturally optional if the target GC does not
require the corresponding barrier.  The GC strategy used with such a collector
should replace the intrinsic calls with the corresponding <code class="docutils literal notranslate"><span class="pre">load</span></code> or
<code class="docutils literal notranslate"><span class="pre">store</span></code> instruction if they are used.</p>
<p>One known deficiency with the current design is that the barrier intrinsics do
not include the size or alignment of the underlying operation performed.  It is
currently assumed that the operation is of pointer size and the alignment is
assumed to be the target machine’s default alignment.</p>
<div class="section" id="write-barrier-llvm-gcwrite">
<h4><a class="toc-backref" href="#id12">Write barrier: <code class="docutils literal notranslate"><span class="pre">llvm.gcwrite</span></code></a><a class="headerlink" href="#write-barrier-llvm-gcwrite" title="Permalink to this headline">¶</a></h4>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">void</span> <span class="vg">@llvm.gcwrite</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%value</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%object</span><span class="p">,</span> <span class="k">i8</span><span class="p">**</span> <span class="nv">%derived</span><span class="p">)</span>
</pre></div>
</div>
<p>For write barriers, LLVM provides the <code class="docutils literal notranslate"><span class="pre">llvm.gcwrite</span></code> intrinsic function.  It
has exactly the same semantics as a non-volatile <code class="docutils literal notranslate"><span class="pre">store</span></code> to the derived
pointer (the third argument).  The exact code generated is specified by the
Function’s selected <a class="reference internal" href="#plugin"><span class="std std-ref">GC strategy</span></a>.</p>
<p>Many important algorithms require write barriers, including generational and
concurrent collectors.  Additionally, write barriers could be used to implement
reference counting.</p>
</div>
<div class="section" id="read-barrier-llvm-gcread">
<h4><a class="toc-backref" href="#id13">Read barrier: <code class="docutils literal notranslate"><span class="pre">llvm.gcread</span></code></a><a class="headerlink" href="#read-barrier-llvm-gcread" title="Permalink to this headline">¶</a></h4>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">i8</span><span class="p">*</span> <span class="vg">@llvm.gcread</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%object</span><span class="p">,</span> <span class="k">i8</span><span class="p">**</span> <span class="nv">%derived</span><span class="p">)</span>
</pre></div>
</div>
<p>For read barriers, LLVM provides the <code class="docutils literal notranslate"><span class="pre">llvm.gcread</span></code> intrinsic function.  It has
exactly the same semantics as a non-volatile <code class="docutils literal notranslate"><span class="pre">load</span></code> from the derived pointer
(the second argument).  The exact code generated is specified by the Function’s
selected <a class="reference internal" href="#plugin"><span class="std std-ref">GC strategy</span></a>.</p>
<p>Read barriers are needed by fewer algorithms than write barriers, and may have a
greater performance impact since pointer reads are more frequent than writes.</p>
</div>
</div>
</div>
<div class="section" id="built-in-gc-strategies">
<span id="builtin-gc-strategies"></span><span id="plugin"></span><h2><a class="toc-backref" href="#id14">Built In GC Strategies</a><a class="headerlink" href="#built-in-gc-strategies" title="Permalink to this headline">¶</a></h2>
<p>LLVM includes built in support for several varieties of garbage collectors.</p>
<div class="section" id="the-shadow-stack-gc">
<h3><a class="toc-backref" href="#id15">The Shadow Stack GC</a><a class="headerlink" href="#the-shadow-stack-gc" title="Permalink to this headline">¶</a></h3>
<p>To use this collector strategy, mark your functions with:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">F</span><span class="p">.</span><span class="n">setGC</span><span class="p">(</span><span class="s">&quot;shadow-stack&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Unlike many GC algorithms which rely on a cooperative code generator to compile
stack maps, this algorithm carefully maintains a linked list of stack roots
[<a class="reference internal" href="#henderson02"><span class="std std-ref">Henderson2002</span></a>].  This so-called “shadow stack” mirrors the
machine stack.  Maintaining this data structure is slower than using a stack map
compiled into the executable as constant data, but has a significant portability
advantage because it requires no special support from the target code generator,
and does not require tricky platform-specific code to crawl the machine stack.</p>
<p>The tradeoff for this simplicity and portability is:</p>
<ul class="simple">
<li><p>High overhead per function call.</p></li>
<li><p>Not thread-safe.</p></li>
</ul>
<p>Still, it’s an easy way to get started.  After your compiler and runtime are up
and running, writing a <a class="reference internal" href="#plugin"><span class="std std-ref">plugin</span></a> will allow you to take advantage
of <a class="reference internal" href="#collector-algos"><span class="std std-ref">more advanced GC features</span></a> of LLVM in order to
improve performance.</p>
<p>The shadow stack doesn’t imply a memory allocation algorithm.  A semispace
collector or building atop <code class="docutils literal notranslate"><span class="pre">malloc</span></code> are great places to start, and can be
implemented with very little code.</p>
<p>When it comes time to collect, however, your runtime needs to traverse the stack
roots, and for this it needs to integrate with the shadow stack.  Luckily, doing
so is very simple. (This code is heavily commented to help you understand the
data structure, but there are only 20 lines of meaningful code.)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// The map for a single function&#39;s stack frame.  One of these is</span>
<span class="c1">///        compiled as constant data into the executable for each function.</span>
<span class="c1">///</span>
<span class="c1">/// Storage of metadata values is elided if the %metadata parameter to</span>
<span class="c1">/// @llvm.gcroot is null.</span>
<span class="k">struct</span> <span class="n">FrameMap</span> <span class="p">{</span>
  <span class="kt">int32_t</span> <span class="n">NumRoots</span><span class="p">;</span>    <span class="c1">//&lt; Number of roots in stack frame.</span>
  <span class="kt">int32_t</span> <span class="n">NumMeta</span><span class="p">;</span>     <span class="c1">//&lt; Number of metadata entries.  May be &lt; NumRoots.</span>
  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">Meta</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">//&lt; Metadata for each root.</span>
<span class="p">};</span>

<span class="c1">/// A link in the dynamic shadow stack.  One of these is embedded in</span>
<span class="c1">///        the stack frame of each function on the call stack.</span>
<span class="k">struct</span> <span class="n">StackEntry</span> <span class="p">{</span>
  <span class="n">StackEntry</span> <span class="o">*</span><span class="n">Next</span><span class="p">;</span>    <span class="c1">//&lt; Link to next stack entry (the caller&#39;s).</span>
  <span class="k">const</span> <span class="n">FrameMap</span> <span class="o">*</span><span class="n">Map</span><span class="p">;</span> <span class="c1">//&lt; Pointer to constant FrameMap.</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">Roots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>      <span class="c1">//&lt; Stack roots (in-place array).</span>
<span class="p">};</span>

<span class="c1">/// The head of the singly-linked list of StackEntries.  Functions push</span>
<span class="c1">///        and pop onto this in their prologue and epilogue.</span>
<span class="c1">///</span>
<span class="c1">/// Since there is only a global list, this technique is not threadsafe.</span>
<span class="n">StackEntry</span> <span class="o">*</span><span class="n">llvm_gc_root_chain</span><span class="p">;</span>

<span class="c1">/// Calls Visitor(root, meta) for each GC root on the stack.</span>
<span class="c1">///        root and meta are exactly the values passed to</span>
<span class="c1">///        @llvm.gcroot.</span>
<span class="c1">///</span>
<span class="c1">/// Visitor could be a function to recursively mark live objects.  Or it</span>
<span class="c1">/// might copy them to another heap or generation.</span>
<span class="c1">///</span>
<span class="c1">/// @param Visitor A function to invoke for every GC root on the stack.</span>
<span class="kt">void</span> <span class="nf">visitGCRoots</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">Visitor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">**</span><span class="n">Root</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">Meta</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">StackEntry</span> <span class="o">*</span><span class="n">R</span> <span class="o">=</span> <span class="n">llvm_gc_root_chain</span><span class="p">;</span> <span class="n">R</span><span class="p">;</span> <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// For roots [0, NumMeta), the metadata pointer is in the FrameMap.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">e</span> <span class="o">=</span> <span class="n">R</span><span class="o">-&gt;</span><span class="n">Map</span><span class="o">-&gt;</span><span class="n">NumMeta</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="n">Visitor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">R</span><span class="o">-&gt;</span><span class="n">Roots</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">R</span><span class="o">-&gt;</span><span class="n">Map</span><span class="o">-&gt;</span><span class="n">Meta</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="c1">// For roots [NumMeta, NumRoots), the metadata pointer is null.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">e</span> <span class="o">=</span> <span class="n">R</span><span class="o">-&gt;</span><span class="n">Map</span><span class="o">-&gt;</span><span class="n">NumRoots</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="n">Visitor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">R</span><span class="o">-&gt;</span><span class="n">Roots</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="the-erlang-and-ocaml-gcs">
<h3><a class="toc-backref" href="#id16">The ‘Erlang’ and ‘Ocaml’ GCs</a><a class="headerlink" href="#the-erlang-and-ocaml-gcs" title="Permalink to this headline">¶</a></h3>
<p>LLVM ships with two example collectors which leverage the <code class="docutils literal notranslate"><span class="pre">gcroot</span></code>
mechanisms.  To our knowledge, these are not actually used by any language
runtime, but they do provide a reasonable starting point for someone interested
in writing an <code class="docutils literal notranslate"><span class="pre">gcroot</span></code> compatible GC plugin.  In particular, these are the
only in tree examples of how to produce a custom binary stack map format using
a <code class="docutils literal notranslate"><span class="pre">gcroot</span></code> strategy.</p>
<p>As there names imply, the binary format produced is intended to model that
used by the Erlang and OCaml compilers respectively.</p>
</div>
<div class="section" id="the-statepoint-example-gc">
<span id="statepoint-example-gc"></span><h3><a class="toc-backref" href="#id17">The Statepoint Example GC</a><a class="headerlink" href="#the-statepoint-example-gc" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">F</span><span class="p">.</span><span class="n">setGC</span><span class="p">(</span><span class="s">&quot;statepoint-example&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>This GC provides an example of how one might use the infrastructure provided
by <code class="docutils literal notranslate"><span class="pre">gc.statepoint</span></code>. This example GC is compatible with the
<a class="reference internal" href="Statepoints.html#placesafepoints"><span class="std std-ref">PlaceSafepoints</span></a> and <a class="reference internal" href="Statepoints.html#rewritestatepointsforgc"><span class="std std-ref">RewriteStatepointsForGC</span></a> utility passes
which simplify <code class="docutils literal notranslate"><span class="pre">gc.statepoint</span></code> sequence insertion. If you need to build a
custom GC strategy around the <code class="docutils literal notranslate"><span class="pre">gc.statepoints</span></code> mechanisms, it is recommended
that you use this one as a starting point.</p>
<p>This GC strategy does not support read or write barriers.  As a result, these
intrinsics are lowered to normal loads and stores.</p>
<p>The stack map format generated by this GC strategy can be found in the
<a class="reference internal" href="StackMaps.html#stackmap-section"><span class="std std-ref">Stack Map Section</span></a> using a format documented <a class="reference internal" href="Statepoints.html#statepoint-stackmap-format"><span class="std std-ref">here</span></a>. This format is intended to be the standard
format supported by LLVM going forward.</p>
</div>
<div class="section" id="the-coreclr-gc">
<h3><a class="toc-backref" href="#id18">The CoreCLR GC</a><a class="headerlink" href="#the-coreclr-gc" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">F</span><span class="p">.</span><span class="n">setGC</span><span class="p">(</span><span class="s">&quot;coreclr&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>This GC leverages the <code class="docutils literal notranslate"><span class="pre">gc.statepoint</span></code> mechanism to support the
<a class="reference external" href="https://github.com/dotnet/coreclr">CoreCLR</a> runtime.</p>
<p>Support for this GC strategy is a work in progress. This strategy will
differ from
<a class="reference internal" href="#statepoint-example-gc"><span class="std std-ref">statepoint-example GC</span></a> strategy in
certain aspects like:</p>
<ul class="simple">
<li><p>Base-pointers of interior pointers are not explicitly
tracked and reported.</p></li>
<li><p>A different format is used for encoding stack maps.</p></li>
<li><p>Safe-point polls are only needed before loop-back edges
and before tail-calls (not needed at function-entry).</p></li>
</ul>
</div>
</div>
<div class="section" id="custom-gc-strategies">
<h2><a class="toc-backref" href="#id19">Custom GC Strategies</a><a class="headerlink" href="#custom-gc-strategies" title="Permalink to this headline">¶</a></h2>
<p>If none of the built in GC strategy descriptions met your needs above, you will
need to define a custom GCStrategy and possibly, a custom LLVM pass to perform
lowering.  Your best example of where to start defining a custom GCStrategy
would be to look at one of the built in strategies.</p>
<p>You may be able to structure this additional code as a loadable plugin library.
Loadable plugins are sufficient if all you need is to enable a different
combination of built in functionality, but if you need to provide a custom
lowering pass, you will need to build a patched version of LLVM.  If you think
you need a patched build, please ask for advice on llvm-dev.  There may be an
easy way we can extend the support to make it work for your use case without
requiring a custom build.</p>
<div class="section" id="collector-requirements">
<h3><a class="toc-backref" href="#id20">Collector Requirements</a><a class="headerlink" href="#collector-requirements" title="Permalink to this headline">¶</a></h3>
<p>You should be able to leverage any existing collector library that includes the following elements:</p>
<ol class="arabic simple">
<li><p>A memory allocator which exposes an allocation function your compiled
code can call.</p></li>
<li><p>A binary format for the stack map.  A stack map describes the location
of references at a safepoint and is used by precise collectors to identify
references within a stack frame on the machine stack. Note that collectors
which conservatively scan the stack don’t require such a structure.</p></li>
<li><p>A stack crawler to discover functions on the call stack, and enumerate the
references listed in the stack map for each call site.</p></li>
<li><p>A mechanism for identifying references in global locations (e.g. global
variables).</p></li>
<li><p>If you collector requires them, an LLVM IR implementation of your collectors
load and store barriers.  Note that since many collectors don’t require
barriers at all, LLVM defaults to lowering such barriers to normal loads
and stores unless you arrange otherwise.</p></li>
</ol>
</div>
<div class="section" id="implementing-a-collector-plugin">
<h3><a class="toc-backref" href="#id21">Implementing a collector plugin</a><a class="headerlink" href="#implementing-a-collector-plugin" title="Permalink to this headline">¶</a></h3>
<p>User code specifies which GC code generation to use with the <code class="docutils literal notranslate"><span class="pre">gc</span></code> function
attribute or, equivalently, with the <code class="docutils literal notranslate"><span class="pre">setGC</span></code> method of <code class="docutils literal notranslate"><span class="pre">Function</span></code>.</p>
<p>To implement a GC plugin, it is necessary to subclass <code class="docutils literal notranslate"><span class="pre">llvm::GCStrategy</span></code>,
which can be accomplished in a few lines of boilerplate code.  LLVM’s
infrastructure provides access to several important algorithms.  For an
uncontroversial collector, all that remains may be to compile LLVM’s computed
stack map to assembly code (using the binary representation expected by the
runtime library).  This can be accomplished in about 100 lines of code.</p>
<p>This is not the appropriate place to implement a garbage collected heap or a
garbage collector itself.  That code should exist in the language’s runtime
library.  The compiler plugin is responsible for generating code which conforms
to the binary interface defined by library, most essentially the <a class="reference internal" href="#stack-map"><span class="std std-ref">stack map</span></a>.</p>
<p>To subclass <code class="docutils literal notranslate"><span class="pre">llvm::GCStrategy</span></code> and register it with the compiler:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// lib/MyGC/MyGC.cpp - Example LLVM GC plugin</span>

<span class="cp">#include</span> <span class="cpf">&quot;llvm/CodeGen/GCStrategy.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;llvm/CodeGen/GCMetadata.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;llvm/Support/Compiler.h&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="k">namespace</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">LLVM_LIBRARY_VISIBILITY</span> <span class="nl">MyGC</span> <span class="p">:</span> <span class="k">public</span> <span class="n">GCStrategy</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">MyGC</span><span class="p">()</span> <span class="p">{}</span>
  <span class="p">};</span>

  <span class="n">GCRegistry</span><span class="o">::</span><span class="n">Add</span><span class="o">&lt;</span><span class="n">MyGC</span><span class="o">&gt;</span>
  <span class="n">X</span><span class="p">(</span><span class="s">&quot;mygc&quot;</span><span class="p">,</span> <span class="s">&quot;My bespoke garbage collector.&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This boilerplate collector does nothing.  More specifically:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm.gcread</span></code> calls are replaced with the corresponding <code class="docutils literal notranslate"><span class="pre">load</span></code>
instruction.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">llvm.gcwrite</span></code> calls are replaced with the corresponding <code class="docutils literal notranslate"><span class="pre">store</span></code>
instruction.</p></li>
<li><p>No safe points are added to the code.</p></li>
<li><p>The stack map is not compiled into the executable.</p></li>
</ul>
<p>Using the LLVM makefiles, this code
can be compiled as a plugin using a simple makefile:</p>
<div class="highlight-make notranslate"><div class="highlight"><pre><span></span><span class="c"># lib/MyGC/Makefile</span>

<span class="nv">LEVEL</span> <span class="o">:=</span> ../..
<span class="nv">LIBRARYNAME</span> <span class="o">=</span> MyGC
<span class="nv">LOADABLE_MODULE</span> <span class="o">=</span> <span class="m">1</span>

<span class="cp">include $(LEVEL)/Makefile.common</span>
</pre></div>
</div>
<p>Once the plugin is compiled, code using it may be compiled using <code class="docutils literal notranslate"><span class="pre">llc</span>
<span class="pre">-load=MyGC.so</span></code> (though MyGC.so may have some other platform-specific
extension):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat sample.ll
define void @f() gc &quot;mygc&quot; {
entry:
  ret void
}
$ llvm-as &lt; sample.ll | llc -load=MyGC.so
</pre></div>
</div>
<p>It is also possible to statically link the collector plugin into tools, such as
a language-specific compiler front-end.</p>
</div>
<div class="section" id="overview-of-available-features">
<span id="collector-algos"></span><h3><a class="toc-backref" href="#id22">Overview of available features</a><a class="headerlink" href="#overview-of-available-features" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">GCStrategy</span></code> provides a range of features through which a plugin may do useful
work.  Some of these are callbacks, some are algorithms that can be enabled,
disabled, or customized.  This matrix summarizes the supported (and planned)
features and correlates them with the collection techniques which typically
require them.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 7%" />
<col style="width: 9%" />
<col style="width: 11%" />
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 15%" />
<col style="width: 11%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Algorithm</p></th>
<th class="head"><p>Done</p></th>
<th class="head"><p>Shadow
stack</p></th>
<th class="head"><p>refcount</p></th>
<th class="head"><p>mark-
sweep</p></th>
<th class="head"><p>copying</p></th>
<th class="head"><p>incremental</p></th>
<th class="head"><p>threaded</p></th>
<th class="head"><p>concurrent</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>stack map</p></td>
<td><p>✔</p></td>
<td></td>
<td></td>
<td><p>✘</p></td>
<td><p>✘</p></td>
<td><p>✘</p></td>
<td><p>✘</p></td>
<td><p>✘</p></td>
</tr>
<tr class="row-odd"><td><p>initialize
roots</p></td>
<td><p>✔</p></td>
<td><p>✘</p></td>
<td><p>✘</p></td>
<td><p>✘</p></td>
<td><p>✘</p></td>
<td><p>✘</p></td>
<td><p>✘</p></td>
<td><p>✘</p></td>
</tr>
<tr class="row-even"><td><p>derived
pointers</p></td>
<td><p>NO</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p><strong>N</strong>*</p></td>
<td><p><strong>N</strong>*</p></td>
</tr>
<tr class="row-odd"><td><p><strong>custom
lowering</strong></p></td>
<td><p>✔</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><em>gcroot</em></p></td>
<td><p>✔</p></td>
<td><p>✘</p></td>
<td><p>✘</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><em>gcwrite</em></p></td>
<td><p>✔</p></td>
<td></td>
<td><p>✘</p></td>
<td></td>
<td></td>
<td><p>✘</p></td>
<td></td>
<td><p>✘</p></td>
</tr>
<tr class="row-even"><td><p><em>gcread</em></p></td>
<td><p>✔</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p>✘</p></td>
</tr>
<tr class="row-odd"><td><p><strong>safe
points</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><em>in
calls</em></p></td>
<td><p>✔</p></td>
<td></td>
<td></td>
<td><p>✘</p></td>
<td><p>✘</p></td>
<td><p>✘</p></td>
<td><p>✘</p></td>
<td><p>✘</p></td>
</tr>
<tr class="row-odd"><td><p><em>before
calls</em></p></td>
<td><p>✔</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p>✘</p></td>
<td><p>✘</p></td>
</tr>
<tr class="row-even"><td><p><em>for
loops</em></p></td>
<td><p>NO</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p><strong>N</strong></p></td>
<td><p><strong>N</strong></p></td>
</tr>
<tr class="row-odd"><td><p><em>before
escape</em></p></td>
<td><p>✔</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p>✘</p></td>
<td><p>✘</p></td>
</tr>
<tr class="row-even"><td><p>emit code
at safe
points</p></td>
<td><p>NO</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p><strong>N</strong></p></td>
<td><p><strong>N</strong></p></td>
</tr>
<tr class="row-odd"><td><p><strong>output</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><em>assembly</em></p></td>
<td><p>✔</p></td>
<td></td>
<td></td>
<td><p>✘</p></td>
<td><p>✘</p></td>
<td><p>✘</p></td>
<td><p>✘</p></td>
<td><p>✘</p></td>
</tr>
<tr class="row-odd"><td><p><em>JIT</em></p></td>
<td><p>NO</p></td>
<td></td>
<td></td>
<td><p><strong>?</strong></p></td>
<td><p><strong>?</strong></p></td>
<td><p><strong>?</strong></p></td>
<td><p><strong>?</strong></p></td>
<td><p><strong>?</strong></p></td>
</tr>
<tr class="row-even"><td><p><em>obj</em></p></td>
<td><p>NO</p></td>
<td></td>
<td></td>
<td><p><strong>?</strong></p></td>
<td><p><strong>?</strong></p></td>
<td><p><strong>?</strong></p></td>
<td><p><strong>?</strong></p></td>
<td><p><strong>?</strong></p></td>
</tr>
<tr class="row-odd"><td><p>live
analysis</p></td>
<td><p>NO</p></td>
<td></td>
<td></td>
<td><p><strong>?</strong></p></td>
<td><p><strong>?</strong></p></td>
<td><p><strong>?</strong></p></td>
<td><p><strong>?</strong></p></td>
<td><p><strong>?</strong></p></td>
</tr>
<tr class="row-even"><td><p>register
map</p></td>
<td><p>NO</p></td>
<td></td>
<td></td>
<td><p><strong>?</strong></p></td>
<td><p><strong>?</strong></p></td>
<td><p><strong>?</strong></p></td>
<td><p><strong>?</strong></p></td>
<td><p><strong>?</strong></p></td>
</tr>
<tr class="row-odd"><td colspan="9"><p>* Derived pointers only pose a hasard to copying collections.</p></td>
</tr>
<tr class="row-even"><td colspan="9"><p><strong>?</strong> denotes a feature which could be utilized if available.</p></td>
</tr>
</tbody>
</table>
<p>To be clear, the collection techniques above are defined as:</p>
<dl class="simple">
<dt>Shadow Stack</dt><dd><p>The mutator carefully maintains a linked list of stack roots.</p>
</dd>
<dt>Reference Counting</dt><dd><p>The mutator maintains a reference count for each object and frees an object
when its count falls to zero.</p>
</dd>
<dt>Mark-Sweep</dt><dd><p>When the heap is exhausted, the collector marks reachable objects starting
from the roots, then deallocates unreachable objects in a sweep phase.</p>
</dd>
<dt>Copying</dt><dd><p>As reachability analysis proceeds, the collector copies objects from one heap
area to another, compacting them in the process.  Copying collectors enable
highly efficient “bump pointer” allocation and can improve locality of
reference.</p>
</dd>
<dt>Incremental</dt><dd><p>(Including generational collectors.) Incremental collectors generally have all
the properties of a copying collector (regardless of whether the mature heap
is compacting), but bring the added complexity of requiring write barriers.</p>
</dd>
<dt>Threaded</dt><dd><p>Denotes a multithreaded mutator; the collector must still stop the mutator
(“stop the world”) before beginning reachability analysis.  Stopping a
multithreaded mutator is a complicated problem.  It generally requires highly
platform-specific code in the runtime, and the production of carefully
designed machine code at safe points.</p>
</dd>
<dt>Concurrent</dt><dd><p>In this technique, the mutator and the collector run concurrently, with the
goal of eliminating pause times.  In a <em>cooperative</em> collector, the mutator
further aids with collection should a pause occur, allowing collection to take
advantage of multiprocessor hosts.  The “stop the world” problem of threaded
collectors is generally still present to a limited extent.  Sophisticated
marking algorithms are necessary.  Read barriers may be necessary.</p>
</dd>
</dl>
<p>As the matrix indicates, LLVM’s garbage collection infrastructure is already
suitable for a wide variety of collectors, but does not currently extend to
multithreaded programs.  This will be added in the future as there is
interest.</p>
</div>
<div class="section" id="computing-stack-maps">
<span id="stack-map"></span><h3><a class="toc-backref" href="#id23">Computing stack maps</a><a class="headerlink" href="#computing-stack-maps" title="Permalink to this headline">¶</a></h3>
<p>LLVM automatically computes a stack map.  One of the most important features
of a <code class="docutils literal notranslate"><span class="pre">GCStrategy</span></code> is to compile this information into the executable in
the binary representation expected by the runtime library.</p>
<p>The stack map consists of the location and identity of each GC root in the
each function in the module.  For each root:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RootNum</span></code>: The index of the root.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">StackOffset</span></code>: The offset of the object relative to the frame pointer.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RootMetadata</span></code>: The value passed as the <code class="docutils literal notranslate"><span class="pre">%metadata</span></code> parameter to the
<code class="docutils literal notranslate"><span class="pre">&#64;llvm.gcroot</span></code> intrinsic.</p></li>
</ul>
<p>Also, for the function as a whole:</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">getFrameSize()</span></code>: The overall size of the function’s initial stack frame,</dt><dd><p>not accounting for any dynamic allocation.</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">roots_size()</span></code>: The count of roots in the function.</p></li>
</ul>
<p>To access the stack map, use <code class="docutils literal notranslate"><span class="pre">GCFunctionMetadata::roots_begin()</span></code> and
-<code class="docutils literal notranslate"><span class="pre">end()</span></code> from the <a class="reference internal" href="#assembly"><span class="std std-ref">GCMetadataPrinter</span></a>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(),</span> <span class="n">E</span> <span class="o">=</span> <span class="n">end</span><span class="p">();</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">E</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">GCFunctionInfo</span> <span class="o">*</span><span class="n">FI</span> <span class="o">=</span> <span class="o">*</span><span class="n">I</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">FrameSize</span> <span class="o">=</span> <span class="n">FI</span><span class="o">-&gt;</span><span class="n">getFrameSize</span><span class="p">();</span>
  <span class="kt">size_t</span> <span class="n">RootCount</span> <span class="o">=</span> <span class="n">FI</span><span class="o">-&gt;</span><span class="n">roots_size</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">GCFunctionInfo</span><span class="o">::</span><span class="n">roots_iterator</span> <span class="n">RI</span> <span class="o">=</span> <span class="n">FI</span><span class="o">-&gt;</span><span class="n">roots_begin</span><span class="p">(),</span>
                                      <span class="n">RE</span> <span class="o">=</span> <span class="n">FI</span><span class="o">-&gt;</span><span class="n">roots_end</span><span class="p">();</span>
                                      <span class="n">RI</span> <span class="o">!=</span> <span class="n">RE</span><span class="p">;</span> <span class="o">++</span><span class="n">RI</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">RootNum</span> <span class="o">=</span> <span class="n">RI</span><span class="o">-&gt;</span><span class="n">Num</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">RootStackOffset</span> <span class="o">=</span> <span class="n">RI</span><span class="o">-&gt;</span><span class="n">StackOffset</span><span class="p">;</span>
    <span class="n">Constant</span> <span class="o">*</span><span class="n">RootMetadata</span> <span class="o">=</span> <span class="n">RI</span><span class="o">-&gt;</span><span class="n">Metadata</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the <code class="docutils literal notranslate"><span class="pre">llvm.gcroot</span></code> intrinsic is eliminated before code generation by a
custom lowering pass, LLVM will compute an empty stack map.  This may be useful
for collector plugins which implement reference counting or a shadow stack.</p>
</div>
<div class="section" id="initializing-roots-to-null">
<span id="init-roots"></span><h3><a class="toc-backref" href="#id24">Initializing roots to null</a><a class="headerlink" href="#initializing-roots-to-null" title="Permalink to this headline">¶</a></h3>
<p>It is recommended that frontends initialize roots explicitly to avoid
potentially confusing the optimizer.  This prevents the GC from visiting
uninitialized pointers, which will almost certainly cause it to crash.</p>
<p>As a fallback, LLVM will automatically initialize each root to <code class="docutils literal notranslate"><span class="pre">null</span></code>
upon entry to the function.  Support for this mode in code generation is
largely a legacy detail to keep old collector implementations working.</p>
</div>
<div class="section" id="custom-lowering-of-intrinsics">
<h3><a class="toc-backref" href="#id25">Custom lowering of intrinsics</a><a class="headerlink" href="#custom-lowering-of-intrinsics" title="Permalink to this headline">¶</a></h3>
<p>For GCs which use barriers or unusual treatment of stack roots, the
implementor is responsibly for providing a custom pass to lower the
intrinsics with the desired semantics.  If you have opted in to custom
lowering of a particular intrinsic your pass <strong>must</strong> eliminate all
instances of the corresponding intrinsic in functions which opt in to
your GC.  The best example of such a pass is the ShadowStackGC and it’s
ShadowStackGCLowering pass.</p>
<p>There is currently no way to register such a custom lowering pass
without building a custom copy of LLVM.</p>
</div>
<div class="section" id="generating-safe-points">
<span id="safe-points"></span><h3><a class="toc-backref" href="#id26">Generating safe points</a><a class="headerlink" href="#generating-safe-points" title="Permalink to this headline">¶</a></h3>
<p>LLVM provides support for associating stackmaps with the return address of
a call.  Any loop or return safepoints required by a given collector design
can be modeled via calls to runtime routines, or potentially patchable call
sequences.  Using gcroot, all call instructions are inferred to be possible
safepoints and will thus have an associated stackmap.</p>
</div>
<div class="section" id="emitting-assembly-code-gcmetadataprinter">
<span id="assembly"></span><h3><a class="toc-backref" href="#id27">Emitting assembly code: <code class="docutils literal notranslate"><span class="pre">GCMetadataPrinter</span></code></a><a class="headerlink" href="#emitting-assembly-code-gcmetadataprinter" title="Permalink to this headline">¶</a></h3>
<p>LLVM allows a plugin to print arbitrary assembly code before and after the rest
of a module’s assembly code.  At the end of the module, the GC can compile the
LLVM stack map into assembly code. (At the beginning, this information is not
yet computed.)</p>
<p>Since AsmWriter and CodeGen are separate components of LLVM, a separate abstract
base class and registry is provided for printing assembly code, the
<code class="docutils literal notranslate"><span class="pre">GCMetadaPrinter</span></code> and <code class="docutils literal notranslate"><span class="pre">GCMetadataPrinterRegistry</span></code>.  The AsmWriter will look
for such a subclass if the <code class="docutils literal notranslate"><span class="pre">GCStrategy</span></code> sets <code class="docutils literal notranslate"><span class="pre">UsesMetadata</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MyGC</span><span class="o">::</span><span class="n">MyGC</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">UsesMetadata</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This separation allows JIT-only clients to be smaller.</p>
<p>Note that LLVM does not currently have analogous APIs to support code generation
in the JIT, nor using the object writers.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// lib/MyGC/MyGCPrinter.cpp - Example LLVM GC printer</span>

<span class="cp">#include</span> <span class="cpf">&quot;llvm/CodeGen/GCMetadataPrinter.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;llvm/Support/Compiler.h&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="k">namespace</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">LLVM_LIBRARY_VISIBILITY</span> <span class="nl">MyGCPrinter</span> <span class="p">:</span> <span class="k">public</span> <span class="n">GCMetadataPrinter</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">beginAssembly</span><span class="p">(</span><span class="n">AsmPrinter</span> <span class="o">&amp;</span><span class="n">AP</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">finishAssembly</span><span class="p">(</span><span class="n">AsmPrinter</span> <span class="o">&amp;</span><span class="n">AP</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="n">GCMetadataPrinterRegistry</span><span class="o">::</span><span class="n">Add</span><span class="o">&lt;</span><span class="n">MyGCPrinter</span><span class="o">&gt;</span>
  <span class="n">X</span><span class="p">(</span><span class="s">&quot;mygc&quot;</span><span class="p">,</span> <span class="s">&quot;My bespoke garbage collector.&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The collector should use <code class="docutils literal notranslate"><span class="pre">AsmPrinter</span></code> to print portable assembly code.  The
collector itself contains the stack map for the entire module, and may access
the <code class="docutils literal notranslate"><span class="pre">GCFunctionInfo</span></code> using its own <code class="docutils literal notranslate"><span class="pre">begin()</span></code> and <code class="docutils literal notranslate"><span class="pre">end()</span></code> methods.  Here’s
a realistic example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;llvm/CodeGen/AsmPrinter.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;llvm/IR/Function.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;llvm/IR/DataLayout.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;llvm/Target/TargetAsmInfo.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;llvm/Target/TargetMachine.h&quot;</span><span class="cp"></span>

<span class="kt">void</span> <span class="n">MyGCPrinter</span><span class="o">::</span><span class="n">beginAssembly</span><span class="p">(</span><span class="n">AsmPrinter</span> <span class="o">&amp;</span><span class="n">AP</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Nothing to do.</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">MyGCPrinter</span><span class="o">::</span><span class="n">finishAssembly</span><span class="p">(</span><span class="n">AsmPrinter</span> <span class="o">&amp;</span><span class="n">AP</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCStreamer</span> <span class="o">&amp;</span><span class="n">OS</span> <span class="o">=</span> <span class="n">AP</span><span class="p">.</span><span class="n">OutStreamer</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">IntPtrSize</span> <span class="o">=</span> <span class="n">AP</span><span class="p">.</span><span class="n">getPointerSize</span><span class="p">();</span>

  <span class="c1">// Put this in the data section.</span>
  <span class="n">OS</span><span class="p">.</span><span class="n">SwitchSection</span><span class="p">(</span><span class="n">AP</span><span class="p">.</span><span class="n">getObjFileLowering</span><span class="p">().</span><span class="n">getDataSection</span><span class="p">());</span>

  <span class="c1">// For each function...</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">iterator</span> <span class="n">FI</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(),</span> <span class="n">FE</span> <span class="o">=</span> <span class="n">end</span><span class="p">();</span> <span class="n">FI</span> <span class="o">!=</span> <span class="n">FE</span><span class="p">;</span> <span class="o">++</span><span class="n">FI</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">GCFunctionInfo</span> <span class="o">&amp;</span><span class="n">MD</span> <span class="o">=</span> <span class="o">**</span><span class="n">FI</span><span class="p">;</span>

    <span class="c1">// A compact GC layout. Emit this data structure:</span>
    <span class="c1">//</span>
    <span class="c1">// struct {</span>
    <span class="c1">//   int32_t PointCount;</span>
    <span class="c1">//   void *SafePointAddress[PointCount];</span>
    <span class="c1">//   int32_t StackFrameSize; // in words</span>
    <span class="c1">//   int32_t StackArity;</span>
    <span class="c1">//   int32_t LiveCount;</span>
    <span class="c1">//   int32_t LiveOffsets[LiveCount];</span>
    <span class="c1">// } __gcmap_&lt;FUNCTIONNAME&gt;;</span>

    <span class="c1">// Align to address width.</span>
    <span class="n">AP</span><span class="p">.</span><span class="n">EmitAlignment</span><span class="p">(</span><span class="n">IntPtrSize</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">3</span><span class="p">);</span>

    <span class="c1">// Emit PointCount.</span>
    <span class="n">OS</span><span class="p">.</span><span class="n">AddComment</span><span class="p">(</span><span class="s">&quot;safe point count&quot;</span><span class="p">);</span>
    <span class="n">AP</span><span class="p">.</span><span class="n">emitInt32</span><span class="p">(</span><span class="n">MD</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

    <span class="c1">// And each safe point...</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">GCFunctionInfo</span><span class="o">::</span><span class="n">iterator</span> <span class="n">PI</span> <span class="o">=</span> <span class="n">MD</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
                                  <span class="n">PE</span> <span class="o">=</span> <span class="n">MD</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">PI</span> <span class="o">!=</span> <span class="n">PE</span><span class="p">;</span> <span class="o">++</span><span class="n">PI</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Emit the address of the safe point.</span>
      <span class="n">OS</span><span class="p">.</span><span class="n">AddComment</span><span class="p">(</span><span class="s">&quot;safe point address&quot;</span><span class="p">);</span>
      <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">Label</span> <span class="o">=</span> <span class="n">PI</span><span class="o">-&gt;</span><span class="n">Label</span><span class="p">;</span>
      <span class="n">AP</span><span class="p">.</span><span class="n">EmitLabelPlusOffset</span><span class="p">(</span><span class="n">Label</span><span class="cm">/*Hi*/</span><span class="p">,</span> <span class="mi">0</span><span class="cm">/*Offset*/</span><span class="p">,</span> <span class="mi">4</span><span class="cm">/*Size*/</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Stack information never change in safe points! Only print info from the</span>
    <span class="c1">// first call-site.</span>
    <span class="n">GCFunctionInfo</span><span class="o">::</span><span class="n">iterator</span> <span class="n">PI</span> <span class="o">=</span> <span class="n">MD</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>

    <span class="c1">// Emit the stack frame size.</span>
    <span class="n">OS</span><span class="p">.</span><span class="n">AddComment</span><span class="p">(</span><span class="s">&quot;stack frame size (in words)&quot;</span><span class="p">);</span>
    <span class="n">AP</span><span class="p">.</span><span class="n">emitInt32</span><span class="p">(</span><span class="n">MD</span><span class="p">.</span><span class="n">getFrameSize</span><span class="p">()</span> <span class="o">/</span> <span class="n">IntPtrSize</span><span class="p">);</span>

    <span class="c1">// Emit stack arity, i.e. the number of stacked arguments.</span>
    <span class="kt">unsigned</span> <span class="n">RegisteredArgs</span> <span class="o">=</span> <span class="n">IntPtrSize</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">?</span> <span class="mi">5</span> <span class="o">:</span> <span class="mi">6</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">StackArity</span> <span class="o">=</span> <span class="n">MD</span><span class="p">.</span><span class="n">getFunction</span><span class="p">().</span><span class="n">arg_size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">RegisteredArgs</span> <span class="o">?</span>
                          <span class="n">MD</span><span class="p">.</span><span class="n">getFunction</span><span class="p">().</span><span class="n">arg_size</span><span class="p">()</span> <span class="o">-</span> <span class="nl">RegisteredArgs</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">OS</span><span class="p">.</span><span class="n">AddComment</span><span class="p">(</span><span class="s">&quot;stack arity&quot;</span><span class="p">);</span>
    <span class="n">AP</span><span class="p">.</span><span class="n">emitInt32</span><span class="p">(</span><span class="n">StackArity</span><span class="p">);</span>

    <span class="c1">// Emit the number of live roots in the function.</span>
    <span class="n">OS</span><span class="p">.</span><span class="n">AddComment</span><span class="p">(</span><span class="s">&quot;live root count&quot;</span><span class="p">);</span>
    <span class="n">AP</span><span class="p">.</span><span class="n">emitInt32</span><span class="p">(</span><span class="n">MD</span><span class="p">.</span><span class="n">live_size</span><span class="p">(</span><span class="n">PI</span><span class="p">));</span>

    <span class="c1">// And for each live root...</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">GCFunctionInfo</span><span class="o">::</span><span class="n">live_iterator</span> <span class="n">LI</span> <span class="o">=</span> <span class="n">MD</span><span class="p">.</span><span class="n">live_begin</span><span class="p">(</span><span class="n">PI</span><span class="p">),</span>
                                       <span class="n">LE</span> <span class="o">=</span> <span class="n">MD</span><span class="p">.</span><span class="n">live_end</span><span class="p">(</span><span class="n">PI</span><span class="p">);</span>
                                       <span class="n">LI</span> <span class="o">!=</span> <span class="n">LE</span><span class="p">;</span> <span class="o">++</span><span class="n">LI</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Emit live root&#39;s offset within the stack frame.</span>
      <span class="n">OS</span><span class="p">.</span><span class="n">AddComment</span><span class="p">(</span><span class="s">&quot;stack index (offset / wordsize)&quot;</span><span class="p">);</span>
      <span class="n">AP</span><span class="p">.</span><span class="n">emitInt32</span><span class="p">(</span><span class="n">LI</span><span class="o">-&gt;</span><span class="n">StackOffset</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="references">
<h2><a class="toc-backref" href="#id28">References</a><a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p id="appel89">[Appel89] Runtime Tags Aren’t Necessary. Andrew W. Appel. Lisp and Symbolic
Computation 19(7):703-705, July 1989.</p>
<p id="goldberg91">[Goldberg91] Tag-free garbage collection for strongly typed programming
languages. Benjamin Goldberg. ACM SIGPLAN PLDI’91.</p>
<p id="tolmach94">[Tolmach94] Tag-free garbage collection using explicit type parameters. Andrew
Tolmach. Proceedings of the 1994 ACM conference on LISP and functional
programming.</p>
<p id="henderson02">[Henderson2002] <a class="reference external" href="http://citeseer.ist.psu.edu/henderson02accurate.html">Accurate Garbage Collection in an Uncooperative Environment</a></p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="WritingAnLLVMPass.html" title="Writing an LLVM Pass"
             >next</a> |</li>
        <li class="right" >
          <a href="HowToUseInstrMappings.html" title="How To Use Instruction Mappings"
             >previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2003-2020, LLVM Project.
      Last updated on 2020-01-13.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.3.1.
    </div>
  </body>
</html>