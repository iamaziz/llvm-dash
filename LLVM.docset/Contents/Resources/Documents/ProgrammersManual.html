

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>LLVM Programmer’s Manual &#8212; LLVM 9 documentation</title>
    <link rel="stylesheet" href="_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="LLVM Extensions" href="Extensions.html" />
    <link rel="prev" title="How to set up LLVM-style RTTI for your class hierarchy" href="HowToSetUpLLVMStyleRTTI.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="Extensions.html" title="LLVM Extensions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="HowToSetUpLLVMStyleRTTI.html" title="How to set up LLVM-style RTTI for your class hierarchy"
             accesskey="P">previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="llvm-programmer-s-manual">
<h1>LLVM Programmer’s Manual<a class="headerlink" href="#llvm-programmer-s-manual" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id8">Introduction</a></p></li>
<li><p><a class="reference internal" href="#general-information" id="id9">General Information</a></p>
<ul>
<li><p><a class="reference internal" href="#the-c-standard-template-library" id="id10">The C++ Standard Template Library</a></p></li>
<li><p><a class="reference internal" href="#other-useful-references" id="id11">Other useful references</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#important-and-useful-llvm-apis" id="id12">Important and useful LLVM APIs</a></p>
<ul>
<li><p><a class="reference internal" href="#the-isa-cast-and-dyn-cast-templates" id="id13">The <code class="docutils literal notranslate"><span class="pre">isa&lt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">cast&lt;&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">dyn_cast&lt;&gt;</span></code> templates</a></p></li>
<li><p><a class="reference internal" href="#passing-strings-the-stringref-and-twine-classes" id="id14">Passing strings (the <code class="docutils literal notranslate"><span class="pre">StringRef</span></code> and <code class="docutils literal notranslate"><span class="pre">Twine</span></code> classes)</a></p>
<ul>
<li><p><a class="reference internal" href="#the-stringref-class" id="id15">The <code class="docutils literal notranslate"><span class="pre">StringRef</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#the-twine-class" id="id16">The <code class="docutils literal notranslate"><span class="pre">Twine</span></code> class</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#formatting-strings-the-formatv-function" id="id17">Formatting strings (the <code class="docutils literal notranslate"><span class="pre">formatv</span></code> function)</a></p>
<ul>
<li><p><a class="reference internal" href="#simple-formatting" id="id18">Simple formatting</a></p></li>
<li><p><a class="reference internal" href="#custom-formatting" id="id19">Custom formatting</a></p></li>
<li><p><a class="reference internal" href="#formatv-examples" id="id20"><code class="docutils literal notranslate"><span class="pre">formatv</span></code> Examples</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#error-handling" id="id21">Error handling</a></p>
<ul>
<li><p><a class="reference internal" href="#programmatic-errors" id="id22">Programmatic Errors</a></p></li>
<li><p><a class="reference internal" href="#recoverable-errors" id="id23">Recoverable Errors</a></p>
<ul>
<li><p><a class="reference internal" href="#stringerror" id="id24">StringError</a></p></li>
<li><p><a class="reference internal" href="#interoperability-with-std-error-code-and-erroror" id="id25">Interoperability with std::error_code and ErrorOr</a></p></li>
<li><p><a class="reference internal" href="#returning-errors-from-error-handlers" id="id26">Returning Errors from error handlers</a></p></li>
<li><p><a class="reference internal" href="#using-exitonerror-to-simplify-tool-code" id="id27">Using ExitOnError to simplify tool code</a></p></li>
<li><p><a class="reference internal" href="#using-cantfail-to-simplify-safe-callsites" id="id28">Using cantFail to simplify safe callsites</a></p></li>
<li><p><a class="reference internal" href="#fallible-constructors" id="id29">Fallible constructors</a></p></li>
<li><p><a class="reference internal" href="#propagating-and-consuming-errors-based-on-types" id="id30">Propagating and consuming errors based on types</a></p></li>
<li><p><a class="reference internal" href="#concatenating-errors-with-joinerrors" id="id31">Concatenating Errors with joinErrors</a></p></li>
<li><p><a class="reference internal" href="#building-fallible-iterators-and-iterator-ranges" id="id32">Building fallible iterators and iterator ranges</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#passing-functions-and-other-callable-objects" id="id33">Passing functions and other callable objects</a></p>
<ul>
<li><p><a class="reference internal" href="#function-template" id="id34">Function template</a></p></li>
<li><p><a class="reference internal" href="#the-function-ref-class-template" id="id35">The <code class="docutils literal notranslate"><span class="pre">function_ref</span></code> class template</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-llvm-debug-macro-and-debug-option" id="id36">The <code class="docutils literal notranslate"><span class="pre">LLVM_DEBUG()</span></code> macro and <code class="docutils literal notranslate"><span class="pre">-debug</span></code> option</a></p>
<ul>
<li><p><a class="reference internal" href="#fine-grained-debug-info-with-debug-type-and-the-debug-only-option" id="id37">Fine grained debug info with <code class="docutils literal notranslate"><span class="pre">DEBUG_TYPE</span></code> and the <code class="docutils literal notranslate"><span class="pre">-debug-only</span></code> option</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-statistic-class-stats-option" id="id38">The <code class="docutils literal notranslate"><span class="pre">Statistic</span></code> class &amp; <code class="docutils literal notranslate"><span class="pre">-stats</span></code> option</a></p></li>
<li><p><a class="reference internal" href="#adding-debug-counters-to-aid-in-debugging-your-code" id="id39">Adding debug counters to aid in debugging your code</a></p></li>
<li><p><a class="reference internal" href="#viewing-graphs-while-debugging-code" id="id40">Viewing graphs while debugging code</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#picking-the-right-data-structure-for-a-task" id="id41">Picking the Right Data Structure for a Task</a></p>
<ul>
<li><p><a class="reference internal" href="#sequential-containers-std-vector-std-list-etc" id="id42">Sequential Containers (std::vector, std::list, etc)</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-adt-arrayref-h" id="id43">llvm/ADT/ArrayRef.h</a></p></li>
<li><p><a class="reference internal" href="#fixed-size-arrays" id="id44">Fixed Size Arrays</a></p></li>
<li><p><a class="reference internal" href="#heap-allocated-arrays" id="id45">Heap Allocated Arrays</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-tinyptrvector-h" id="id46">llvm/ADT/TinyPtrVector.h</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-smallvector-h" id="id47">llvm/ADT/SmallVector.h</a></p></li>
<li><p><a class="reference internal" href="#vector" id="id48">&lt;vector&gt;</a></p></li>
<li><p><a class="reference internal" href="#deque" id="id49">&lt;deque&gt;</a></p></li>
<li><p><a class="reference internal" href="#list" id="id50">&lt;list&gt;</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-ilist-h" id="id51">llvm/ADT/ilist.h</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-packedvector-h" id="id52">llvm/ADT/PackedVector.h</a></p></li>
<li><p><a class="reference internal" href="#ilist-traits" id="id53">ilist_traits</a></p></li>
<li><p><a class="reference internal" href="#iplist" id="id54">iplist</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-ilist-node-h" id="id55">llvm/ADT/ilist_node.h</a></p></li>
<li><p><a class="reference internal" href="#sentinels" id="id56">Sentinels</a></p></li>
<li><p><a class="reference internal" href="#other-sequential-container-options" id="id57">Other Sequential Container options</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#string-like-containers" id="id58">String-like containers</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-adt-stringref-h" id="id59">llvm/ADT/StringRef.h</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-twine-h" id="id60">llvm/ADT/Twine.h</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-smallstring-h" id="id61">llvm/ADT/SmallString.h</a></p></li>
<li><p><a class="reference internal" href="#std-string" id="id62">std::string</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#set-like-containers-std-set-smallset-setvector-etc" id="id63">Set-Like Containers (std::set, SmallSet, SetVector, etc)</a></p>
<ul>
<li><p><a class="reference internal" href="#a-sorted-vector" id="id64">A sorted ‘vector’</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-smallset-h" id="id65">llvm/ADT/SmallSet.h</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-smallptrset-h" id="id66">llvm/ADT/SmallPtrSet.h</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-stringset-h" id="id67">llvm/ADT/StringSet.h</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-denseset-h" id="id68">llvm/ADT/DenseSet.h</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-sparseset-h" id="id69">llvm/ADT/SparseSet.h</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-sparsemultiset-h" id="id70">llvm/ADT/SparseMultiSet.h</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-foldingset-h" id="id71">llvm/ADT/FoldingSet.h</a></p></li>
<li><p><a class="reference internal" href="#set" id="id72">&lt;set&gt;</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-setvector-h" id="id73">llvm/ADT/SetVector.h</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-uniquevector-h" id="id74">llvm/ADT/UniqueVector.h</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-immutableset-h" id="id75">llvm/ADT/ImmutableSet.h</a></p></li>
<li><p><a class="reference internal" href="#other-set-like-container-options" id="id76">Other Set-Like Container Options</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#map-like-containers-std-map-densemap-etc" id="id77">Map-Like Containers (std::map, DenseMap, etc)</a></p>
<ul>
<li><p><a class="reference internal" href="#dss-sortedvectormap" id="id78">A sorted ‘vector’</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-stringmap-h" id="id79">llvm/ADT/StringMap.h</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-indexedmap-h" id="id80">llvm/ADT/IndexedMap.h</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-densemap-h" id="id81">llvm/ADT/DenseMap.h</a></p></li>
<li><p><a class="reference internal" href="#llvm-ir-valuemap-h" id="id82">llvm/IR/ValueMap.h</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-intervalmap-h" id="id83">llvm/ADT/IntervalMap.h</a></p></li>
<li><p><a class="reference internal" href="#map" id="id84">&lt;map&gt;</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-mapvector-h" id="id85">llvm/ADT/MapVector.h</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-inteqclasses-h" id="id86">llvm/ADT/IntEqClasses.h</a></p></li>
<li><p><a class="reference internal" href="#llvm-adt-immutablemap-h" id="id87">llvm/ADT/ImmutableMap.h</a></p></li>
<li><p><a class="reference internal" href="#other-map-like-container-options" id="id88">Other Map-Like Container Options</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#bit-storage-containers-bitvector-sparsebitvector" id="id89">Bit storage containers (BitVector, SparseBitVector)</a></p>
<ul>
<li><p><a class="reference internal" href="#bitvector" id="id90">BitVector</a></p></li>
<li><p><a class="reference internal" href="#smallbitvector" id="id91">SmallBitVector</a></p></li>
<li><p><a class="reference internal" href="#sparsebitvector" id="id92">SparseBitVector</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#debugging" id="id93">Debugging</a></p></li>
<li><p><a class="reference internal" href="#helpful-hints-for-common-operations" id="id94">Helpful Hints for Common Operations</a></p>
<ul>
<li><p><a class="reference internal" href="#basic-inspection-and-traversal-routines" id="id95">Basic Inspection and Traversal Routines</a></p>
<ul>
<li><p><a class="reference internal" href="#iterating-over-the-basicblock-in-a-function" id="id96">Iterating over the <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code> in a <code class="docutils literal notranslate"><span class="pre">Function</span></code></a></p></li>
<li><p><a class="reference internal" href="#iterating-over-the-instruction-in-a-basicblock" id="id97">Iterating over the <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> in a <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code></a></p></li>
<li><p><a class="reference internal" href="#iterating-over-the-instruction-in-a-function" id="id98">Iterating over the <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> in a <code class="docutils literal notranslate"><span class="pre">Function</span></code></a></p></li>
<li><p><a class="reference internal" href="#turning-an-iterator-into-a-class-pointer-and-vice-versa" id="id99">Turning an iterator into a class pointer (and vice-versa)</a></p></li>
<li><p><a class="reference internal" href="#finding-call-sites-a-slightly-more-complex-example" id="id100">Finding call sites: a slightly more complex example</a></p></li>
<li><p><a class="reference internal" href="#treating-calls-and-invokes-the-same-way" id="id101">Treating calls and invokes the same way</a></p></li>
<li><p><a class="reference internal" href="#iterating-over-def-use-use-def-chains" id="id102">Iterating over def-use &amp; use-def chains</a></p></li>
<li><p><a class="reference internal" href="#iterating-over-predecessors-successors-of-blocks" id="id103">Iterating over predecessors &amp; successors of blocks</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#making-simple-changes" id="id104">Making simple changes</a></p>
<ul>
<li><p><a class="reference internal" href="#creating-and-inserting-new-instructions" id="id105">Creating and inserting new <code class="docutils literal notranslate"><span class="pre">Instruction</span></code>s</a></p></li>
<li><p><a class="reference internal" href="#deleting-instructions" id="id106">Deleting Instructions</a></p></li>
<li><p><a class="reference internal" href="#replacing-an-instruction-with-another-value" id="id107">Replacing an Instruction with another Value</a></p>
<ul>
<li><p><a class="reference internal" href="#replacing-individual-instructions" id="id108">Replacing individual instructions</a></p></li>
<li><p><a class="reference internal" href="#schanges-deleting-sub" id="id109">Deleting Instructions</a></p></li>
<li><p><a class="reference internal" href="#replacing-multiple-uses-of-users-and-values" id="id110">Replacing multiple uses of Users and Values</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#deleting-globalvariables" id="id111">Deleting GlobalVariables</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#threads-and-llvm" id="id112">Threads and LLVM</a></p>
<ul>
<li><p><a class="reference internal" href="#ending-execution-with-llvm-shutdown" id="id113">Ending Execution with <code class="docutils literal notranslate"><span class="pre">llvm_shutdown()</span></code></a></p></li>
<li><p><a class="reference internal" href="#lazy-initialization-with-managedstatic" id="id114">Lazy Initialization with <code class="docutils literal notranslate"><span class="pre">ManagedStatic</span></code></a></p></li>
<li><p><a class="reference internal" href="#achieving-isolation-with-llvmcontext" id="id115">Achieving Isolation with <code class="docutils literal notranslate"><span class="pre">LLVMContext</span></code></a></p></li>
<li><p><a class="reference internal" href="#threads-and-the-jit" id="id116">Threads and the JIT</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#advanced-topics" id="id117">Advanced Topics</a></p>
<ul>
<li><p><a class="reference internal" href="#the-valuesymboltable-class" id="id118">The <code class="docutils literal notranslate"><span class="pre">ValueSymbolTable</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#the-user-and-owned-use-classes-memory-layout" id="id119">The <code class="docutils literal notranslate"><span class="pre">User</span></code> and owned <code class="docutils literal notranslate"><span class="pre">Use</span></code> classes’ memory layout</a></p>
<ul>
<li><p><a class="reference internal" href="#interaction-and-relationship-between-user-and-use-objects" id="id120">Interaction and relationship between <code class="docutils literal notranslate"><span class="pre">User</span></code> and <code class="docutils literal notranslate"><span class="pre">Use</span></code> objects</a></p></li>
<li><p><a class="reference internal" href="#the-waymarking-algorithm" id="id121">The waymarking algorithm</a></p></li>
<li><p><a class="reference internal" href="#reference-implementation" id="id122">Reference implementation</a></p></li>
<li><p><a class="reference internal" href="#tagging-considerations" id="id123">Tagging considerations</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#designing-type-hiercharies-and-polymorphic-interfaces" id="id124">Designing Type Hiercharies and Polymorphic Interfaces</a></p></li>
<li><p><a class="reference internal" href="#abi-breaking-checks" id="id125">ABI Breaking Checks</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-core-llvm-class-hierarchy-reference" id="id126">The Core LLVM Class Hierarchy Reference</a></p>
<ul>
<li><p><a class="reference internal" href="#the-type-class-and-derived-types" id="id127">The Type class and Derived Types</a></p>
<ul>
<li><p><a class="reference internal" href="#important-public-methods" id="id128">Important Public Methods</a></p></li>
<li><p><a class="reference internal" href="#important-derived-types" id="id129">Important Derived Types</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-module-class" id="id130">The <code class="docutils literal notranslate"><span class="pre">Module</span></code> class</a></p>
<ul>
<li><p><a class="reference internal" href="#important-public-members-of-the-module-class" id="id131">Important Public Members of the <code class="docutils literal notranslate"><span class="pre">Module</span></code> class</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-value-class" id="id132">The <code class="docutils literal notranslate"><span class="pre">Value</span></code> class</a></p>
<ul>
<li><p><a class="reference internal" href="#important-public-members-of-the-value-class" id="id133">Important Public Members of the <code class="docutils literal notranslate"><span class="pre">Value</span></code> class</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-user-class" id="id134">The <code class="docutils literal notranslate"><span class="pre">User</span></code> class</a></p>
<ul>
<li><p><a class="reference internal" href="#important-public-members-of-the-user-class" id="id135">Important Public Members of the <code class="docutils literal notranslate"><span class="pre">User</span></code> class</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-instruction-class" id="id136">The <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> class</a></p>
<ul>
<li><p><a class="reference internal" href="#important-subclasses-of-the-instruction-class" id="id137">Important Subclasses of the <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#important-public-members-of-the-instruction-class" id="id138">Important Public Members of the <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> class</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-constant-class-and-subclasses" id="id139">The <code class="docutils literal notranslate"><span class="pre">Constant</span></code> class and subclasses</a></p>
<ul>
<li><p><a class="reference internal" href="#important-subclasses-of-constant" id="id140">Important Subclasses of Constant</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-globalvalue-class" id="id141">The <code class="docutils literal notranslate"><span class="pre">GlobalValue</span></code> class</a></p>
<ul>
<li><p><a class="reference internal" href="#important-public-members-of-the-globalvalue-class" id="id142">Important Public Members of the <code class="docutils literal notranslate"><span class="pre">GlobalValue</span></code> class</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-function-class" id="id143">The <code class="docutils literal notranslate"><span class="pre">Function</span></code> class</a></p>
<ul>
<li><p><a class="reference internal" href="#important-public-members-of-the-function" id="id144">Important Public Members of the <code class="docutils literal notranslate"><span class="pre">Function</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-globalvariable-class" id="id145">The <code class="docutils literal notranslate"><span class="pre">GlobalVariable</span></code> class</a></p>
<ul>
<li><p><a class="reference internal" href="#important-public-members-of-the-globalvariable-class" id="id146">Important Public Members of the <code class="docutils literal notranslate"><span class="pre">GlobalVariable</span></code> class</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-basicblock-class" id="id147">The <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code> class</a></p>
<ul>
<li><p><a class="reference internal" href="#important-public-members-of-the-basicblock-class" id="id148">Important Public Members of the <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code> class</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-argument-class" id="id149">The <code class="docutils literal notranslate"><span class="pre">Argument</span></code> class</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is always a work in progress.</p>
</div>
<div class="section" id="introduction">
<span id="id1"></span><h2><a class="toc-backref" href="#id8">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document is meant to highlight some of the important classes and interfaces
available in the LLVM source-base.  This manual is not intended to explain what
LLVM is, how it works, and what LLVM code looks like.  It assumes that you know
the basics of LLVM and are interested in writing transformations or otherwise
analyzing or manipulating the code.</p>
<p>This document should get you oriented so that you can find your way in the
continuously growing source code that makes up the LLVM infrastructure.  Note
that this manual is not intended to serve as a replacement for reading the
source code, so if you think there should be a method in one of these classes to
do something, but it’s not listed, check the source.  Links to the <a class="reference external" href="http://llvm.org/doxygen/">doxygen</a> sources are provided to make this as easy as
possible.</p>
<p>The first section of this document describes general information that is useful
to know when working in the LLVM infrastructure, and the second describes the
Core LLVM classes.  In the future this manual will be extended with information
describing how to use extension libraries, such as dominator information, CFG
traversal routines, and useful utilities like the <code class="docutils literal notranslate"><span class="pre">InstVisitor</span></code> (<a class="reference external" href="http://llvm.org/doxygen/InstVisitor_8h_source.html">doxygen</a>) template.</p>
</div>
<div class="section" id="general-information">
<span id="general"></span><h2><a class="toc-backref" href="#id9">General Information</a><a class="headerlink" href="#general-information" title="Permalink to this headline">¶</a></h2>
<p>This section contains general information that is useful if you are working in
the LLVM source-base, but that isn’t specific to any particular API.</p>
<div class="section" id="the-c-standard-template-library">
<span id="stl"></span><h3><a class="toc-backref" href="#id10">The C++ Standard Template Library</a><a class="headerlink" href="#the-c-standard-template-library" title="Permalink to this headline">¶</a></h3>
<p>LLVM makes heavy use of the C++ Standard Template Library (STL), perhaps much
more than you are used to, or have seen before.  Because of this, you might want
to do a little background reading in the techniques used and capabilities of the
library.  There are many good pages that discuss the STL, and several books on
the subject that you can get, so it will not be discussed in this document.</p>
<p>Here are some useful links:</p>
<ol class="arabic simple">
<li><p><a class="reference external" href="http://en.cppreference.com/w/">cppreference.com</a> - an excellent
reference for the STL and other parts of the standard C++ library.</p></li>
<li><p><a class="reference external" href="http://www.tempest-sw.com/cpp/">C++ In a Nutshell</a> - This is an O’Reilly
book in the making.  It has a decent Standard Library Reference that rivals
Dinkumware’s, and is unfortunately no longer free since the book has been
published.</p></li>
<li><p><a class="reference external" href="http://www.parashift.com/c++-faq-lite/">C++ Frequently Asked Questions</a>.</p></li>
<li><p><a class="reference external" href="http://www.sgi.com/tech/stl/">SGI’s STL Programmer’s Guide</a> - Contains a
useful <a class="reference external" href="http://www.sgi.com/tech/stl/stl_introduction.html">Introduction to the STL</a>.</p></li>
<li><p><a class="reference external" href="http://www.research.att.com/%7Ebs/C++.html">Bjarne Stroustrup’s C++ Page</a>.</p></li>
<li><p><a class="reference external" href="http://www.mindview.net/Books/TICPP/ThinkingInCPP2e.html">Bruce Eckel’s Thinking in C++, 2nd ed. Volume 2 Revision 4.0
(even better, get the book)</a>.</p></li>
</ol>
<p>You are also encouraged to take a look at the <a class="reference internal" href="CodingStandards.html"><span class="doc">LLVM Coding Standards</span></a> guide which focuses on how to write maintainable code more
than where to put your curly braces.</p>
</div>
<div class="section" id="other-useful-references">
<span id="resources"></span><h3><a class="toc-backref" href="#id11">Other useful references</a><a class="headerlink" href="#other-useful-references" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p><a class="reference external" href="http://www.fortran-2000.com/ArnaudRecipes/sharedlib.html">Using static and shared libraries across platforms</a></p></li>
</ol>
</div>
</div>
<div class="section" id="important-and-useful-llvm-apis">
<span id="apis"></span><h2><a class="toc-backref" href="#id12">Important and useful LLVM APIs</a><a class="headerlink" href="#important-and-useful-llvm-apis" title="Permalink to this headline">¶</a></h2>
<p>Here we highlight some LLVM APIs that are generally useful and good to know
about when writing transformations.</p>
<div class="section" id="the-isa-cast-and-dyn-cast-templates">
<span id="isa"></span><h3><a class="toc-backref" href="#id13">The <code class="docutils literal notranslate"><span class="pre">isa&lt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">cast&lt;&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">dyn_cast&lt;&gt;</span></code> templates</a><a class="headerlink" href="#the-isa-cast-and-dyn-cast-templates" title="Permalink to this headline">¶</a></h3>
<p>The LLVM source-base makes extensive use of a custom form of RTTI.  These
templates have many similarities to the C++ <code class="docutils literal notranslate"><span class="pre">dynamic_cast&lt;&gt;</span></code> operator, but
they don’t have some drawbacks (primarily stemming from the fact that
<code class="docutils literal notranslate"><span class="pre">dynamic_cast&lt;&gt;</span></code> only works on classes that have a v-table).  Because they are
used so often, you must know what they do and how they work.  All of these
templates are defined in the <code class="docutils literal notranslate"><span class="pre">llvm/Support/Casting.h</span></code> (<a class="reference external" href="http://llvm.org/doxygen/Casting_8h_source.html">doxygen</a>) file (note that you very
rarely have to include this file directly).</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">isa&lt;&gt;</span></code>:</dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">isa&lt;&gt;</span></code> operator works exactly like the Java “<code class="docutils literal notranslate"><span class="pre">instanceof</span></code>” operator.
It returns true or false depending on whether a reference or pointer points to
an instance of the specified class.  This can be very useful for constraint
checking of various sorts (example below).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cast&lt;&gt;</span></code>:</dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">cast&lt;&gt;</span></code> operator is a “checked cast” operation.  It converts a pointer
or reference from a base class to a derived class, causing an assertion
failure if it is not really an instance of the right type.  This should be
used in cases where you have some information that makes you believe that
something is of the right type.  An example of the <code class="docutils literal notranslate"><span class="pre">isa&lt;&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">cast&lt;&gt;</span></code>
template is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">isLoopInvariant</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">Loop</span> <span class="o">*</span><span class="n">L</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">Constant</span><span class="o">&gt;</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">||</span> <span class="n">isa</span><span class="o">&lt;</span><span class="n">Argument</span><span class="o">&gt;</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">||</span> <span class="n">isa</span><span class="o">&lt;</span><span class="n">GlobalValue</span><span class="o">&gt;</span><span class="p">(</span><span class="n">V</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

  <span class="c1">// Otherwise, it must be an instruction...</span>
  <span class="k">return</span> <span class="o">!</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">contains</span><span class="p">(</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">Instruction</span><span class="o">&gt;</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that you should <strong>not</strong> use an <code class="docutils literal notranslate"><span class="pre">isa&lt;&gt;</span></code> test followed by a <code class="docutils literal notranslate"><span class="pre">cast&lt;&gt;</span></code>,
for that use the <code class="docutils literal notranslate"><span class="pre">dyn_cast&lt;&gt;</span></code> operator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dyn_cast&lt;&gt;</span></code>:</dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">dyn_cast&lt;&gt;</span></code> operator is a “checking cast” operation.  It checks to see
if the operand is of the specified type, and if so, returns a pointer to it
(this operator does not work with references).  If the operand is not of the
correct type, a null pointer is returned.  Thus, this works very much like
the <code class="docutils literal notranslate"><span class="pre">dynamic_cast&lt;&gt;</span></code> operator in C++, and should be used in the same
circumstances.  Typically, the <code class="docutils literal notranslate"><span class="pre">dyn_cast&lt;&gt;</span></code> operator is used in an <code class="docutils literal notranslate"><span class="pre">if</span></code>
statement or some other flow control statement like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="o">*</span><span class="n">AI</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">AllocationInst</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Val</span><span class="p">))</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This form of the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement effectively combines together a call to
<code class="docutils literal notranslate"><span class="pre">isa&lt;&gt;</span></code> and a call to <code class="docutils literal notranslate"><span class="pre">cast&lt;&gt;</span></code> into one statement, which is very
convenient.</p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">dyn_cast&lt;&gt;</span></code> operator, like C++’s <code class="docutils literal notranslate"><span class="pre">dynamic_cast&lt;&gt;</span></code> or Java’s
<code class="docutils literal notranslate"><span class="pre">instanceof</span></code> operator, can be abused.  In particular, you should not use big
chained <code class="docutils literal notranslate"><span class="pre">if/then/else</span></code> blocks to check for lots of different variants of
classes.  If you find yourself wanting to do this, it is much cleaner and more
efficient to use the <code class="docutils literal notranslate"><span class="pre">InstVisitor</span></code> class to dispatch over the instruction
type directly.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">isa_and_nonnull&lt;&gt;</span></code>:</dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">isa_and_nonnull&lt;&gt;</span></code> operator works just like the <code class="docutils literal notranslate"><span class="pre">isa&lt;&gt;</span></code> operator,
except that it allows for a null pointer as an argument (which it then
returns false).  This can sometimes be useful, allowing you to combine several
null checks into one.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cast_or_null&lt;&gt;</span></code>:</dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">cast_or_null&lt;&gt;</span></code> operator works just like the <code class="docutils literal notranslate"><span class="pre">cast&lt;&gt;</span></code> operator,
except that it allows for a null pointer as an argument (which it then
propagates).  This can sometimes be useful, allowing you to combine several
null checks into one.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dyn_cast_or_null&lt;&gt;</span></code>:</dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">dyn_cast_or_null&lt;&gt;</span></code> operator works just like the <code class="docutils literal notranslate"><span class="pre">dyn_cast&lt;&gt;</span></code>
operator, except that it allows for a null pointer as an argument (which it
then propagates).  This can sometimes be useful, allowing you to combine
several null checks into one.</p>
</dd>
</dl>
<p>These five templates can be used with any classes, whether they have a v-table
or not.  If you want to add support for these templates, see the document
<a class="reference internal" href="HowToSetUpLLVMStyleRTTI.html"><span class="doc">How to set up LLVM-style RTTI for your class hierarchy</span></a></p>
</div>
<div class="section" id="passing-strings-the-stringref-and-twine-classes">
<span id="string-apis"></span><h3><a class="toc-backref" href="#id14">Passing strings (the <code class="docutils literal notranslate"><span class="pre">StringRef</span></code> and <code class="docutils literal notranslate"><span class="pre">Twine</span></code> classes)</a><a class="headerlink" href="#passing-strings-the-stringref-and-twine-classes" title="Permalink to this headline">¶</a></h3>
<p>Although LLVM generally does not do much string manipulation, we do have several
important APIs which take strings.  Two important examples are the Value class
– which has names for instructions, functions, etc. – and the <code class="docutils literal notranslate"><span class="pre">StringMap</span></code>
class which is used extensively in LLVM and Clang.</p>
<p>These are generic classes, and they need to be able to accept strings which may
have embedded null characters.  Therefore, they cannot simply take a <code class="docutils literal notranslate"><span class="pre">const</span>
<span class="pre">char</span> <span class="pre">*</span></code>, and taking a <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">std::string&amp;</span></code> requires clients to perform a heap
allocation which is usually unnecessary.  Instead, many LLVM APIs use a
<code class="docutils literal notranslate"><span class="pre">StringRef</span></code> or a <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">Twine&amp;</span></code> for passing strings efficiently.</p>
<div class="section" id="the-stringref-class">
<span id="stringref"></span><h4><a class="toc-backref" href="#id15">The <code class="docutils literal notranslate"><span class="pre">StringRef</span></code> class</a><a class="headerlink" href="#the-stringref-class" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">StringRef</span></code> data type represents a reference to a constant string (a
character array and a length) and supports the common operations available on
<code class="docutils literal notranslate"><span class="pre">std::string</span></code>, but does not require heap allocation.</p>
<p>It can be implicitly constructed using a C style null-terminated string, an
<code class="docutils literal notranslate"><span class="pre">std::string</span></code>, or explicitly with a character pointer and length.  For
example, the <code class="docutils literal notranslate"><span class="pre">StringRef</span></code> find function is declared as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">iterator</span> <span class="nf">find</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Key</span><span class="p">);</span>
</pre></div>
</div>
<p>and clients can call it using any one of:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Map</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">);</span>                 <span class="c1">// Lookup &quot;foo&quot;</span>
<span class="n">Map</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">));</span>    <span class="c1">// Lookup &quot;bar&quot;</span>
<span class="n">Map</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\0</span><span class="s">baz&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">));</span> <span class="c1">// Lookup &quot;\0baz&quot;</span>
</pre></div>
</div>
<p>Similarly, APIs which need to return a string may return a <code class="docutils literal notranslate"><span class="pre">StringRef</span></code>
instance, which can be used directly or converted to an <code class="docutils literal notranslate"><span class="pre">std::string</span></code> using
the <code class="docutils literal notranslate"><span class="pre">str</span></code> member function.  See <code class="docutils literal notranslate"><span class="pre">llvm/ADT/StringRef.h</span></code> (<a class="reference external" href="http://llvm.org/doxygen/StringRef_8h_source.html">doxygen</a>) for more
information.</p>
<p>You should rarely use the <code class="docutils literal notranslate"><span class="pre">StringRef</span></code> class directly, because it contains
pointers to external memory it is not generally safe to store an instance of the
class (unless you know that the external storage will not be freed).
<code class="docutils literal notranslate"><span class="pre">StringRef</span></code> is small and pervasive enough in LLVM that it should always be
passed by value.</p>
</div>
<div class="section" id="the-twine-class">
<h4><a class="toc-backref" href="#id16">The <code class="docutils literal notranslate"><span class="pre">Twine</span></code> class</a><a class="headerlink" href="#the-twine-class" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">Twine</span></code> (<a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Twine.html">doxygen</a>)
class is an efficient way for APIs to accept concatenated strings.  For example,
a common LLVM paradigm is to name one instruction based on the name of another
instruction with a suffix, for example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">New</span> <span class="o">=</span> <span class="n">CmpInst</span><span class="o">::</span><span class="n">Create</span><span class="p">(...,</span> <span class="n">SO</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot;.cmp&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Twine</span></code> class is effectively a lightweight <a class="reference external" href="http://en.wikipedia.org/wiki/Rope_(computer_science)">rope</a> which points to
temporary (stack allocated) objects.  Twines can be implicitly constructed as
the result of the plus operator applied to strings (i.e., a C strings, an
<code class="docutils literal notranslate"><span class="pre">std::string</span></code>, or a <code class="docutils literal notranslate"><span class="pre">StringRef</span></code>).  The twine delays the actual concatenation
of strings until it is actually required, at which point it can be efficiently
rendered directly into a character array.  This avoids unnecessary heap
allocation involved in constructing the temporary results of string
concatenation.  See <code class="docutils literal notranslate"><span class="pre">llvm/ADT/Twine.h</span></code> (<a class="reference external" href="http://llvm.org/doxygen/Twine_8h_source.html">doxygen</a>) and <a class="reference internal" href="#dss-twine"><span class="std std-ref">here</span></a>
for more information.</p>
<p>As with a <code class="docutils literal notranslate"><span class="pre">StringRef</span></code>, <code class="docutils literal notranslate"><span class="pre">Twine</span></code> objects point to external memory and should
almost never be stored or mentioned directly.  They are intended solely for use
when defining a function which should be able to efficiently accept concatenated
strings.</p>
</div>
</div>
<div class="section" id="formatting-strings-the-formatv-function">
<span id="formatting-strings"></span><h3><a class="toc-backref" href="#id17">Formatting strings (the <code class="docutils literal notranslate"><span class="pre">formatv</span></code> function)</a><a class="headerlink" href="#formatting-strings-the-formatv-function" title="Permalink to this headline">¶</a></h3>
<p>While LLVM doesn’t necessarily do a lot of string manipulation and parsing, it
does do a lot of string formatting.  From diagnostic messages, to llvm tool
outputs such as <code class="docutils literal notranslate"><span class="pre">llvm-readobj</span></code> to printing verbose disassembly listings and
LLDB runtime logging, the need for string formatting is pervasive.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">formatv</span></code> is similar in spirit to <code class="docutils literal notranslate"><span class="pre">printf</span></code>, but uses a different syntax
which borrows heavily from Python and C#.  Unlike <code class="docutils literal notranslate"><span class="pre">printf</span></code> it deduces the type
to be formatted at compile time, so it does not need a format specifier such as
<code class="docutils literal notranslate"><span class="pre">%d</span></code>.  This reduces the mental overhead of trying to construct portable format
strings, especially for platform-specific types like <code class="docutils literal notranslate"><span class="pre">size_t</span></code> or pointer types.
Unlike both <code class="docutils literal notranslate"><span class="pre">printf</span></code> and Python, it additionally fails to compile if LLVM does
not know how to format the type.  These two properties ensure that the function
is both safer and simpler to use than traditional formatting methods such as
the <code class="docutils literal notranslate"><span class="pre">printf</span></code> family of functions.</p>
<div class="section" id="simple-formatting">
<h4><a class="toc-backref" href="#id18">Simple formatting</a><a class="headerlink" href="#simple-formatting" title="Permalink to this headline">¶</a></h4>
<p>A call to <code class="docutils literal notranslate"><span class="pre">formatv</span></code> involves a single <strong>format string</strong> consisting of 0 or more
<strong>replacement sequences</strong>, followed by a variable length list of <strong>replacement values</strong>.
A replacement sequence is a string of the form <code class="docutils literal notranslate"><span class="pre">{N[[,align]:style]}</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">N</span></code> refers to the 0-based index of the argument from the list of replacement
values.  Note that this means it is possible to reference the same parameter
multiple times, possibly with different style and/or alignment options, in any order.</p>
<p><code class="docutils literal notranslate"><span class="pre">align</span></code> is an optional string specifying the width of the field to format
the value into, and the alignment of the value within the field.  It is specified as
an optional <strong>alignment style</strong> followed by a positive integral <strong>field width</strong>.  The
alignment style can be one of the characters <code class="docutils literal notranslate"><span class="pre">-</span></code> (left align), <code class="docutils literal notranslate"><span class="pre">=</span></code> (center align),
or <code class="docutils literal notranslate"><span class="pre">+</span></code> (right align).  The default is right aligned.</p>
<p><code class="docutils literal notranslate"><span class="pre">style</span></code> is an optional string consisting of a type specific that controls the
formatting of the value.  For example, to format a floating point value as a percentage,
you can use the style option <code class="docutils literal notranslate"><span class="pre">P</span></code>.</p>
</div>
<div class="section" id="custom-formatting">
<h4><a class="toc-backref" href="#id19">Custom formatting</a><a class="headerlink" href="#custom-formatting" title="Permalink to this headline">¶</a></h4>
<p>There are two ways to customize the formatting behavior for a type.</p>
<ol class="arabic simple">
<li><p>Provide a template specialization of <code class="docutils literal notranslate"><span class="pre">llvm::format_provider&lt;T&gt;</span></code> for your
type <code class="docutils literal notranslate"><span class="pre">T</span></code> with the appropriate static format method.</p></li>
</ol>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;&gt;</span>
  <span class="k">struct</span> <span class="n">format_provider</span><span class="o">&lt;</span><span class="n">MyFooBar</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">format</span><span class="p">(</span><span class="k">const</span> <span class="n">MyFooBar</span> <span class="o">&amp;</span><span class="n">V</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">Stream</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">Style</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Do whatever is necessary to format `V` into `Stream`</span>
    <span class="p">}</span>
  <span class="p">};</span>
  <span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MyFooBar</span> <span class="n">X</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">S</span> <span class="o">=</span> <span class="n">formatv</span><span class="p">(</span><span class="s">&quot;{0}&quot;</span><span class="p">,</span> <span class="n">X</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is a useful extensibility mechanism for adding support for formatting your own
custom types with your own custom Style options.  But it does not help when you want
to extend the mechanism for formatting a type that the library already knows how to
format.  For that, we need something else.</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>Provide a <strong>format adapter</strong> inheriting from <code class="docutils literal notranslate"><span class="pre">llvm::FormatAdapter&lt;T&gt;</span></code>.</p></li>
</ol>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">anything</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nl">format_int_custom</span> <span class="p">:</span> <span class="k">public</span> <span class="n">llvm</span><span class="o">::</span><span class="n">FormatAdapter</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">explicit</span> <span class="n">format_int_custom</span><span class="p">(</span><span class="kt">int</span> <span class="n">N</span><span class="p">)</span> <span class="o">:</span> <span class="n">llvm</span><span class="o">::</span><span class="n">FormatAdapter</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="n">format</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">Stream</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">Style</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
      <span class="c1">// Do whatever is necessary to format ``this-&gt;Item`` into ``Stream``</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>
<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">S</span> <span class="o">=</span> <span class="n">formatv</span><span class="p">(</span><span class="s">&quot;{0}&quot;</span><span class="p">,</span> <span class="n">anything</span><span class="o">::</span><span class="n">format_int_custom</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the type is detected to be derived from <code class="docutils literal notranslate"><span class="pre">FormatAdapter&lt;T&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">formatv</span></code>
will call the
<code class="docutils literal notranslate"><span class="pre">format</span></code> method on the argument passing in the specified style.  This allows
one to provide custom formatting of any type, including one which already has
a builtin format provider.</p>
</div></blockquote>
</div>
<div class="section" id="formatv-examples">
<h4><a class="toc-backref" href="#id20"><code class="docutils literal notranslate"><span class="pre">formatv</span></code> Examples</a><a class="headerlink" href="#formatv-examples" title="Permalink to this headline">¶</a></h4>
<p>Below is intended to provide an incomplete set of examples demonstrating
the usage of <code class="docutils literal notranslate"><span class="pre">formatv</span></code>.  More information can be found by reading the
doxygen documentation or by looking at the unit test suite.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">S</span><span class="p">;</span>
<span class="c1">// Simple formatting of basic types and implicit string conversion.</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">formatv</span><span class="p">(</span><span class="s">&quot;{0} ({1:P})&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mf">0.35</span><span class="p">);</span>  <span class="c1">// S == &quot;7 (35.00%)&quot;</span>

<span class="c1">// Out-of-order referencing and multi-referencing</span>
<span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">formatv</span><span class="p">(</span><span class="s">&quot;{0} {2} {1} {0}&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;test&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// prints &quot;1 3 test 1&quot;</span>

<span class="c1">// Left, right, and center alignment</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">formatv</span><span class="p">(</span><span class="s">&quot;{0,7}&quot;</span><span class="p">,</span>  <span class="sc">&#39;a&#39;</span><span class="p">);</span>  <span class="c1">// S == &quot;      a&quot;;</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">formatv</span><span class="p">(</span><span class="s">&quot;{0,-7}&quot;</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>  <span class="c1">// S == &quot;a      &quot;;</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">formatv</span><span class="p">(</span><span class="s">&quot;{0,=7}&quot;</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>  <span class="c1">// S == &quot;   a   &quot;;</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">formatv</span><span class="p">(</span><span class="s">&quot;{0,+7}&quot;</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>  <span class="c1">// S == &quot;      a&quot;;</span>

<span class="c1">// Custom styles</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">formatv</span><span class="p">(</span><span class="s">&quot;{0:N} - {0:x} - {1:E}&quot;</span><span class="p">,</span> <span class="mi">12345</span><span class="p">,</span> <span class="mi">123908342</span><span class="p">);</span> <span class="c1">// S == &quot;12,345 - 0x3039 - 1.24E8&quot;</span>

<span class="c1">// Adapters</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">formatv</span><span class="p">(</span><span class="s">&quot;{0}&quot;</span><span class="p">,</span> <span class="n">fmt_align</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">AlignStyle</span><span class="o">::</span><span class="n">Center</span><span class="p">,</span> <span class="mi">7</span><span class="p">));</span>  <span class="c1">// S == &quot;  42   &quot;</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">formatv</span><span class="p">(</span><span class="s">&quot;{0}&quot;</span><span class="p">,</span> <span class="n">fmt_repeat</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span> <span class="c1">// S == &quot;hihihi&quot;</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">formatv</span><span class="p">(</span><span class="s">&quot;{0}&quot;</span><span class="p">,</span> <span class="n">fmt_pad</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">));</span> <span class="c1">// S == &quot;  hi      &quot;</span>

<span class="c1">// Ranges</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">V</span> <span class="o">=</span> <span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">formatv</span><span class="p">(</span><span class="s">&quot;{0}&quot;</span><span class="p">,</span> <span class="n">make_range</span><span class="p">(</span><span class="n">V</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">V</span><span class="p">.</span><span class="n">end</span><span class="p">()));</span> <span class="c1">// S == &quot;8, 9, 10&quot;</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">formatv</span><span class="p">(</span><span class="s">&quot;{0:$[+]}&quot;</span><span class="p">,</span> <span class="n">make_range</span><span class="p">(</span><span class="n">V</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">V</span><span class="p">.</span><span class="n">end</span><span class="p">()));</span> <span class="c1">// S == &quot;8+9+10&quot;</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">formatv</span><span class="p">(</span><span class="s">&quot;{0:$[ + ]@[x]}&quot;</span><span class="p">,</span> <span class="n">make_range</span><span class="p">(</span><span class="n">V</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">V</span><span class="p">.</span><span class="n">end</span><span class="p">()));</span> <span class="c1">// S == &quot;0x8 + 0x9 + 0xA&quot;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="error-handling">
<span id="error-apis"></span><h3><a class="toc-backref" href="#id21">Error handling</a><a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h3>
<p>Proper error handling helps us identify bugs in our code, and helps end-users
understand errors in their tool usage. Errors fall into two broad categories:
<em>programmatic</em> and <em>recoverable</em>, with different strategies for handling and
reporting.</p>
<div class="section" id="programmatic-errors">
<h4><a class="toc-backref" href="#id22">Programmatic Errors</a><a class="headerlink" href="#programmatic-errors" title="Permalink to this headline">¶</a></h4>
<p>Programmatic errors are violations of program invariants or API contracts, and
represent bugs within the program itself. Our aim is to document invariants, and
to abort quickly at the point of failure (providing some basic diagnostic) when
invariants are broken at runtime.</p>
<p>The fundamental tools for handling programmatic errors are assertions and the
llvm_unreachable function. Assertions are used to express invariant conditions,
and should include a message describing the invariant:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">assert</span><span class="p">(</span><span class="n">isPhysReg</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;All virt regs should have been allocated already.&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The llvm_unreachable function can be used to document areas of control flow
that should never be entered if the program invariants hold:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="p">{</span> <span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">,</span> <span class="n">Baz</span> <span class="p">}</span> <span class="n">X</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span>

<span class="k">switch</span> <span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nl">Foo</span><span class="p">:</span> <span class="cm">/* Handle Foo */</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="nl">Bar</span><span class="p">:</span> <span class="cm">/* Handle Bar */</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">default</span><span class="o">:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;X should be Foo or Bar here&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="recoverable-errors">
<h4><a class="toc-backref" href="#id23">Recoverable Errors</a><a class="headerlink" href="#recoverable-errors" title="Permalink to this headline">¶</a></h4>
<p>Recoverable errors represent an error in the program’s environment, for example
a resource failure (a missing file, a dropped network connection, etc.), or
malformed input. These errors should be detected and communicated to a level of
the program where they can be handled appropriately. Handling the error may be
as simple as reporting the issue to the user, or it may involve attempts at
recovery.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>While it would be ideal to use this error handling scheme throughout
LLVM, there are places where this hasn’t been practical to apply. In
situations where you absolutely must emit a non-programmatic error and
the <code class="docutils literal notranslate"><span class="pre">Error</span></code> model isn’t workable you can call <code class="docutils literal notranslate"><span class="pre">report_fatal_error</span></code>,
which will call installed error handlers, print a message, and exit the
program.</p>
</div>
<p>Recoverable errors are modeled using LLVM’s <code class="docutils literal notranslate"><span class="pre">Error</span></code> scheme. This scheme
represents errors using function return values, similar to classic C integer
error codes, or C++’s <code class="docutils literal notranslate"><span class="pre">std::error_code</span></code>. However, the <code class="docutils literal notranslate"><span class="pre">Error</span></code> class is
actually a lightweight wrapper for user-defined error types, allowing arbitrary
information to be attached to describe the error. This is similar to the way C++
exceptions allow throwing of user-defined types.</p>
<p>Success values are created by calling <code class="docutils literal notranslate"><span class="pre">Error::success()</span></code>, E.g.:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Error</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Do something.</span>
  <span class="c1">// Return success.</span>
  <span class="k">return</span> <span class="n">Error</span><span class="o">::</span><span class="n">success</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Success values are very cheap to construct and return - they have minimal
impact on program performance.</p>
<p>Failure values are constructed using <code class="docutils literal notranslate"><span class="pre">make_error&lt;T&gt;</span></code>, where <code class="docutils literal notranslate"><span class="pre">T</span></code> is any class
that inherits from the ErrorInfo utility, E.g.:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BadFileFormat</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ErrorInfo</span><span class="o">&lt;</span><span class="n">BadFileFormat</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">static</span> <span class="kt">char</span> <span class="n">ID</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Path</span><span class="p">;</span>

  <span class="n">BadFileFormat</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Path</span><span class="p">)</span> <span class="o">:</span> <span class="n">Path</span><span class="p">(</span><span class="n">Path</span><span class="p">.</span><span class="n">str</span><span class="p">())</span> <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">log</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="n">Path</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; is malformed&quot;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="n">convertToErrorCode</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">make_error_code</span><span class="p">(</span><span class="n">object_error</span><span class="o">::</span><span class="n">parse_failed</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">char</span> <span class="n">BadFileFormat</span><span class="o">::</span><span class="n">ID</span><span class="p">;</span> <span class="c1">// This should be declared in the C++ file.</span>

<span class="n">Error</span> <span class="nf">printFormattedFile</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Path</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">check</span> <span class="k">for</span> <span class="n">valid</span> <span class="n">format</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">make_error</span><span class="o">&lt;</span><span class="n">BadFileFormat</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Path</span><span class="p">);</span>
  <span class="c1">// print file contents.</span>
  <span class="k">return</span> <span class="n">Error</span><span class="o">::</span><span class="n">success</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Error values can be implicitly converted to bool: true for error, false for
success, enabling the following idiom:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Error</span> <span class="nf">mayFail</span><span class="p">();</span>

<span class="n">Error</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">Err</span> <span class="o">=</span> <span class="n">mayFail</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">Err</span><span class="p">;</span>
  <span class="c1">// Success! We can proceed.</span>
  <span class="p">...</span>
</pre></div>
</div>
<p>For functions that can fail but need to return a value the <code class="docutils literal notranslate"><span class="pre">Expected&lt;T&gt;</span></code>
utility can be used. Values of this type can be constructed with either a
<code class="docutils literal notranslate"><span class="pre">T</span></code>, or an <code class="docutils literal notranslate"><span class="pre">Error</span></code>. Expected&lt;T&gt; values are also implicitly convertible to
boolean, but with the opposite convention to <code class="docutils literal notranslate"><span class="pre">Error</span></code>: true for success, false
for error. If success, the <code class="docutils literal notranslate"><span class="pre">T</span></code> value can be accessed via the dereference
operator. If failure, the <code class="docutils literal notranslate"><span class="pre">Error</span></code> value can be extracted using the
<code class="docutils literal notranslate"><span class="pre">takeError()</span></code> method. Idiomatic usage looks like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Expected</span><span class="o">&lt;</span><span class="n">FormattedFile</span><span class="o">&gt;</span> <span class="n">openFormattedFile</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Path</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// If badly formatted, return an error.</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">Err</span> <span class="o">=</span> <span class="n">checkFormat</span><span class="p">(</span><span class="n">Path</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Err</span><span class="p">);</span>
  <span class="c1">// Otherwise return a FormattedFile instance.</span>
  <span class="k">return</span> <span class="nf">FormattedFile</span><span class="p">(</span><span class="n">Path</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Error</span> <span class="n">processFormattedFile</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Path</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Try to open a formatted file</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">FileOrErr</span> <span class="o">=</span> <span class="n">openFormattedFile</span><span class="p">(</span><span class="n">Path</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// On success, grab a reference to the file and continue.</span>
    <span class="k">auto</span> <span class="o">&amp;</span><span class="n">File</span> <span class="o">=</span> <span class="o">*</span><span class="n">FileOrErr</span><span class="p">;</span>
    <span class="p">...</span>
  <span class="p">}</span> <span class="k">else</span>
    <span class="c1">// On error, extract the Error value and return it.</span>
    <span class="k">return</span> <span class="n">FileOrErr</span><span class="p">.</span><span class="n">takeError</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If an <code class="docutils literal notranslate"><span class="pre">Expected&lt;T&gt;</span></code> value is in success mode then the <code class="docutils literal notranslate"><span class="pre">takeError()</span></code> method
will return a success value. Using this fact, the above function can be
rewritten as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Error</span> <span class="nf">processFormattedFile</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Path</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Try to open a formatted file</span>
  <span class="k">auto</span> <span class="n">FileOrErr</span> <span class="o">=</span> <span class="n">openFormattedFile</span><span class="p">(</span><span class="n">Path</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">Err</span> <span class="o">=</span> <span class="n">FileOrErr</span><span class="p">.</span><span class="n">takeError</span><span class="p">())</span>
    <span class="c1">// On error, extract the Error value and return it.</span>
    <span class="k">return</span> <span class="n">Err</span><span class="p">;</span>
  <span class="c1">// On success, grab a reference to the file and continue.</span>
  <span class="k">auto</span> <span class="o">&amp;</span><span class="n">File</span> <span class="o">=</span> <span class="o">*</span><span class="n">FileOrErr</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This second form is often more readable for functions that involve multiple
<code class="docutils literal notranslate"><span class="pre">Expected&lt;T&gt;</span></code> values as it limits the indentation required.</p>
<p>All <code class="docutils literal notranslate"><span class="pre">Error</span></code> instances, whether success or failure, must be either checked or
moved from (via <code class="docutils literal notranslate"><span class="pre">std::move</span></code> or a return) before they are destructed.
Accidentally discarding an unchecked error will cause a program abort at the
point where the unchecked value’s destructor is run, making it easy to identify
and fix violations of this rule.</p>
<p>Success values are considered checked once they have been tested (by invoking
the boolean conversion operator):</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">Err</span> <span class="o">=</span> <span class="n">mayFail</span><span class="p">(...))</span>
  <span class="k">return</span> <span class="n">Err</span><span class="p">;</span> <span class="c1">// Failure value - move error to caller.</span>

<span class="c1">// Safe to continue: Err was checked.</span>
</pre></div>
</div>
<p>In contrast, the following code will always cause an abort, even if <code class="docutils literal notranslate"><span class="pre">mayFail</span></code>
returns a success value:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">mayFail</span><span class="p">();</span>
<span class="c1">// Program will always abort here, even if mayFail() returns Success, since</span>
<span class="c1">// the value is not checked.</span>
</pre></div>
</div>
<p>Failure values are considered checked once a handler for the error type has
been activated:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">handleErrors</span><span class="p">(</span>
  <span class="n">processFormattedFile</span><span class="p">(...),</span>
  <span class="p">[](</span><span class="k">const</span> <span class="n">BadFileFormat</span> <span class="o">&amp;</span><span class="n">BFF</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">report</span><span class="p">(</span><span class="s">&quot;Unable to process &quot;</span> <span class="o">+</span> <span class="n">BFF</span><span class="p">.</span><span class="n">Path</span> <span class="o">+</span> <span class="s">&quot;: bad format&quot;</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="p">[](</span><span class="k">const</span> <span class="n">FileNotFound</span> <span class="o">&amp;</span><span class="n">FNF</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">report</span><span class="p">(</span><span class="s">&quot;File not found &quot;</span> <span class="o">+</span> <span class="n">FNF</span><span class="p">.</span><span class="n">Path</span><span class="p">);</span>
  <span class="p">});</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">handleErrors</span></code> function takes an error as its first argument, followed by
a variadic list of “handlers”, each of which must be a callable type (a
function, lambda, or class with a call operator) with one argument. The
<code class="docutils literal notranslate"><span class="pre">handleErrors</span></code> function will visit each handler in the sequence and check its
argument type against the dynamic type of the error, running the first handler
that matches. This is the same decision process that is used decide which catch
clause to run for a C++ exception.</p>
<p>Since the list of handlers passed to <code class="docutils literal notranslate"><span class="pre">handleErrors</span></code> may not cover every error
type that can occur, the <code class="docutils literal notranslate"><span class="pre">handleErrors</span></code> function also returns an Error value
that must be checked or propagated. If the error value that is passed to
<code class="docutils literal notranslate"><span class="pre">handleErrors</span></code> does not match any of the handlers it will be returned from
handleErrors. Idiomatic use of <code class="docutils literal notranslate"><span class="pre">handleErrors</span></code> thus looks like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">Err</span> <span class="o">=</span>
      <span class="n">handleErrors</span><span class="p">(</span>
        <span class="n">processFormattedFile</span><span class="p">(...),</span>
        <span class="p">[](</span><span class="k">const</span> <span class="n">BadFileFormat</span> <span class="o">&amp;</span><span class="n">BFF</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">report</span><span class="p">(</span><span class="s">&quot;Unable to process &quot;</span> <span class="o">+</span> <span class="n">BFF</span><span class="p">.</span><span class="n">Path</span> <span class="o">+</span> <span class="s">&quot;: bad format&quot;</span><span class="p">);</span>
        <span class="p">},</span>
        <span class="p">[](</span><span class="k">const</span> <span class="n">FileNotFound</span> <span class="o">&amp;</span><span class="n">FNF</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">report</span><span class="p">(</span><span class="s">&quot;File not found &quot;</span> <span class="o">+</span> <span class="n">FNF</span><span class="p">.</span><span class="n">Path</span><span class="p">);</span>
        <span class="p">}))</span>
  <span class="k">return</span> <span class="n">Err</span><span class="p">;</span>
</pre></div>
</div>
<p>In cases where you truly know that the handler list is exhaustive the
<code class="docutils literal notranslate"><span class="pre">handleAllErrors</span></code> function can be used instead. This is identical to
<code class="docutils literal notranslate"><span class="pre">handleErrors</span></code> except that it will terminate the program if an unhandled
error is passed in, and can therefore return void. The <code class="docutils literal notranslate"><span class="pre">handleAllErrors</span></code>
function should generally be avoided: the introduction of a new error type
elsewhere in the program can easily turn a formerly exhaustive list of errors
into a non-exhaustive list, risking unexpected program termination. Where
possible, use handleErrors and propagate unknown errors up the stack instead.</p>
<p>For tool code, where errors can be handled by printing an error message then
exiting with an error code, the <a class="reference internal" href="#err-exitonerr"><span class="std std-ref">ExitOnError</span></a> utility
may be a better choice than handleErrors, as it simplifies control flow when
calling fallible functions.</p>
<p>In situations where it is known that a particular call to a fallible function
will always succeed (for example, a call to a function that can only fail on a
subset of inputs with an input that is known to be safe) the
<a class="reference internal" href="#err-cantfail"><span class="std std-ref">cantFail</span></a> functions can be used to remove the error type,
simplifying control flow.</p>
<div class="section" id="stringerror">
<h5><a class="toc-backref" href="#id24">StringError</a><a class="headerlink" href="#stringerror" title="Permalink to this headline">¶</a></h5>
<p>Many kinds of errors have no recovery strategy, the only action that can be
taken is to report them to the user so that the user can attempt to fix the
environment. In this case representing the error as a string makes perfect
sense. LLVM provides the <code class="docutils literal notranslate"><span class="pre">StringError</span></code> class for this purpose. It takes two
arguments: A string error message, and an equivalent <code class="docutils literal notranslate"><span class="pre">std::error_code</span></code> for
interoperability. It also provides a <code class="docutils literal notranslate"><span class="pre">createStringError</span></code> function to simplify
common usage of this class:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// These two lines of code are equivalent:</span>
<span class="n">make_error</span><span class="o">&lt;</span><span class="n">StringError</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Bad executable&quot;</span><span class="p">,</span> <span class="n">errc</span><span class="o">::</span><span class="n">executable_format_error</span><span class="p">);</span>
<span class="n">createStringError</span><span class="p">(</span><span class="n">errc</span><span class="o">::</span><span class="n">executable_format_error</span><span class="p">,</span> <span class="s">&quot;Bad executable&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>If you’re certain that the error you’re building will never need to be converted
to a <code class="docutils literal notranslate"><span class="pre">std::error_code</span></code> you can use the <code class="docutils literal notranslate"><span class="pre">inconvertibleErrorCode()</span></code> function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">createStringError</span><span class="p">(</span><span class="n">inconvertibleErrorCode</span><span class="p">(),</span> <span class="s">&quot;Bad executable&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>This should be done only after careful consideration. If any attempt is made to
convert this error to a <code class="docutils literal notranslate"><span class="pre">std::error_code</span></code> it will trigger immediate program
termination. Unless you are certain that your errors will not need
interoperability you should look for an existing <code class="docutils literal notranslate"><span class="pre">std::error_code</span></code> that you
can convert to, and even (as painful as it is) consider introducing a new one as
a stopgap measure.</p>
<p><code class="docutils literal notranslate"><span class="pre">createStringError</span></code> can take <code class="docutils literal notranslate"><span class="pre">printf</span></code> style format specifiers to provide a
formatted message:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">createStringError</span><span class="p">(</span><span class="n">errc</span><span class="o">::</span><span class="n">executable_format_error</span><span class="p">,</span>
                  <span class="s">&quot;Bad executable: %s&quot;</span><span class="p">,</span> <span class="n">FileName</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="interoperability-with-std-error-code-and-erroror">
<h5><a class="toc-backref" href="#id25">Interoperability with std::error_code and ErrorOr</a><a class="headerlink" href="#interoperability-with-std-error-code-and-erroror" title="Permalink to this headline">¶</a></h5>
<p>Many existing LLVM APIs use <code class="docutils literal notranslate"><span class="pre">std::error_code</span></code> and its partner <code class="docutils literal notranslate"><span class="pre">ErrorOr&lt;T&gt;</span></code>
(which plays the same role as <code class="docutils literal notranslate"><span class="pre">Expected&lt;T&gt;</span></code>, but wraps a <code class="docutils literal notranslate"><span class="pre">std::error_code</span></code>
rather than an <code class="docutils literal notranslate"><span class="pre">Error</span></code>). The infectious nature of error types means that an
attempt to change one of these functions to return <code class="docutils literal notranslate"><span class="pre">Error</span></code> or <code class="docutils literal notranslate"><span class="pre">Expected&lt;T&gt;</span></code>
instead often results in an avalanche of changes to callers, callers of callers,
and so on. (The first such attempt, returning an <code class="docutils literal notranslate"><span class="pre">Error</span></code> from
MachOObjectFile’s constructor, was abandoned after the diff reached 3000 lines,
impacted half a dozen libraries, and was still growing).</p>
<p>To solve this problem, the <code class="docutils literal notranslate"><span class="pre">Error</span></code>/<code class="docutils literal notranslate"><span class="pre">std::error_code</span></code> interoperability requirement was
introduced. Two pairs of functions allow any <code class="docutils literal notranslate"><span class="pre">Error</span></code> value to be converted to a
<code class="docutils literal notranslate"><span class="pre">std::error_code</span></code>, any <code class="docutils literal notranslate"><span class="pre">Expected&lt;T&gt;</span></code> to be converted to an <code class="docutils literal notranslate"><span class="pre">ErrorOr&lt;T&gt;</span></code>, and vice
versa:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="n">errorToErrorCode</span><span class="p">(</span><span class="n">Error</span> <span class="n">Err</span><span class="p">);</span>
<span class="n">Error</span> <span class="nf">errorCodeToError</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="n">EC</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">ErrorOr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">expectedToErrorOr</span><span class="p">(</span><span class="n">Expected</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">TOrErr</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Expected</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">errorOrToExpected</span><span class="p">(</span><span class="n">ErrorOr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">TOrEC</span><span class="p">);</span>
</pre></div>
</div>
<p>Using these APIs it is easy to make surgical patches that update individual
functions from <code class="docutils literal notranslate"><span class="pre">std::error_code</span></code> to <code class="docutils literal notranslate"><span class="pre">Error</span></code>, and from <code class="docutils literal notranslate"><span class="pre">ErrorOr&lt;T&gt;</span></code> to
<code class="docutils literal notranslate"><span class="pre">Expected&lt;T&gt;</span></code>.</p>
</div>
<div class="section" id="returning-errors-from-error-handlers">
<h5><a class="toc-backref" href="#id26">Returning Errors from error handlers</a><a class="headerlink" href="#returning-errors-from-error-handlers" title="Permalink to this headline">¶</a></h5>
<p>Error recovery attempts may themselves fail. For that reason, <code class="docutils literal notranslate"><span class="pre">handleErrors</span></code>
actually recognises three different forms of handler signature:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Error must be handled, no new errors produced:</span>
<span class="kt">void</span><span class="p">(</span><span class="n">UserDefinedError</span> <span class="o">&amp;</span><span class="n">E</span><span class="p">);</span>

<span class="c1">// Error must be handled, new errors can be produced:</span>
<span class="n">Error</span><span class="p">(</span><span class="n">UserDefinedError</span> <span class="o">&amp;</span><span class="n">E</span><span class="p">);</span>

<span class="c1">// Original error can be inspected, then re-wrapped and returned (or a new</span>
<span class="c1">// error can be produced):</span>
<span class="n">Error</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">UserDefinedError</span><span class="o">&gt;</span> <span class="n">E</span><span class="p">);</span>
</pre></div>
</div>
<p>Any error returned from a handler will be returned from the <code class="docutils literal notranslate"><span class="pre">handleErrors</span></code>
function so that it can be handled itself, or propagated up the stack.</p>
</div>
<div class="section" id="using-exitonerror-to-simplify-tool-code">
<span id="err-exitonerr"></span><h5><a class="toc-backref" href="#id27">Using ExitOnError to simplify tool code</a><a class="headerlink" href="#using-exitonerror-to-simplify-tool-code" title="Permalink to this headline">¶</a></h5>
<p>Library code should never call <code class="docutils literal notranslate"><span class="pre">exit</span></code> for a recoverable error, however in tool
code (especially command line tools) this can be a reasonable approach. Calling
<code class="docutils literal notranslate"><span class="pre">exit</span></code> upon encountering an error dramatically simplifies control flow as the
error no longer needs to be propagated up the stack. This allows code to be
written in straight-line style, as long as each fallible call is wrapped in a
check and call to exit. The <code class="docutils literal notranslate"><span class="pre">ExitOnError</span></code> class supports this pattern by
providing call operators that inspect <code class="docutils literal notranslate"><span class="pre">Error</span></code> values, stripping the error away
in the success case and logging to <code class="docutils literal notranslate"><span class="pre">stderr</span></code> then exiting in the failure case.</p>
<p>To use this class, declare a global <code class="docutils literal notranslate"><span class="pre">ExitOnError</span></code> variable in your program:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ExitOnError</span> <span class="n">ExitOnErr</span><span class="p">;</span>
</pre></div>
</div>
<p>Calls to fallible functions can then be wrapped with a call to <code class="docutils literal notranslate"><span class="pre">ExitOnErr</span></code>,
turning them into non-failing calls:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Error</span> <span class="nf">mayFail</span><span class="p">();</span>
<span class="n">Expected</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">mayFail2</span><span class="p">();</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ExitOnErr</span><span class="p">(</span><span class="n">mayFail</span><span class="p">());</span>
  <span class="kt">int</span> <span class="n">X</span> <span class="o">=</span> <span class="n">ExitOnErr</span><span class="p">(</span><span class="n">mayFail2</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>On failure, the error’s log message will be written to <code class="docutils literal notranslate"><span class="pre">stderr</span></code>, optionally
preceded by a string “banner” that can be set by calling the setBanner method. A
mapping can also be supplied from <code class="docutils literal notranslate"><span class="pre">Error</span></code> values to exit codes using the
<code class="docutils literal notranslate"><span class="pre">setExitCodeMapper</span></code> method:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="n">ExitOnErr</span><span class="p">.</span><span class="n">setBanner</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s">&quot; error:&quot;</span><span class="p">);</span>
  <span class="n">ExitOnErr</span><span class="p">.</span><span class="n">setExitCodeMapper</span><span class="p">(</span>
    <span class="p">[](</span><span class="k">const</span> <span class="n">Error</span> <span class="o">&amp;</span><span class="n">Err</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">Err</span><span class="p">.</span><span class="n">isA</span><span class="o">&lt;</span><span class="n">BadFileFormat</span><span class="o">&gt;</span><span class="p">())</span>
        <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
      <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">});</span>
</pre></div>
</div>
<p>Use <code class="docutils literal notranslate"><span class="pre">ExitOnError</span></code> in your tool code where possible as it can greatly improve
readability.</p>
</div>
<div class="section" id="using-cantfail-to-simplify-safe-callsites">
<span id="err-cantfail"></span><h5><a class="toc-backref" href="#id28">Using cantFail to simplify safe callsites</a><a class="headerlink" href="#using-cantfail-to-simplify-safe-callsites" title="Permalink to this headline">¶</a></h5>
<p>Some functions may only fail for a subset of their inputs, so calls using known
safe inputs can be assumed to succeed.</p>
<p>The cantFail functions encapsulate this by wrapping an assertion that their
argument is a success value and, in the case of Expected&lt;T&gt;, unwrapping the
T value:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Error</span> <span class="nf">onlyFailsForSomeXValues</span><span class="p">(</span><span class="kt">int</span> <span class="n">X</span><span class="p">);</span>
<span class="n">Expected</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">onlyFailsForSomeXValues2</span><span class="p">(</span><span class="kt">int</span> <span class="n">X</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cantFail</span><span class="p">(</span><span class="n">onlyFailsForSomeXValues</span><span class="p">(</span><span class="n">KnownSafeValue</span><span class="p">));</span>
  <span class="kt">int</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">cantFail</span><span class="p">(</span><span class="n">onlyFailsForSomeXValues2</span><span class="p">(</span><span class="n">KnownSafeValue</span><span class="p">));</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Like the ExitOnError utility, cantFail simplifies control flow. Their treatment
of error cases is very different however: Where ExitOnError is guaranteed to
terminate the program on an error input, cantFail simply asserts that the result
is success. In debug builds this will result in an assertion failure if an error
is encountered. In release builds the behavior of cantFail for failure values is
undefined. As such, care must be taken in the use of cantFail: clients must be
certain that a cantFail wrapped call really can not fail with the given
arguments.</p>
<p>Use of the cantFail functions should be rare in library code, but they are
likely to be of more use in tool and unit-test code where inputs and/or
mocked-up classes or functions may be known to be safe.</p>
</div>
<div class="section" id="fallible-constructors">
<h5><a class="toc-backref" href="#id29">Fallible constructors</a><a class="headerlink" href="#fallible-constructors" title="Permalink to this headline">¶</a></h5>
<p>Some classes require resource acquisition or other complex initialization that
can fail during construction. Unfortunately constructors can’t return errors,
and having clients test objects after they’re constructed to ensure that they’re
valid is error prone as it’s all too easy to forget the test. To work around
this, use the named constructor idiom and return an <code class="docutils literal notranslate"><span class="pre">Expected&lt;T&gt;</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

  <span class="k">static</span> <span class="n">Expected</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">Create</span><span class="p">(</span><span class="n">Resource</span> <span class="n">R1</span><span class="p">,</span> <span class="n">Resource</span> <span class="n">R2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Error</span> <span class="n">Err</span><span class="p">;</span>
    <span class="n">Foo</span> <span class="nf">F</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="n">Err</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Err</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Err</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">F</span><span class="p">);</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>

  <span class="n">Foo</span><span class="p">(</span><span class="n">Resource</span> <span class="n">R1</span><span class="p">,</span> <span class="n">Resource</span> <span class="n">R2</span><span class="p">,</span> <span class="n">Error</span> <span class="o">&amp;</span><span class="n">Err</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ErrorAsOutParameter</span> <span class="n">EAO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Err</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">Err2</span> <span class="o">=</span> <span class="n">R1</span><span class="p">.</span><span class="n">acquire</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">Err</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Err2</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Err</span> <span class="o">=</span> <span class="n">R2</span><span class="p">.</span><span class="n">acquire</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here, the named constructor passes an <code class="docutils literal notranslate"><span class="pre">Error</span></code> by reference into the actual
constructor, which the constructor can then use to return errors. The
<code class="docutils literal notranslate"><span class="pre">ErrorAsOutParameter</span></code> utility sets the <code class="docutils literal notranslate"><span class="pre">Error</span></code> value’s checked flag on entry
to the constructor so that the error can be assigned to, then resets it on exit
to force the client (the named constructor) to check the error.</p>
<p>By using this idiom, clients attempting to construct a Foo receive either a
well-formed Foo or an Error, never an object in an invalid state.</p>
</div>
<div class="section" id="propagating-and-consuming-errors-based-on-types">
<h5><a class="toc-backref" href="#id30">Propagating and consuming errors based on types</a><a class="headerlink" href="#propagating-and-consuming-errors-based-on-types" title="Permalink to this headline">¶</a></h5>
<p>In some contexts, certain types of error are known to be benign. For example,
when walking an archive, some clients may be happy to skip over badly formatted
object files rather than terminating the walk immediately. Skipping badly
formatted objects could be achieved using an elaborate handler method, but the
Error.h header provides two utilities that make this idiom much cleaner: the
type inspection method, <code class="docutils literal notranslate"><span class="pre">isA</span></code>, and the <code class="docutils literal notranslate"><span class="pre">consumeError</span></code> function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Error</span> <span class="nf">walkArchive</span><span class="p">(</span><span class="n">Archive</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">A</span><span class="p">.</span><span class="n">numMembers</span><span class="p">();</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">ChildOrErr</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">getMember</span><span class="p">(</span><span class="n">I</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">Err</span> <span class="o">=</span> <span class="n">ChildOrErr</span><span class="p">.</span><span class="n">takeError</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">Err</span><span class="p">.</span><span class="n">isA</span><span class="o">&lt;</span><span class="n">BadFileFormat</span><span class="o">&gt;</span><span class="p">())</span>
        <span class="n">consumeError</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Err</span><span class="p">))</span>
      <span class="k">else</span>
        <span class="k">return</span> <span class="n">Err</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="o">&amp;</span><span class="n">Child</span> <span class="o">=</span> <span class="o">*</span><span class="n">ChildOrErr</span><span class="p">;</span>
    <span class="c1">// Use Child</span>
    <span class="p">...</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Error</span><span class="o">::</span><span class="n">success</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="concatenating-errors-with-joinerrors">
<h5><a class="toc-backref" href="#id31">Concatenating Errors with joinErrors</a><a class="headerlink" href="#concatenating-errors-with-joinerrors" title="Permalink to this headline">¶</a></h5>
<p>In the archive walking example above <code class="docutils literal notranslate"><span class="pre">BadFileFormat</span></code> errors are simply
consumed and ignored. If the client had wanted report these errors after
completing the walk over the archive they could use the <code class="docutils literal notranslate"><span class="pre">joinErrors</span></code> utility:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Error</span> <span class="nf">walkArchive</span><span class="p">(</span><span class="n">Archive</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Error</span> <span class="n">DeferredErrs</span> <span class="o">=</span> <span class="n">Error</span><span class="o">::</span><span class="n">success</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">A</span><span class="p">.</span><span class="n">numMembers</span><span class="p">();</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">ChildOrErr</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">getMember</span><span class="p">(</span><span class="n">I</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">Err</span> <span class="o">=</span> <span class="n">ChildOrErr</span><span class="p">.</span><span class="n">takeError</span><span class="p">())</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">Err</span><span class="p">.</span><span class="n">isA</span><span class="o">&lt;</span><span class="n">BadFileFormat</span><span class="o">&gt;</span><span class="p">())</span>
        <span class="n">DeferredErrs</span> <span class="o">=</span> <span class="n">joinErrors</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">DeferredErrs</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Err</span><span class="p">));</span>
      <span class="k">else</span>
        <span class="k">return</span> <span class="n">Err</span><span class="p">;</span>
    <span class="k">auto</span> <span class="o">&amp;</span><span class="n">Child</span> <span class="o">=</span> <span class="o">*</span><span class="n">ChildOrErr</span><span class="p">;</span>
    <span class="c1">// Use Child</span>
    <span class="p">...</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">DeferredErrs</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">joinErrors</span></code> routine builds a special error type called <code class="docutils literal notranslate"><span class="pre">ErrorList</span></code>,
which holds a list of user defined errors. The <code class="docutils literal notranslate"><span class="pre">handleErrors</span></code> routine
recognizes this type and will attempt to handle each of the contained errors in
order. If all contained errors can be handled, <code class="docutils literal notranslate"><span class="pre">handleErrors</span></code> will return
<code class="docutils literal notranslate"><span class="pre">Error::success()</span></code>, otherwise <code class="docutils literal notranslate"><span class="pre">handleErrors</span></code> will concatenate the remaining
errors and return the resulting <code class="docutils literal notranslate"><span class="pre">ErrorList</span></code>.</p>
</div>
<div class="section" id="building-fallible-iterators-and-iterator-ranges">
<h5><a class="toc-backref" href="#id32">Building fallible iterators and iterator ranges</a><a class="headerlink" href="#building-fallible-iterators-and-iterator-ranges" title="Permalink to this headline">¶</a></h5>
<p>The archive walking examples above retrieve archive members by index, however
this requires considerable boiler-plate for iteration and error checking. We can
clean this up by using the “fallible iterator” pattern, which supports the
following natural iteration idiom for fallible containers like Archive:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Error</span> <span class="n">Err</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">Child</span> <span class="p">:</span> <span class="n">Ar</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">(</span><span class="n">Err</span><span class="p">))</span> <span class="p">{</span>
  <span class="c1">// Use Child - only enter the loop when it&#39;s valid</span>

  <span class="c1">// Allow early exit from the loop body, since we know that Err is success</span>
  <span class="c1">// when we&#39;re inside the loop.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">BailOutOn</span><span class="p">(</span><span class="n">Child</span><span class="p">))</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="p">...</span>
<span class="p">}</span>
<span class="c1">// Check Err after the loop to ensure it didn&#39;t break due to an error.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Err</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">Err</span><span class="p">;</span>
</pre></div>
</div>
<p>To enable this idiom, iterators over fallible containers are written in a
natural style, with their <code class="docutils literal notranslate"><span class="pre">++</span></code> and <code class="docutils literal notranslate"><span class="pre">--</span></code> operators replaced with fallible
<code class="docutils literal notranslate"><span class="pre">Error</span> <span class="pre">inc()</span></code> and <code class="docutils literal notranslate"><span class="pre">Error</span> <span class="pre">dec()</span></code> functions. E.g.:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FallibleChildIterator</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">FallibleChildIterator</span><span class="p">(</span><span class="n">Archive</span> <span class="o">&amp;</span><span class="n">A</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">ChildIdx</span><span class="p">);</span>
  <span class="n">Archive</span><span class="o">::</span><span class="n">Child</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">*</span><span class="p">();</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">ArchiveIterator</span> <span class="o">&amp;</span><span class="n">LHS</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">ArchiveIterator</span> <span class="o">&amp;</span><span class="n">RHS</span><span class="p">);</span>

  <span class="c1">// operator++/operator-- replaced with fallible increment / decrement:</span>
  <span class="n">Error</span> <span class="nf">inc</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">A</span><span class="p">.</span><span class="n">childValid</span><span class="p">(</span><span class="n">ChildIdx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">make_error</span><span class="o">&lt;</span><span class="n">BadArchiveMember</span><span class="o">&gt;</span><span class="p">(...);</span>
    <span class="o">++</span><span class="n">ChildIdx</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Error</span><span class="o">::</span><span class="n">success</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">Error</span> <span class="nf">dec</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Instances of this kind of fallible iterator interface are then wrapped with the
fallible_iterator utility which provides <code class="docutils literal notranslate"><span class="pre">operator++</span></code> and <code class="docutils literal notranslate"><span class="pre">operator--</span></code>,
returning any errors via a reference passed in to the wrapper at construction
time. The fallible_iterator wrapper takes care of (a) jumping to the end of the
range on error, and (b) marking the error as checked whenever an iterator is
compared to <code class="docutils literal notranslate"><span class="pre">end</span></code> and found to be inequal (in particular: this marks the
error as checked throughout the body of a range-based for loop), enabling early
exit from the loop without redundant error checking.</p>
<p>Instances of the fallible iterator interface (e.g. FallibleChildIterator above)
are wrapped using the <code class="docutils literal notranslate"><span class="pre">make_fallible_itr</span></code> and <code class="docutils literal notranslate"><span class="pre">make_fallible_end</span></code>
functions. E.g.:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Archive</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">using</span> <span class="n">child_iterator</span> <span class="o">=</span> <span class="n">fallible_iterator</span><span class="o">&lt;</span><span class="n">FallibleChildIterator</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="n">child_iterator</span> <span class="nf">child_begin</span><span class="p">(</span><span class="n">Error</span> <span class="o">&amp;</span><span class="n">Err</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">make_fallible_itr</span><span class="p">(</span><span class="n">FallibleChildIterator</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">Err</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">child_iterator</span> <span class="nf">child_end</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">make_fallible_end</span><span class="p">(</span><span class="n">FallibleChildIterator</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">size</span><span class="p">()));</span>
  <span class="p">}</span>

  <span class="n">iterator_range</span><span class="o">&lt;</span><span class="n">child_iterator</span><span class="o">&gt;</span> <span class="n">children</span><span class="p">(</span><span class="n">Error</span> <span class="o">&amp;</span><span class="n">Err</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">make_range</span><span class="p">(</span><span class="n">child_begin</span><span class="p">(</span><span class="n">Err</span><span class="p">),</span> <span class="n">child_end</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Using the fallible_iterator utility allows for both natural construction of
fallible iterators (using failing <code class="docutils literal notranslate"><span class="pre">inc</span></code> and <code class="docutils literal notranslate"><span class="pre">dec</span></code> operations) and
relatively natural use of c++ iterator/loop idioms.</p>
<p id="function-apis">More information on Error and its related utilities can be found in the
Error.h header file.</p>
</div>
</div>
</div>
<div class="section" id="passing-functions-and-other-callable-objects">
<h3><a class="toc-backref" href="#id33">Passing functions and other callable objects</a><a class="headerlink" href="#passing-functions-and-other-callable-objects" title="Permalink to this headline">¶</a></h3>
<p>Sometimes you may want a function to be passed a callback object. In order to
support lambda expressions and other function objects, you should not use the
traditional C approach of taking a function pointer and an opaque cookie:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">takeCallback</span><span class="p">(</span><span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">Callback</span><span class="p">)(</span><span class="n">Function</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">Cookie</span><span class="p">);</span>
</pre></div>
</div>
<p>Instead, use one of the following approaches:</p>
<div class="section" id="function-template">
<h4><a class="toc-backref" href="#id34">Function template</a><a class="headerlink" href="#function-template" title="Permalink to this headline">¶</a></h4>
<p>If you don’t mind putting the definition of your function into a header file,
make it a function template that is templated on the callable type.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Callable</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">takeCallback</span><span class="p">(</span><span class="n">Callable</span> <span class="n">Callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Callback</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="the-function-ref-class-template">
<h4><a class="toc-backref" href="#id35">The <code class="docutils literal notranslate"><span class="pre">function_ref</span></code> class template</a><a class="headerlink" href="#the-function-ref-class-template" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">function_ref</span></code>
(<a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1function__ref_3_01Ret_07Params_8_8_8_08_4.html">doxygen</a>) class
template represents a reference to a callable object, templated over the type
of the callable. This is a good choice for passing a callback to a function,
if you don’t need to hold onto the callback after the function returns. In this
way, <code class="docutils literal notranslate"><span class="pre">function_ref</span></code> is to <code class="docutils literal notranslate"><span class="pre">std::function</span></code> as <code class="docutils literal notranslate"><span class="pre">StringRef</span></code> is to
<code class="docutils literal notranslate"><span class="pre">std::string</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">function_ref&lt;Ret(Param1,</span> <span class="pre">Param2,</span> <span class="pre">...)&gt;</span></code> can be implicitly constructed from
any callable object that can be called with arguments of type <code class="docutils literal notranslate"><span class="pre">Param1</span></code>,
<code class="docutils literal notranslate"><span class="pre">Param2</span></code>, …, and returns a value that can be converted to type <code class="docutils literal notranslate"><span class="pre">Ret</span></code>.
For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">visitBasicBlocks</span><span class="p">(</span><span class="n">Function</span> <span class="o">*</span><span class="n">F</span><span class="p">,</span> <span class="n">function_ref</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="p">(</span><span class="n">BasicBlock</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">Callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">BasicBlock</span> <span class="o">&amp;</span><span class="nl">BB</span> <span class="p">:</span> <span class="o">*</span><span class="n">F</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Callback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BB</span><span class="p">))</span>
      <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>can be called using:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">visitBasicBlocks</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">BasicBlock</span> <span class="o">*</span><span class="n">BB</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">process</span><span class="p">(</span><span class="n">BB</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">isEmpty</span><span class="p">(</span><span class="n">BB</span><span class="p">);</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Note that a <code class="docutils literal notranslate"><span class="pre">function_ref</span></code> object contains pointers to external memory, so it
is not generally safe to store an instance of the class (unless you know that
the external storage will not be freed). If you need this ability, consider
using <code class="docutils literal notranslate"><span class="pre">std::function</span></code>. <code class="docutils literal notranslate"><span class="pre">function_ref</span></code> is small enough that it should always
be passed by value.</p>
</div>
</div>
<div class="section" id="the-llvm-debug-macro-and-debug-option">
<span id="debug"></span><h3><a class="toc-backref" href="#id36">The <code class="docutils literal notranslate"><span class="pre">LLVM_DEBUG()</span></code> macro and <code class="docutils literal notranslate"><span class="pre">-debug</span></code> option</a><a class="headerlink" href="#the-llvm-debug-macro-and-debug-option" title="Permalink to this headline">¶</a></h3>
<p>Often when working on your pass you will put a bunch of debugging printouts and
other code into your pass.  After you get it working, you want to remove it, but
you may need it again in the future (to work out new bugs that you run across).</p>
<p>Naturally, because of this, you don’t want to delete the debug printouts, but
you don’t want them to always be noisy.  A standard compromise is to comment
them out, allowing you to enable them if you need them in the future.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">llvm/Support/Debug.h</span></code> (<a class="reference external" href="http://llvm.org/doxygen/Debug_8h_source.html">doxygen</a>) file provides a macro named
<code class="docutils literal notranslate"><span class="pre">LLVM_DEBUG()</span></code> that is a much nicer solution to this problem.  Basically, you can
put arbitrary code into the argument of the <code class="docutils literal notranslate"><span class="pre">LLVM_DEBUG</span></code> macro, and it is only
executed if ‘<code class="docutils literal notranslate"><span class="pre">opt</span></code>’ (or any other tool) is run with the ‘<code class="docutils literal notranslate"><span class="pre">-debug</span></code>’ command
line argument:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">dbgs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;I am here!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Then you can run your pass like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ opt &lt; a.bc &gt; /dev/null -mypass
&lt;no output&gt;
$ opt &lt; a.bc &gt; /dev/null -mypass -debug
I am here!
</pre></div>
</div>
<p>Using the <code class="docutils literal notranslate"><span class="pre">LLVM_DEBUG()</span></code> macro instead of a home-brewed solution allows you to not
have to create “yet another” command line option for the debug output for your
pass.  Note that <code class="docutils literal notranslate"><span class="pre">LLVM_DEBUG()</span></code> macros are disabled for non-asserts builds, so they
do not cause a performance impact at all (for the same reason, they should also
not contain side-effects!).</p>
<p>One additional nice thing about the <code class="docutils literal notranslate"><span class="pre">LLVM_DEBUG()</span></code> macro is that you can enable or
disable it directly in gdb.  Just use “<code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">DebugFlag=0</span></code>” or “<code class="docutils literal notranslate"><span class="pre">set</span>
<span class="pre">DebugFlag=1</span></code>” from the gdb if the program is running.  If the program hasn’t
been started yet, you can always just run it with <code class="docutils literal notranslate"><span class="pre">-debug</span></code>.</p>
<div class="section" id="fine-grained-debug-info-with-debug-type-and-the-debug-only-option">
<span id="debug-type"></span><h4><a class="toc-backref" href="#id37">Fine grained debug info with <code class="docutils literal notranslate"><span class="pre">DEBUG_TYPE</span></code> and the <code class="docutils literal notranslate"><span class="pre">-debug-only</span></code> option</a><a class="headerlink" href="#fine-grained-debug-info-with-debug-type-and-the-debug-only-option" title="Permalink to this headline">¶</a></h4>
<p>Sometimes you may find yourself in a situation where enabling <code class="docutils literal notranslate"><span class="pre">-debug</span></code> just
turns on <strong>too much</strong> information (such as when working on the code generator).
If you want to enable debug information with more fine-grained control, you
should define the <code class="docutils literal notranslate"><span class="pre">DEBUG_TYPE</span></code> macro and use the <code class="docutils literal notranslate"><span class="pre">-debug-only</span></code> option as
follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define DEBUG_TYPE &quot;foo&quot;</span>
<span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">dbgs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;foo&#39; debug type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#undef  DEBUG_TYPE</span>
<span class="cp">#define DEBUG_TYPE &quot;bar&quot;</span>
<span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">dbgs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;bar&#39; debug type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#undef  DEBUG_TYPE</span>
</pre></div>
</div>
<p>Then you can run your pass like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ opt &lt; a.bc &gt; /dev/null -mypass
&lt;no output&gt;
$ opt &lt; a.bc &gt; /dev/null -mypass -debug
&#39;foo&#39; debug type
&#39;bar&#39; debug type
$ opt &lt; a.bc &gt; /dev/null -mypass -debug-only=foo
&#39;foo&#39; debug type
$ opt &lt; a.bc &gt; /dev/null -mypass -debug-only=bar
&#39;bar&#39; debug type
$ opt &lt; a.bc &gt; /dev/null -mypass -debug-only=foo,bar
&#39;foo&#39; debug type
&#39;bar&#39; debug type
</pre></div>
</div>
<p>Of course, in practice, you should only set <code class="docutils literal notranslate"><span class="pre">DEBUG_TYPE</span></code> at the top of a file,
to specify the debug type for the entire module. Be careful that you only do
this after including Debug.h and not around any #include of headers. Also, you
should use names more meaningful than “foo” and “bar”, because there is no
system in place to ensure that names do not conflict. If two different modules
use the same string, they will all be turned on when the name is specified.
This allows, for example, all debug information for instruction scheduling to be
enabled with <code class="docutils literal notranslate"><span class="pre">-debug-only=InstrSched</span></code>, even if the source lives in multiple
files. The name must not include a comma (,) as that is used to separate the
arguments of the <code class="docutils literal notranslate"><span class="pre">-debug-only</span></code> option.</p>
<p>For performance reasons, -debug-only is not available in optimized build
(<code class="docutils literal notranslate"><span class="pre">--enable-optimized</span></code>) of LLVM.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DEBUG_WITH_TYPE</span></code> macro is also available for situations where you would
like to set <code class="docutils literal notranslate"><span class="pre">DEBUG_TYPE</span></code>, but only for one specific <code class="docutils literal notranslate"><span class="pre">DEBUG</span></code> statement.  It
takes an additional first parameter, which is the type to use.  For example, the
preceding example could be written as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">DEBUG_WITH_TYPE</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">dbgs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;foo&#39; debug type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">DEBUG_WITH_TYPE</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">,</span> <span class="n">dbgs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;bar&#39; debug type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="the-statistic-class-stats-option">
<span id="statistic"></span><h3><a class="toc-backref" href="#id38">The <code class="docutils literal notranslate"><span class="pre">Statistic</span></code> class &amp; <code class="docutils literal notranslate"><span class="pre">-stats</span></code> option</a><a class="headerlink" href="#the-statistic-class-stats-option" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">llvm/ADT/Statistic.h</span></code> (<a class="reference external" href="http://llvm.org/doxygen/Statistic_8h_source.html">doxygen</a>) file provides a class
named <code class="docutils literal notranslate"><span class="pre">Statistic</span></code> that is used as a unified way to keep track of what the LLVM
compiler is doing and how effective various optimizations are.  It is useful to
see what optimizations are contributing to making a particular program run
faster.</p>
<p>Often you may run your pass on some big program, and you’re interested to see
how many times it makes a certain transformation.  Although you can do this with
hand inspection, or some ad-hoc method, this is a real pain and not very useful
for big programs.  Using the <code class="docutils literal notranslate"><span class="pre">Statistic</span></code> class makes it very easy to keep
track of this information, and the calculated information is presented in a
uniform manner with the rest of the passes being executed.</p>
<p>There are many examples of <code class="docutils literal notranslate"><span class="pre">Statistic</span></code> uses, but the basics of using it are as
follows:</p>
<p>Define your statistic like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define DEBUG_TYPE &quot;mypassname&quot;   </span><span class="c1">// This goes before any #includes.</span>
<span class="n">STATISTIC</span><span class="p">(</span><span class="n">NumXForms</span><span class="p">,</span> <span class="s">&quot;The # of times I did stuff&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">STATISTIC</span></code> macro defines a static variable, whose name is specified by
the first argument.  The pass name is taken from the <code class="docutils literal notranslate"><span class="pre">DEBUG_TYPE</span></code> macro, and
the description is taken from the second argument.  The variable defined
(“NumXForms” in this case) acts like an unsigned integer.</p>
<p>Whenever you make a transformation, bump the counter:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="o">++</span><span class="n">NumXForms</span><span class="p">;</span>   <span class="c1">// I did stuff!</span>
</pre></div>
</div>
<p>That’s all you have to do.  To get ‘<code class="docutils literal notranslate"><span class="pre">opt</span></code>’ to print out the statistics
gathered, use the ‘<code class="docutils literal notranslate"><span class="pre">-stats</span></code>’ option:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ opt -stats -mypassname &lt; program.bc &gt; /dev/null
... statistics output ...
</pre></div>
</div>
<p>Note that in order to use the ‘<code class="docutils literal notranslate"><span class="pre">-stats</span></code>’ option, LLVM must be
compiled with assertions enabled.</p>
<p>When running <code class="docutils literal notranslate"><span class="pre">opt</span></code> on a C file from the SPEC benchmark suite, it gives a
report that looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  7646 bitcodewriter   - Number of normal instructions
   725 bitcodewriter   - Number of oversized instructions
129996 bitcodewriter   - Number of bitcode bytes written
  2817 raise           - Number of insts DCEd or constprop&#39;d
  3213 raise           - Number of cast-of-self removed
  5046 raise           - Number of expression trees converted
    75 raise           - Number of other getelementptr&#39;s formed
   138 raise           - Number of load/store peepholes
    42 deadtypeelim    - Number of unused typenames removed from symtab
   392 funcresolve     - Number of varargs functions resolved
    27 globaldce       - Number of global variables removed
     2 adce            - Number of basic blocks removed
   134 cee             - Number of branches revectored
    49 cee             - Number of setcc instruction eliminated
   532 gcse            - Number of loads removed
  2919 gcse            - Number of instructions removed
    86 indvars         - Number of canonical indvars added
    87 indvars         - Number of aux indvars removed
    25 instcombine     - Number of dead inst eliminate
   434 instcombine     - Number of insts combined
   248 licm            - Number of load insts hoisted
  1298 licm            - Number of insts hoisted to a loop pre-header
     3 licm            - Number of insts hoisted to multiple loop preds (bad, no loop pre-header)
    75 mem2reg         - Number of alloca&#39;s promoted
  1444 cfgsimplify     - Number of blocks simplified
</pre></div>
</div>
<p>Obviously, with so many optimizations, having a unified framework for this stuff
is very nice.  Making your pass fit well into the framework makes it more
maintainable and useful.</p>
</div>
<div class="section" id="adding-debug-counters-to-aid-in-debugging-your-code">
<span id="debugcounters"></span><h3><a class="toc-backref" href="#id39">Adding debug counters to aid in debugging your code</a><a class="headerlink" href="#adding-debug-counters-to-aid-in-debugging-your-code" title="Permalink to this headline">¶</a></h3>
<p>Sometimes, when writing new passes, or trying to track down bugs, it
is useful to be able to control whether certain things in your pass
happen or not.  For example, there are times the minimization tooling
can only easily give you large testcases.  You would like to narrow
your bug down to a specific transformation happening or not happening,
automatically, using bisection.  This is where debug counters help.
They provide a framework for making parts of your code only execute a
certain number of times.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">llvm/Support/DebugCounter.h</span></code> (<a class="reference external" href="http://llvm.org/doxygen/DebugCounter_8h_source.html">doxygen</a>) file
provides a class named <code class="docutils literal notranslate"><span class="pre">DebugCounter</span></code> that can be used to create
command line counter options that control execution of parts of your code.</p>
<p>Define your DebugCounter like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">DEBUG_COUNTER</span><span class="p">(</span><span class="n">DeleteAnInstruction</span><span class="p">,</span> <span class="s">&quot;passname-delete-instruction&quot;</span><span class="p">,</span>
              <span class="s">&quot;Controls which instructions get delete&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">DEBUG_COUNTER</span></code> macro defines a static variable, whose name
is specified by the first argument.  The name of the counter
(which is used on the command line) is specified by the second
argument, and the description used in the help is specified by the
third argument.</p>
<p>Whatever code you want that control, use <code class="docutils literal notranslate"><span class="pre">DebugCounter::shouldExecute</span></code> to control it.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">DebugCounter</span><span class="o">::</span><span class="n">shouldExecute</span><span class="p">(</span><span class="n">DeleteAnInstruction</span><span class="p">))</span>
  <span class="n">I</span><span class="o">-&gt;</span><span class="n">eraseFromParent</span><span class="p">();</span>
</pre></div>
</div>
<p>That’s all you have to do.  Now, using opt, you can control when this code triggers using
the ‘<code class="docutils literal notranslate"><span class="pre">--debug-counter</span></code>’ option.  There are two counters provided, <code class="docutils literal notranslate"><span class="pre">skip</span></code> and <code class="docutils literal notranslate"><span class="pre">count</span></code>.
<code class="docutils literal notranslate"><span class="pre">skip</span></code> is the number of times to skip execution of the codepath.  <code class="docutils literal notranslate"><span class="pre">count</span></code> is the number
of times, once we are done skipping, to execute the codepath.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ opt --debug-counter=passname-delete-instruction-skip=1,passname-delete-instruction-count=2 -passname
</pre></div>
</div>
<p>This will skip the above code the first time we hit it, then execute it twice, then skip the rest of the executions.</p>
<p>So if executed on the following code:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">%1</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="nv">%a</span><span class="p">,</span> <span class="nv">%b</span>
<span class="nv nv-Anonymous">%2</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="nv">%a</span><span class="p">,</span> <span class="nv">%b</span>
<span class="nv nv-Anonymous">%3</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="nv">%a</span><span class="p">,</span> <span class="nv">%b</span>
<span class="nv nv-Anonymous">%4</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="nv">%a</span><span class="p">,</span> <span class="nv">%b</span>
</pre></div>
</div>
<p>It would delete number <code class="docutils literal notranslate"><span class="pre">%2</span></code> and <code class="docutils literal notranslate"><span class="pre">%3</span></code>.</p>
<p>A utility is provided in <cite>utils/bisect-skip-count</cite> to binary search
skip and count arguments. It can be used to automatically minimize the
skip and count for a debug-counter variable.</p>
</div>
<div class="section" id="viewing-graphs-while-debugging-code">
<span id="viewgraph"></span><h3><a class="toc-backref" href="#id40">Viewing graphs while debugging code</a><a class="headerlink" href="#viewing-graphs-while-debugging-code" title="Permalink to this headline">¶</a></h3>
<p>Several of the important data structures in LLVM are graphs: for example CFGs
made out of LLVM <a class="reference internal" href="#basicblock"><span class="std std-ref">BasicBlocks</span></a>, CFGs made out of LLVM
<a class="reference internal" href="CodeGenerator.html#machinebasicblock"><span class="std std-ref">MachineBasicBlocks</span></a>, and <a class="reference internal" href="CodeGenerator.html#selectiondag"><span class="std std-ref">Instruction Selection
DAGs</span></a>.  In many cases, while debugging various parts of the
compiler, it is nice to instantly visualize these graphs.</p>
<p>LLVM provides several callbacks that are available in a debug build to do
exactly that.  If you call the <code class="docutils literal notranslate"><span class="pre">Function::viewCFG()</span></code> method, for example, the
current LLVM tool will pop up a window containing the CFG for the function where
each basic block is a node in the graph, and each node contains the instructions
in the block.  Similarly, there also exists <code class="docutils literal notranslate"><span class="pre">Function::viewCFGOnly()</span></code> (does
not include the instructions), the <code class="docutils literal notranslate"><span class="pre">MachineFunction::viewCFG()</span></code> and
<code class="docutils literal notranslate"><span class="pre">MachineFunction::viewCFGOnly()</span></code>, and the <code class="docutils literal notranslate"><span class="pre">SelectionDAG::viewGraph()</span></code>
methods.  Within GDB, for example, you can usually use something like <code class="docutils literal notranslate"><span class="pre">call</span>
<span class="pre">DAG.viewGraph()</span></code> to pop up a window.  Alternatively, you can sprinkle calls to
these functions in your code in places you want to debug.</p>
<p>Getting this to work requires a small amount of setup.  On Unix systems
with X11, install the <a class="reference external" href="http://www.graphviz.org">graphviz</a> toolkit, and make
sure ‘dot’ and ‘gv’ are in your path.  If you are running on macOS, download
and install the macOS <a class="reference external" href="http://www.pixelglow.com/graphviz/">Graphviz program</a> and add
<code class="docutils literal notranslate"><span class="pre">/Applications/Graphviz.app/Contents/MacOS/</span></code> (or wherever you install it) to
your path. The programs need not be present when configuring, building or
running LLVM and can simply be installed when needed during an active debug
session.</p>
<p><code class="docutils literal notranslate"><span class="pre">SelectionDAG</span></code> has been extended to make it easier to locate <em>interesting</em>
nodes in large complex graphs.  From gdb, if you <code class="docutils literal notranslate"><span class="pre">call</span> <span class="pre">DAG.setGraphColor(node,</span>
<span class="pre">&quot;color&quot;)</span></code>, then the next <code class="docutils literal notranslate"><span class="pre">call</span> <span class="pre">DAG.viewGraph()</span></code> would highlight the node in
the specified color (choices of colors can be found at <a class="reference external" href="http://www.graphviz.org/doc/info/colors.html">colors</a>.) More complex node attributes
can be provided with <code class="docutils literal notranslate"><span class="pre">call</span> <span class="pre">DAG.setGraphAttrs(node,</span> <span class="pre">&quot;attributes&quot;)</span></code> (choices can
be found at <a class="reference external" href="http://www.graphviz.org/doc/info/attrs.html">Graph attributes</a>.)
If you want to restart and clear all the current graph attributes, then you can
<code class="docutils literal notranslate"><span class="pre">call</span> <span class="pre">DAG.clearGraphAttrs()</span></code>.</p>
<p>Note that graph visualization features are compiled out of Release builds to
reduce file size.  This means that you need a Debug+Asserts or Release+Asserts
build to use these features.</p>
</div>
</div>
<div class="section" id="picking-the-right-data-structure-for-a-task">
<span id="datastructure"></span><h2><a class="toc-backref" href="#id41">Picking the Right Data Structure for a Task</a><a class="headerlink" href="#picking-the-right-data-structure-for-a-task" title="Permalink to this headline">¶</a></h2>
<p>LLVM has a plethora of data structures in the <code class="docutils literal notranslate"><span class="pre">llvm/ADT/</span></code> directory, and we
commonly use STL data structures.  This section describes the trade-offs you
should consider when you pick one.</p>
<p>The first step is a choose your own adventure: do you want a sequential
container, a set-like container, or a map-like container?  The most important
thing when choosing a container is the algorithmic properties of how you plan to
access the container.  Based on that, you should use:</p>
<ul class="simple">
<li><p>a <a class="reference internal" href="#ds-map"><span class="std std-ref">map-like</span></a> container if you need efficient look-up of a
value based on another value.  Map-like containers also support efficient
queries for containment (whether a key is in the map).  Map-like containers
generally do not support efficient reverse mapping (values to keys).  If you
need that, use two maps.  Some map-like containers also support efficient
iteration through the keys in sorted order.  Map-like containers are the most
expensive sort, only use them if you need one of these capabilities.</p></li>
<li><p>a <a class="reference internal" href="#ds-set"><span class="std std-ref">set-like</span></a> container if you need to put a bunch of stuff into
a container that automatically eliminates duplicates.  Some set-like
containers support efficient iteration through the elements in sorted order.
Set-like containers are more expensive than sequential containers.</p></li>
<li><p>a <a class="reference internal" href="#ds-sequential"><span class="std std-ref">sequential</span></a> container provides the most efficient way
to add elements and keeps track of the order they are added to the collection.
They permit duplicates and support efficient iteration, but do not support
efficient look-up based on a key.</p></li>
<li><p>a <a class="reference internal" href="#ds-string"><span class="std std-ref">string</span></a> container is a specialized sequential container or
reference structure that is used for character or byte arrays.</p></li>
<li><p>a <a class="reference internal" href="#ds-bit"><span class="std std-ref">bit</span></a> container provides an efficient way to store and
perform set operations on sets of numeric id’s, while automatically
eliminating duplicates.  Bit containers require a maximum of 1 bit for each
identifier you want to store.</p></li>
</ul>
<p>Once the proper category of container is determined, you can fine tune the
memory use, constant factors, and cache behaviors of access by intelligently
picking a member of the category.  Note that constant factors and cache behavior
can be a big deal.  If you have a vector that usually only contains a few
elements (but could contain many), for example, it’s much better to use
<a class="reference internal" href="#dss-smallvector"><span class="std std-ref">SmallVector</span></a> than <a class="reference internal" href="#dss-vector"><span class="std std-ref">vector</span></a>.  Doing so
avoids (relatively) expensive malloc/free calls, which dwarf the cost of adding
the elements to the container.</p>
<div class="section" id="sequential-containers-std-vector-std-list-etc">
<span id="ds-sequential"></span><h3><a class="toc-backref" href="#id42">Sequential Containers (std::vector, std::list, etc)</a><a class="headerlink" href="#sequential-containers-std-vector-std-list-etc" title="Permalink to this headline">¶</a></h3>
<p>There are a variety of sequential containers available for you, based on your
needs.  Pick the first in this section that will do what you want.</p>
<div class="section" id="llvm-adt-arrayref-h">
<span id="dss-arrayref"></span><h4><a class="toc-backref" href="#id43">llvm/ADT/ArrayRef.h</a><a class="headerlink" href="#llvm-adt-arrayref-h" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">llvm::ArrayRef</span></code> class is the preferred class to use in an interface that
accepts a sequential list of elements in memory and just reads from them.  By
taking an <code class="docutils literal notranslate"><span class="pre">ArrayRef</span></code>, the API can be passed a fixed size array, an
<code class="docutils literal notranslate"><span class="pre">std::vector</span></code>, an <code class="docutils literal notranslate"><span class="pre">llvm::SmallVector</span></code> and anything else that is contiguous
in memory.</p>
</div>
<div class="section" id="fixed-size-arrays">
<span id="dss-fixedarrays"></span><h4><a class="toc-backref" href="#id44">Fixed Size Arrays</a><a class="headerlink" href="#fixed-size-arrays" title="Permalink to this headline">¶</a></h4>
<p>Fixed size arrays are very simple and very fast.  They are good if you know
exactly how many elements you have, or you have a (low) upper bound on how many
you have.</p>
</div>
<div class="section" id="heap-allocated-arrays">
<span id="dss-heaparrays"></span><h4><a class="toc-backref" href="#id45">Heap Allocated Arrays</a><a class="headerlink" href="#heap-allocated-arrays" title="Permalink to this headline">¶</a></h4>
<p>Heap allocated arrays (<code class="docutils literal notranslate"><span class="pre">new[]</span></code> + <code class="docutils literal notranslate"><span class="pre">delete[]</span></code>) are also simple.  They are good
if the number of elements is variable, if you know how many elements you will
need before the array is allocated, and if the array is usually large (if not,
consider a <a class="reference internal" href="#dss-smallvector"><span class="std std-ref">SmallVector</span></a>).  The cost of a heap allocated
array is the cost of the new/delete (aka malloc/free).  Also note that if you
are allocating an array of a type with a constructor, the constructor and
destructors will be run for every element in the array (re-sizable vectors only
construct those elements actually used).</p>
</div>
<div class="section" id="llvm-adt-tinyptrvector-h">
<span id="dss-tinyptrvector"></span><h4><a class="toc-backref" href="#id46">llvm/ADT/TinyPtrVector.h</a><a class="headerlink" href="#llvm-adt-tinyptrvector-h" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">TinyPtrVector&lt;Type&gt;</span></code> is a highly specialized collection class that is
optimized to avoid allocation in the case when a vector has zero or one
elements.  It has two major restrictions: 1) it can only hold values of pointer
type, and 2) it cannot hold a null pointer.</p>
<p>Since this container is highly specialized, it is rarely used.</p>
</div>
<div class="section" id="llvm-adt-smallvector-h">
<span id="dss-smallvector"></span><h4><a class="toc-backref" href="#id47">llvm/ADT/SmallVector.h</a><a class="headerlink" href="#llvm-adt-smallvector-h" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">SmallVector&lt;Type,</span> <span class="pre">N&gt;</span></code> is a simple class that looks and smells just like
<code class="docutils literal notranslate"><span class="pre">vector&lt;Type&gt;</span></code>: it supports efficient iteration, lays out elements in memory
order (so you can do pointer arithmetic between elements), supports efficient
push_back/pop_back operations, supports efficient random access to its elements,
etc.</p>
<p>The main advantage of SmallVector is that it allocates space for some number of
elements (N) <strong>in the object itself</strong>.  Because of this, if the SmallVector is
dynamically smaller than N, no malloc is performed.  This can be a big win in
cases where the malloc/free call is far more expensive than the code that
fiddles around with the elements.</p>
<p>This is good for vectors that are “usually small” (e.g. the number of
predecessors/successors of a block is usually less than 8).  On the other hand,
this makes the size of the SmallVector itself large, so you don’t want to
allocate lots of them (doing so will waste a lot of space).  As such,
SmallVectors are most useful when on the stack.</p>
<p>SmallVector also provides a nice portable and efficient replacement for
<code class="docutils literal notranslate"><span class="pre">alloca</span></code>.</p>
<p>SmallVector has grown a few other minor advantages over std::vector, causing
<code class="docutils literal notranslate"><span class="pre">SmallVector&lt;Type,</span> <span class="pre">0&gt;</span></code> to be preferred over <code class="docutils literal notranslate"><span class="pre">std::vector&lt;Type&gt;</span></code>.</p>
<ol class="arabic simple">
<li><p>std::vector is exception-safe, and some implementations have pessimizations
that copy elements when SmallVector would move them.</p></li>
<li><p>SmallVector understands <code class="docutils literal notranslate"><span class="pre">llvm::is_trivially_copyable&lt;Type&gt;</span></code> and uses realloc aggressively.</p></li>
<li><p>Many LLVM APIs take a SmallVectorImpl as an out parameter (see the note
below).</p></li>
<li><p>SmallVector with N equal to 0 is smaller than std::vector on 64-bit
platforms, since it uses <code class="docutils literal notranslate"><span class="pre">unsigned</span></code> (instead of <code class="docutils literal notranslate"><span class="pre">void*</span></code>) for its size
and capacity.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Prefer to use <code class="docutils literal notranslate"><span class="pre">SmallVectorImpl&lt;T&gt;</span></code> as a parameter type.</p>
<p>In APIs that don’t care about the “small size” (most?), prefer to use
the <code class="docutils literal notranslate"><span class="pre">SmallVectorImpl&lt;T&gt;</span></code> class, which is basically just the “vector
header” (and methods) without the elements allocated after it. Note that
<code class="docutils literal notranslate"><span class="pre">SmallVector&lt;T,</span> <span class="pre">N&gt;</span></code> inherits from <code class="docutils literal notranslate"><span class="pre">SmallVectorImpl&lt;T&gt;</span></code> so the
conversion is implicit and costs nothing. E.g.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// BAD: Clients cannot pass e.g. SmallVector&lt;Foo, 4&gt;.</span>
<span class="n">hardcodedSmallSize</span><span class="p">(</span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Out</span><span class="p">);</span>
<span class="c1">// GOOD: Clients can pass any SmallVector&lt;Foo, N&gt;.</span>
<span class="n">allowsAnySmallSize</span><span class="p">(</span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Out</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">someFunc</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">Vec</span><span class="p">;</span>
  <span class="n">hardcodedSmallSize</span><span class="p">(</span><span class="n">Vec</span><span class="p">);</span> <span class="c1">// Error.</span>
  <span class="n">allowsAnySmallSize</span><span class="p">(</span><span class="n">Vec</span><span class="p">);</span> <span class="c1">// Works.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Even though it has “<code class="docutils literal notranslate"><span class="pre">Impl</span></code>” in the name, this is so widely used that
it really isn’t “private to the implementation” anymore. A name like
<code class="docutils literal notranslate"><span class="pre">SmallVectorHeader</span></code> would be more appropriate.</p>
</div>
</div>
<div class="section" id="vector">
<span id="dss-vector"></span><h4><a class="toc-backref" href="#id48">&lt;vector&gt;</a><a class="headerlink" href="#vector" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">std::vector&lt;T&gt;</span></code> is well loved and respected.  However, <code class="docutils literal notranslate"><span class="pre">SmallVector&lt;T,</span> <span class="pre">0&gt;</span></code>
is often a better option due to the advantages listed above.  std::vector is
still useful when you need to store more than <code class="docutils literal notranslate"><span class="pre">UINT32_MAX</span></code> elements or when
interfacing with code that expects vectors :).</p>
<p>One worthwhile note about std::vector: avoid code like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span> <span class="p">...</span> <span class="p">)</span> <span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span> <span class="n">V</span><span class="p">;</span>
   <span class="c1">// make use of V.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Instead, write this as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span> <span class="n">V</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span> <span class="p">...</span> <span class="p">)</span> <span class="p">{</span>
   <span class="c1">// make use of V.</span>
   <span class="n">V</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Doing so will save (at least) one heap allocation and free per iteration of the
loop.</p>
</div>
<div class="section" id="deque">
<span id="dss-deque"></span><h4><a class="toc-backref" href="#id49">&lt;deque&gt;</a><a class="headerlink" href="#deque" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">std::deque</span></code> is, in some senses, a generalized version of <code class="docutils literal notranslate"><span class="pre">std::vector</span></code>.
Like <code class="docutils literal notranslate"><span class="pre">std::vector</span></code>, it provides constant time random access and other similar
properties, but it also provides efficient access to the front of the list.  It
does not guarantee continuity of elements within memory.</p>
<p>In exchange for this extra flexibility, <code class="docutils literal notranslate"><span class="pre">std::deque</span></code> has significantly higher
constant factor costs than <code class="docutils literal notranslate"><span class="pre">std::vector</span></code>.  If possible, use <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> or
something cheaper.</p>
</div>
<div class="section" id="list">
<span id="dss-list"></span><h4><a class="toc-backref" href="#id50">&lt;list&gt;</a><a class="headerlink" href="#list" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">std::list</span></code> is an extremely inefficient class that is rarely useful.  It
performs a heap allocation for every element inserted into it, thus having an
extremely high constant factor, particularly for small data types.
<code class="docutils literal notranslate"><span class="pre">std::list</span></code> also only supports bidirectional iteration, not random access
iteration.</p>
<p>In exchange for this high cost, std::list supports efficient access to both ends
of the list (like <code class="docutils literal notranslate"><span class="pre">std::deque</span></code>, but unlike <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> or
<code class="docutils literal notranslate"><span class="pre">SmallVector</span></code>).  In addition, the iterator invalidation characteristics of
std::list are stronger than that of a vector class: inserting or removing an
element into the list does not invalidate iterator or pointers to other elements
in the list.</p>
</div>
<div class="section" id="llvm-adt-ilist-h">
<span id="dss-ilist"></span><h4><a class="toc-backref" href="#id51">llvm/ADT/ilist.h</a><a class="headerlink" href="#llvm-adt-ilist-h" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">ilist&lt;T&gt;</span></code> implements an ‘intrusive’ doubly-linked list.  It is intrusive,
because it requires the element to store and provide access to the prev/next
pointers for the list.</p>
<p><code class="docutils literal notranslate"><span class="pre">ilist</span></code> has the same drawbacks as <code class="docutils literal notranslate"><span class="pre">std::list</span></code>, and additionally requires an
<code class="docutils literal notranslate"><span class="pre">ilist_traits</span></code> implementation for the element type, but it provides some novel
characteristics.  In particular, it can efficiently store polymorphic objects,
the traits class is informed when an element is inserted or removed from the
list, and <code class="docutils literal notranslate"><span class="pre">ilist</span></code>s are guaranteed to support a constant-time splice
operation.</p>
<p>These properties are exactly what we want for things like <code class="docutils literal notranslate"><span class="pre">Instruction</span></code>s and
basic blocks, which is why these are implemented with <code class="docutils literal notranslate"><span class="pre">ilist</span></code>s.</p>
<p>Related classes of interest are explained in the following subsections:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#dss-ilist-traits"><span class="std std-ref">ilist_traits</span></a></p></li>
<li><p><a class="reference internal" href="#dss-iplist"><span class="std std-ref">iplist</span></a></p></li>
<li><p><a class="reference internal" href="#dss-ilist-node"><span class="std std-ref">llvm/ADT/ilist_node.h</span></a></p></li>
<li><p><a class="reference internal" href="#dss-ilist-sentinel"><span class="std std-ref">Sentinels</span></a></p></li>
</ul>
</div>
<div class="section" id="llvm-adt-packedvector-h">
<span id="dss-packedvector"></span><h4><a class="toc-backref" href="#id52">llvm/ADT/PackedVector.h</a><a class="headerlink" href="#llvm-adt-packedvector-h" title="Permalink to this headline">¶</a></h4>
<p>Useful for storing a vector of values using only a few number of bits for each
value.  Apart from the standard operations of a vector-like container, it can
also perform an ‘or’ set operation.</p>
<p>For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">State</span> <span class="p">{</span>
    <span class="n">None</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
    <span class="n">FirstCondition</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
    <span class="n">SecondCondition</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
    <span class="n">Both</span> <span class="o">=</span> <span class="mh">0x3</span>
<span class="p">};</span>

<span class="n">State</span> <span class="nf">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">PackedVector</span><span class="o">&lt;</span><span class="n">State</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Vec1</span><span class="p">;</span>
    <span class="n">Vec1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">FirstCondition</span><span class="p">);</span>

    <span class="n">PackedVector</span><span class="o">&lt;</span><span class="n">State</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Vec2</span><span class="p">;</span>
    <span class="n">Vec2</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">SecondCondition</span><span class="p">);</span>

    <span class="n">Vec1</span> <span class="o">|=</span> <span class="n">Vec2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Vec1</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// returns &#39;Both&#39;.</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="ilist-traits">
<span id="dss-ilist-traits"></span><h4><a class="toc-backref" href="#id53">ilist_traits</a><a class="headerlink" href="#ilist-traits" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">ilist_traits&lt;T&gt;</span></code> is <code class="docutils literal notranslate"><span class="pre">ilist&lt;T&gt;</span></code>’s customization mechanism. <code class="docutils literal notranslate"><span class="pre">iplist&lt;T&gt;</span></code>
(and consequently <code class="docutils literal notranslate"><span class="pre">ilist&lt;T&gt;</span></code>) publicly derive from this traits class.</p>
</div>
<div class="section" id="iplist">
<span id="dss-iplist"></span><h4><a class="toc-backref" href="#id54">iplist</a><a class="headerlink" href="#iplist" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">iplist&lt;T&gt;</span></code> is <code class="docutils literal notranslate"><span class="pre">ilist&lt;T&gt;</span></code>’s base and as such supports a slightly narrower
interface.  Notably, inserters from <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> are absent.</p>
<p><code class="docutils literal notranslate"><span class="pre">ilist_traits&lt;T&gt;</span></code> is a public base of this class and can be used for a wide
variety of customizations.</p>
</div>
<div class="section" id="llvm-adt-ilist-node-h">
<span id="dss-ilist-node"></span><h4><a class="toc-backref" href="#id55">llvm/ADT/ilist_node.h</a><a class="headerlink" href="#llvm-adt-ilist-node-h" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">ilist_node&lt;T&gt;</span></code> implements the forward and backward links that are expected
by the <code class="docutils literal notranslate"><span class="pre">ilist&lt;T&gt;</span></code> (and analogous containers) in the default manner.</p>
<p><code class="docutils literal notranslate"><span class="pre">ilist_node&lt;T&gt;</span></code>s are meant to be embedded in the node type <code class="docutils literal notranslate"><span class="pre">T</span></code>, usually
<code class="docutils literal notranslate"><span class="pre">T</span></code> publicly derives from <code class="docutils literal notranslate"><span class="pre">ilist_node&lt;T&gt;</span></code>.</p>
</div>
<div class="section" id="sentinels">
<span id="dss-ilist-sentinel"></span><h4><a class="toc-backref" href="#id56">Sentinels</a><a class="headerlink" href="#sentinels" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">ilist</span></code>s have another specialty that must be considered.  To be a good
citizen in the C++ ecosystem, it needs to support the standard container
operations, such as <code class="docutils literal notranslate"><span class="pre">begin</span></code> and <code class="docutils literal notranslate"><span class="pre">end</span></code> iterators, etc.  Also, the
<code class="docutils literal notranslate"><span class="pre">operator--</span></code> must work correctly on the <code class="docutils literal notranslate"><span class="pre">end</span></code> iterator in the case of
non-empty <code class="docutils literal notranslate"><span class="pre">ilist</span></code>s.</p>
<p>The only sensible solution to this problem is to allocate a so-called <em>sentinel</em>
along with the intrusive list, which serves as the <code class="docutils literal notranslate"><span class="pre">end</span></code> iterator, providing
the back-link to the last element.  However conforming to the C++ convention it
is illegal to <code class="docutils literal notranslate"><span class="pre">operator++</span></code> beyond the sentinel and it also must not be
dereferenced.</p>
<p>These constraints allow for some implementation freedom to the <code class="docutils literal notranslate"><span class="pre">ilist</span></code> how to
allocate and store the sentinel.  The corresponding policy is dictated by
<code class="docutils literal notranslate"><span class="pre">ilist_traits&lt;T&gt;</span></code>.  By default a <code class="docutils literal notranslate"><span class="pre">T</span></code> gets heap-allocated whenever the need
for a sentinel arises.</p>
<p>While the default policy is sufficient in most cases, it may break down when
<code class="docutils literal notranslate"><span class="pre">T</span></code> does not provide a default constructor.  Also, in the case of many
instances of <code class="docutils literal notranslate"><span class="pre">ilist</span></code>s, the memory overhead of the associated sentinels is
wasted.  To alleviate the situation with numerous and voluminous
<code class="docutils literal notranslate"><span class="pre">T</span></code>-sentinels, sometimes a trick is employed, leading to <em>ghostly sentinels</em>.</p>
<p>Ghostly sentinels are obtained by specially-crafted <code class="docutils literal notranslate"><span class="pre">ilist_traits&lt;T&gt;</span></code> which
superpose the sentinel with the <code class="docutils literal notranslate"><span class="pre">ilist</span></code> instance in memory.  Pointer
arithmetic is used to obtain the sentinel, which is relative to the <code class="docutils literal notranslate"><span class="pre">ilist</span></code>’s
<code class="docutils literal notranslate"><span class="pre">this</span></code> pointer.  The <code class="docutils literal notranslate"><span class="pre">ilist</span></code> is augmented by an extra pointer, which serves
as the back-link of the sentinel.  This is the only field in the ghostly
sentinel which can be legally accessed.</p>
</div>
<div class="section" id="other-sequential-container-options">
<span id="dss-other"></span><h4><a class="toc-backref" href="#id57">Other Sequential Container options</a><a class="headerlink" href="#other-sequential-container-options" title="Permalink to this headline">¶</a></h4>
<p>Other STL containers are available, such as <code class="docutils literal notranslate"><span class="pre">std::string</span></code>.</p>
<p>There are also various STL adapter classes such as <code class="docutils literal notranslate"><span class="pre">std::queue</span></code>,
<code class="docutils literal notranslate"><span class="pre">std::priority_queue</span></code>, <code class="docutils literal notranslate"><span class="pre">std::stack</span></code>, etc.  These provide simplified access
to an underlying container but don’t affect the cost of the container itself.</p>
</div>
</div>
<div class="section" id="string-like-containers">
<span id="ds-string"></span><h3><a class="toc-backref" href="#id58">String-like containers</a><a class="headerlink" href="#string-like-containers" title="Permalink to this headline">¶</a></h3>
<p>There are a variety of ways to pass around and use strings in C and C++, and
LLVM adds a few new options to choose from.  Pick the first option on this list
that will do what you need, they are ordered according to their relative cost.</p>
<p>Note that it is generally preferred to <em>not</em> pass strings around as <code class="docutils literal notranslate"><span class="pre">const</span>
<span class="pre">char*</span></code>’s.  These have a number of problems, including the fact that they
cannot represent embedded nul (“0”) characters, and do not have a length
available efficiently.  The general replacement for ‘<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char*</span></code>’ is
StringRef.</p>
<p>For more information on choosing string containers for APIs, please see
<a class="reference internal" href="#string-apis"><span class="std std-ref">Passing Strings</span></a>.</p>
<div class="section" id="llvm-adt-stringref-h">
<span id="dss-stringref"></span><h4><a class="toc-backref" href="#id59">llvm/ADT/StringRef.h</a><a class="headerlink" href="#llvm-adt-stringref-h" title="Permalink to this headline">¶</a></h4>
<p>The StringRef class is a simple value class that contains a pointer to a
character and a length, and is quite related to the <a class="reference internal" href="#dss-arrayref"><span class="std std-ref">ArrayRef</span></a> class (but specialized for arrays of characters).  Because
StringRef carries a length with it, it safely handles strings with embedded nul
characters in it, getting the length does not require a strlen call, and it even
has very convenient APIs for slicing and dicing the character range that it
represents.</p>
<p>StringRef is ideal for passing simple strings around that are known to be live,
either because they are C string literals, std::string, a C array, or a
SmallVector.  Each of these cases has an efficient implicit conversion to
StringRef, which doesn’t result in a dynamic strlen being executed.</p>
<p>StringRef has a few major limitations which make more powerful string containers
useful:</p>
<ol class="arabic simple">
<li><p>You cannot directly convert a StringRef to a ‘const char*’ because there is
no way to add a trailing nul (unlike the .c_str() method on various stronger
classes).</p></li>
<li><p>StringRef doesn’t own or keep alive the underlying string bytes.
As such it can easily lead to dangling pointers, and is not suitable for
embedding in datastructures in most cases (instead, use an std::string or
something like that).</p></li>
<li><p>For the same reason, StringRef cannot be used as the return value of a
method if the method “computes” the result string.  Instead, use std::string.</p></li>
<li><p>StringRef’s do not allow you to mutate the pointed-to string bytes and it
doesn’t allow you to insert or remove bytes from the range.  For editing
operations like this, it interoperates with the <a class="reference internal" href="#dss-twine"><span class="std std-ref">Twine</span></a>
class.</p></li>
</ol>
<p>Because of its strengths and limitations, it is very common for a function to
take a StringRef and for a method on an object to return a StringRef that points
into some string that it owns.</p>
</div>
<div class="section" id="llvm-adt-twine-h">
<span id="dss-twine"></span><h4><a class="toc-backref" href="#id60">llvm/ADT/Twine.h</a><a class="headerlink" href="#llvm-adt-twine-h" title="Permalink to this headline">¶</a></h4>
<p>The Twine class is used as an intermediary datatype for APIs that want to take a
string that can be constructed inline with a series of concatenations.  Twine
works by forming recursive instances of the Twine datatype (a simple value
object) on the stack as temporary objects, linking them together into a tree
which is then linearized when the Twine is consumed.  Twine is only safe to use
as the argument to a function, and should always be a const reference, e.g.:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">Twine</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">StringRef</span> <span class="n">X</span> <span class="o">=</span> <span class="p">...</span>
<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">foo</span><span class="p">(</span><span class="n">X</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span> <span class="o">+</span> <span class="n">Twine</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</pre></div>
</div>
<p>This example forms a string like “blarg.42” by concatenating the values
together, and does not form intermediate strings containing “blarg” or “blarg.”.</p>
<p>Because Twine is constructed with temporary objects on the stack, and because
these instances are destroyed at the end of the current statement, it is an
inherently dangerous API.  For example, this simple variant contains undefined
behavior and will probably crash:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">Twine</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">StringRef</span> <span class="n">X</span> <span class="o">=</span> <span class="p">...</span>
<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="p">...</span>
<span class="k">const</span> <span class="n">Twine</span> <span class="o">&amp;</span><span class="n">Tmp</span> <span class="o">=</span> <span class="n">X</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span> <span class="o">+</span> <span class="n">Twine</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="n">foo</span><span class="p">(</span><span class="n">Tmp</span><span class="p">);</span>
</pre></div>
</div>
<p>… because the temporaries are destroyed before the call.  That said, Twine’s
are much more efficient than intermediate std::string temporaries, and they work
really well with StringRef.  Just be aware of their limitations.</p>
</div>
<div class="section" id="llvm-adt-smallstring-h">
<span id="dss-smallstring"></span><h4><a class="toc-backref" href="#id61">llvm/ADT/SmallString.h</a><a class="headerlink" href="#llvm-adt-smallstring-h" title="Permalink to this headline">¶</a></h4>
<p>SmallString is a subclass of <a class="reference internal" href="#dss-smallvector"><span class="std std-ref">SmallVector</span></a> that adds some
convenience APIs like += that takes StringRef’s.  SmallString avoids allocating
memory in the case when the preallocated space is enough to hold its data, and
it calls back to general heap allocation when required.  Since it owns its data,
it is very safe to use and supports full mutation of the string.</p>
<p>Like SmallVector’s, the big downside to SmallString is their sizeof.  While they
are optimized for small strings, they themselves are not particularly small.
This means that they work great for temporary scratch buffers on the stack, but
should not generally be put into the heap: it is very rare to see a SmallString
as the member of a frequently-allocated heap data structure or returned
by-value.</p>
</div>
<div class="section" id="std-string">
<span id="dss-stdstring"></span><h4><a class="toc-backref" href="#id62">std::string</a><a class="headerlink" href="#std-string" title="Permalink to this headline">¶</a></h4>
<p>The standard C++ std::string class is a very general class that (like
SmallString) owns its underlying data.  sizeof(std::string) is very reasonable
so it can be embedded into heap data structures and returned by-value.  On the
other hand, std::string is highly inefficient for inline editing (e.g.
concatenating a bunch of stuff together) and because it is provided by the
standard library, its performance characteristics depend a lot of the host
standard library (e.g. libc++ and MSVC provide a highly optimized string class,
GCC contains a really slow implementation).</p>
<p>The major disadvantage of std::string is that almost every operation that makes
them larger can allocate memory, which is slow.  As such, it is better to use
SmallVector or Twine as a scratch buffer, but then use std::string to persist
the result.</p>
</div>
</div>
<div class="section" id="set-like-containers-std-set-smallset-setvector-etc">
<span id="ds-set"></span><h3><a class="toc-backref" href="#id63">Set-Like Containers (std::set, SmallSet, SetVector, etc)</a><a class="headerlink" href="#set-like-containers-std-set-smallset-setvector-etc" title="Permalink to this headline">¶</a></h3>
<p>Set-like containers are useful when you need to canonicalize multiple values
into a single representation.  There are several different choices for how to do
this, providing various trade-offs.</p>
<div class="section" id="a-sorted-vector">
<span id="dss-sortedvectorset"></span><h4><a class="toc-backref" href="#id64">A sorted ‘vector’</a><a class="headerlink" href="#a-sorted-vector" title="Permalink to this headline">¶</a></h4>
<p>If you intend to insert a lot of elements, then do a lot of queries, a great
approach is to use an std::vector (or other sequential container) with
std::sort+std::unique to remove duplicates.  This approach works really well if
your usage pattern has these two distinct phases (insert then query), and can be
coupled with a good choice of <a class="reference internal" href="#ds-sequential"><span class="std std-ref">sequential container</span></a>.</p>
<p>This combination provides the several nice properties: the result data is
contiguous in memory (good for cache locality), has few allocations, is easy to
address (iterators in the final vector are just indices or pointers), and can be
efficiently queried with a standard binary search (e.g.
<code class="docutils literal notranslate"><span class="pre">std::lower_bound</span></code>; if you want the whole range of elements comparing
equal, use <code class="docutils literal notranslate"><span class="pre">std::equal_range</span></code>).</p>
</div>
<div class="section" id="llvm-adt-smallset-h">
<span id="dss-smallset"></span><h4><a class="toc-backref" href="#id65">llvm/ADT/SmallSet.h</a><a class="headerlink" href="#llvm-adt-smallset-h" title="Permalink to this headline">¶</a></h4>
<p>If you have a set-like data structure that is usually small and whose elements
are reasonably small, a <code class="docutils literal notranslate"><span class="pre">SmallSet&lt;Type,</span> <span class="pre">N&gt;</span></code> is a good choice.  This set has
space for N elements in place (thus, if the set is dynamically smaller than N,
no malloc traffic is required) and accesses them with a simple linear search.
When the set grows beyond N elements, it allocates a more expensive
representation that guarantees efficient access (for most types, it falls back
to <a class="reference internal" href="#dss-set"><span class="std std-ref">std::set</span></a>, but for pointers it uses something far better,
<a class="reference internal" href="#dss-smallptrset"><span class="std std-ref">SmallPtrSet</span></a>.</p>
<p>The magic of this class is that it handles small sets extremely efficiently, but
gracefully handles extremely large sets without loss of efficiency.</p>
</div>
<div class="section" id="llvm-adt-smallptrset-h">
<span id="dss-smallptrset"></span><h4><a class="toc-backref" href="#id66">llvm/ADT/SmallPtrSet.h</a><a class="headerlink" href="#llvm-adt-smallptrset-h" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">SmallPtrSet</span></code> has all the advantages of <code class="docutils literal notranslate"><span class="pre">SmallSet</span></code> (and a <code class="docutils literal notranslate"><span class="pre">SmallSet</span></code> of
pointers is transparently implemented with a <code class="docutils literal notranslate"><span class="pre">SmallPtrSet</span></code>). If more than N
insertions are performed, a single quadratically probed hash table is allocated
and grows as needed, providing extremely efficient access (constant time
insertion/deleting/queries with low constant factors) and is very stingy with
malloc traffic.</p>
<p>Note that, unlike <a class="reference internal" href="#dss-set"><span class="std std-ref">std::set</span></a>, the iterators of <code class="docutils literal notranslate"><span class="pre">SmallPtrSet</span></code>
are invalidated whenever an insertion occurs.  Also, the values visited by the
iterators are not visited in sorted order.</p>
</div>
<div class="section" id="llvm-adt-stringset-h">
<span id="dss-stringset"></span><h4><a class="toc-backref" href="#id67">llvm/ADT/StringSet.h</a><a class="headerlink" href="#llvm-adt-stringset-h" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">StringSet</span></code> is a thin wrapper around <a class="reference internal" href="#dss-stringmap"><span class="std std-ref">StringMap&lt;char&gt;</span></a>,
and it allows efficient storage and retrieval of unique strings.</p>
<p>Functionally analogous to <code class="docutils literal notranslate"><span class="pre">SmallSet&lt;StringRef&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">StringSet</span></code> also supports
iteration. (The iterator dereferences to a <code class="docutils literal notranslate"><span class="pre">StringMapEntry&lt;char&gt;</span></code>, so you
need to call <code class="docutils literal notranslate"><span class="pre">i-&gt;getKey()</span></code> to access the item of the StringSet.)  On the
other hand, <code class="docutils literal notranslate"><span class="pre">StringSet</span></code> doesn’t support range-insertion and
copy-construction, which <a class="reference internal" href="#dss-smallset"><span class="std std-ref">SmallSet</span></a> and <a class="reference internal" href="#dss-smallptrset"><span class="std std-ref">SmallPtrSet</span></a> do support.</p>
</div>
<div class="section" id="llvm-adt-denseset-h">
<span id="dss-denseset"></span><h4><a class="toc-backref" href="#id68">llvm/ADT/DenseSet.h</a><a class="headerlink" href="#llvm-adt-denseset-h" title="Permalink to this headline">¶</a></h4>
<p>DenseSet is a simple quadratically probed hash table.  It excels at supporting
small values: it uses a single allocation to hold all of the pairs that are
currently inserted in the set.  DenseSet is a great way to unique small values
that are not simple pointers (use <a class="reference internal" href="#dss-smallptrset"><span class="std std-ref">SmallPtrSet</span></a> for
pointers).  Note that DenseSet has the same requirements for the value type that
<a class="reference internal" href="#dss-densemap"><span class="std std-ref">DenseMap</span></a> has.</p>
</div>
<div class="section" id="llvm-adt-sparseset-h">
<span id="dss-sparseset"></span><h4><a class="toc-backref" href="#id69">llvm/ADT/SparseSet.h</a><a class="headerlink" href="#llvm-adt-sparseset-h" title="Permalink to this headline">¶</a></h4>
<p>SparseSet holds a small number of objects identified by unsigned keys of
moderate size.  It uses a lot of memory, but provides operations that are almost
as fast as a vector.  Typical keys are physical registers, virtual registers, or
numbered basic blocks.</p>
<p>SparseSet is useful for algorithms that need very fast clear/find/insert/erase
and fast iteration over small sets.  It is not intended for building composite
data structures.</p>
</div>
<div class="section" id="llvm-adt-sparsemultiset-h">
<span id="dss-sparsemultiset"></span><h4><a class="toc-backref" href="#id70">llvm/ADT/SparseMultiSet.h</a><a class="headerlink" href="#llvm-adt-sparsemultiset-h" title="Permalink to this headline">¶</a></h4>
<p>SparseMultiSet adds multiset behavior to SparseSet, while retaining SparseSet’s
desirable attributes. Like SparseSet, it typically uses a lot of memory, but
provides operations that are almost as fast as a vector.  Typical keys are
physical registers, virtual registers, or numbered basic blocks.</p>
<p>SparseMultiSet is useful for algorithms that need very fast
clear/find/insert/erase of the entire collection, and iteration over sets of
elements sharing a key. It is often a more efficient choice than using composite
data structures (e.g. vector-of-vectors, map-of-vectors). It is not intended for
building composite data structures.</p>
</div>
<div class="section" id="llvm-adt-foldingset-h">
<span id="dss-foldingset"></span><h4><a class="toc-backref" href="#id71">llvm/ADT/FoldingSet.h</a><a class="headerlink" href="#llvm-adt-foldingset-h" title="Permalink to this headline">¶</a></h4>
<p>FoldingSet is an aggregate class that is really good at uniquing
expensive-to-create or polymorphic objects.  It is a combination of a chained
hash table with intrusive links (uniqued objects are required to inherit from
FoldingSetNode) that uses <a class="reference internal" href="#dss-smallvector"><span class="std std-ref">SmallVector</span></a> as part of its ID
process.</p>
<p>Consider a case where you want to implement a “getOrCreateFoo” method for a
complex object (for example, a node in the code generator).  The client has a
description of <strong>what</strong> it wants to generate (it knows the opcode and all the
operands), but we don’t want to ‘new’ a node, then try inserting it into a set
only to find out it already exists, at which point we would have to delete it
and return the node that already exists.</p>
<p>To support this style of client, FoldingSet perform a query with a
FoldingSetNodeID (which wraps SmallVector) that can be used to describe the
element that we want to query for.  The query either returns the element
matching the ID or it returns an opaque ID that indicates where insertion should
take place.  Construction of the ID usually does not require heap traffic.</p>
<p>Because FoldingSet uses intrusive links, it can support polymorphic objects in
the set (for example, you can have SDNode instances mixed with LoadSDNodes).
Because the elements are individually allocated, pointers to the elements are
stable: inserting or removing elements does not invalidate any pointers to other
elements.</p>
</div>
<div class="section" id="set">
<span id="dss-set"></span><h4><a class="toc-backref" href="#id72">&lt;set&gt;</a><a class="headerlink" href="#set" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">std::set</span></code> is a reasonable all-around set class, which is decent at many
things but great at nothing.  std::set allocates memory for each element
inserted (thus it is very malloc intensive) and typically stores three pointers
per element in the set (thus adding a large amount of per-element space
overhead).  It offers guaranteed log(n) performance, which is not particularly
fast from a complexity standpoint (particularly if the elements of the set are
expensive to compare, like strings), and has extremely high constant factors for
lookup, insertion and removal.</p>
<p>The advantages of std::set are that its iterators are stable (deleting or
inserting an element from the set does not affect iterators or pointers to other
elements) and that iteration over the set is guaranteed to be in sorted order.
If the elements in the set are large, then the relative overhead of the pointers
and malloc traffic is not a big deal, but if the elements of the set are small,
std::set is almost never a good choice.</p>
</div>
<div class="section" id="llvm-adt-setvector-h">
<span id="dss-setvector"></span><h4><a class="toc-backref" href="#id73">llvm/ADT/SetVector.h</a><a class="headerlink" href="#llvm-adt-setvector-h" title="Permalink to this headline">¶</a></h4>
<p>LLVM’s <code class="docutils literal notranslate"><span class="pre">SetVector&lt;Type&gt;</span></code> is an adapter class that combines your choice of a
set-like container along with a <a class="reference internal" href="#ds-sequential"><span class="std std-ref">Sequential Container</span></a> The
important property that this provides is efficient insertion with uniquing
(duplicate elements are ignored) with iteration support.  It implements this by
inserting elements into both a set-like container and the sequential container,
using the set-like container for uniquing and the sequential container for
iteration.</p>
<p>The difference between SetVector and other sets is that the order of iteration
is guaranteed to match the order of insertion into the SetVector.  This property
is really important for things like sets of pointers.  Because pointer values
are non-deterministic (e.g. vary across runs of the program on different
machines), iterating over the pointers in the set will not be in a well-defined
order.</p>
<p>The drawback of SetVector is that it requires twice as much space as a normal
set and has the sum of constant factors from the set-like container and the
sequential container that it uses.  Use it <strong>only</strong> if you need to iterate over
the elements in a deterministic order.  SetVector is also expensive to delete
elements out of (linear time), unless you use its “pop_back” method, which is
faster.</p>
<p><code class="docutils literal notranslate"><span class="pre">SetVector</span></code> is an adapter class that defaults to using <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> and a
size 16 <code class="docutils literal notranslate"><span class="pre">SmallSet</span></code> for the underlying containers, so it is quite expensive.
However, <code class="docutils literal notranslate"><span class="pre">&quot;llvm/ADT/SetVector.h&quot;</span></code> also provides a <code class="docutils literal notranslate"><span class="pre">SmallSetVector</span></code> class,
which defaults to using a <code class="docutils literal notranslate"><span class="pre">SmallVector</span></code> and <code class="docutils literal notranslate"><span class="pre">SmallSet</span></code> of a specified size.
If you use this, and if your sets are dynamically smaller than <code class="docutils literal notranslate"><span class="pre">N</span></code>, you will
save a lot of heap traffic.</p>
</div>
<div class="section" id="llvm-adt-uniquevector-h">
<span id="dss-uniquevector"></span><h4><a class="toc-backref" href="#id74">llvm/ADT/UniqueVector.h</a><a class="headerlink" href="#llvm-adt-uniquevector-h" title="Permalink to this headline">¶</a></h4>
<p>UniqueVector is similar to <a class="reference internal" href="#dss-setvector"><span class="std std-ref">SetVector</span></a> but it retains a
unique ID for each element inserted into the set.  It internally contains a map
and a vector, and it assigns a unique ID for each value inserted into the set.</p>
<p>UniqueVector is very expensive: its cost is the sum of the cost of maintaining
both the map and vector, it has high complexity, high constant factors, and
produces a lot of malloc traffic.  It should be avoided.</p>
</div>
<div class="section" id="llvm-adt-immutableset-h">
<span id="dss-immutableset"></span><h4><a class="toc-backref" href="#id75">llvm/ADT/ImmutableSet.h</a><a class="headerlink" href="#llvm-adt-immutableset-h" title="Permalink to this headline">¶</a></h4>
<p>ImmutableSet is an immutable (functional) set implementation based on an AVL
tree.  Adding or removing elements is done through a Factory object and results
in the creation of a new ImmutableSet object.  If an ImmutableSet already exists
with the given contents, then the existing one is returned; equality is compared
with a FoldingSetNodeID.  The time and space complexity of add or remove
operations is logarithmic in the size of the original set.</p>
<p>There is no method for returning an element of the set, you can only check for
membership.</p>
</div>
<div class="section" id="other-set-like-container-options">
<span id="dss-otherset"></span><h4><a class="toc-backref" href="#id76">Other Set-Like Container Options</a><a class="headerlink" href="#other-set-like-container-options" title="Permalink to this headline">¶</a></h4>
<p>The STL provides several other options, such as std::multiset and the various
“hash_set” like containers (whether from C++ TR1 or from the SGI library).  We
never use hash_set and unordered_set because they are generally very expensive
(each insertion requires a malloc) and very non-portable.</p>
<p>std::multiset is useful if you’re not interested in elimination of duplicates,
but has all the drawbacks of <a class="reference internal" href="#dss-set"><span class="std std-ref">std::set</span></a>.  A sorted vector
(where you don’t delete duplicate entries) or some other approach is almost
always better.</p>
</div>
</div>
<div class="section" id="map-like-containers-std-map-densemap-etc">
<span id="ds-map"></span><h3><a class="toc-backref" href="#id77">Map-Like Containers (std::map, DenseMap, etc)</a><a class="headerlink" href="#map-like-containers-std-map-densemap-etc" title="Permalink to this headline">¶</a></h3>
<p>Map-like containers are useful when you want to associate data to a key.  As
usual, there are a lot of different ways to do this. :)</p>
<div class="section" id="dss-sortedvectormap">
<span id="id2"></span><h4><a class="toc-backref" href="#id78">A sorted ‘vector’</a><a class="headerlink" href="#dss-sortedvectormap" title="Permalink to this headline">¶</a></h4>
<p>If your usage pattern follows a strict insert-then-query approach, you can
trivially use the same approach as <a class="reference internal" href="#dss-sortedvectorset"><span class="std std-ref">sorted vectors for set-like containers</span></a>.  The only difference is that your query function (which
uses std::lower_bound to get efficient log(n) lookup) should only compare the
key, not both the key and value.  This yields the same advantages as sorted
vectors for sets.</p>
</div>
<div class="section" id="llvm-adt-stringmap-h">
<span id="dss-stringmap"></span><h4><a class="toc-backref" href="#id79">llvm/ADT/StringMap.h</a><a class="headerlink" href="#llvm-adt-stringmap-h" title="Permalink to this headline">¶</a></h4>
<p>Strings are commonly used as keys in maps, and they are difficult to support
efficiently: they are variable length, inefficient to hash and compare when
long, expensive to copy, etc.  StringMap is a specialized container designed to
cope with these issues.  It supports mapping an arbitrary range of bytes to an
arbitrary other object.</p>
<p>The StringMap implementation uses a quadratically-probed hash table, where the
buckets store a pointer to the heap allocated entries (and some other stuff).
The entries in the map must be heap allocated because the strings are variable
length.  The string data (key) and the element object (value) are stored in the
same allocation with the string data immediately after the element object.
This container guarantees the “<code class="docutils literal notranslate"><span class="pre">(char*)(&amp;Value+1)</span></code>” points to the key string
for a value.</p>
<p>The StringMap is very fast for several reasons: quadratic probing is very cache
efficient for lookups, the hash value of strings in buckets is not recomputed
when looking up an element, StringMap rarely has to touch the memory for
unrelated objects when looking up a value (even when hash collisions happen),
hash table growth does not recompute the hash values for strings already in the
table, and each pair in the map is store in a single allocation (the string data
is stored in the same allocation as the Value of a pair).</p>
<p>StringMap also provides query methods that take byte ranges, so it only ever
copies a string if a value is inserted into the table.</p>
<p>StringMap iteration order, however, is not guaranteed to be deterministic, so
any uses which require that should instead use a std::map.</p>
</div>
<div class="section" id="llvm-adt-indexedmap-h">
<span id="dss-indexmap"></span><h4><a class="toc-backref" href="#id80">llvm/ADT/IndexedMap.h</a><a class="headerlink" href="#llvm-adt-indexedmap-h" title="Permalink to this headline">¶</a></h4>
<p>IndexedMap is a specialized container for mapping small dense integers (or
values that can be mapped to small dense integers) to some other type.  It is
internally implemented as a vector with a mapping function that maps the keys
to the dense integer range.</p>
<p>This is useful for cases like virtual registers in the LLVM code generator: they
have a dense mapping that is offset by a compile-time constant (the first
virtual register ID).</p>
</div>
<div class="section" id="llvm-adt-densemap-h">
<span id="dss-densemap"></span><h4><a class="toc-backref" href="#id81">llvm/ADT/DenseMap.h</a><a class="headerlink" href="#llvm-adt-densemap-h" title="Permalink to this headline">¶</a></h4>
<p>DenseMap is a simple quadratically probed hash table.  It excels at supporting
small keys and values: it uses a single allocation to hold all of the pairs
that are currently inserted in the map.  DenseMap is a great way to map
pointers to pointers, or map other small types to each other.</p>
<p>There are several aspects of DenseMap that you should be aware of, however.
The iterators in a DenseMap are invalidated whenever an insertion occurs,
unlike map.  Also, because DenseMap allocates space for a large number of
key/value pairs (it starts with 64 by default), it will waste a lot of space if
your keys or values are large.  Finally, you must implement a partial
specialization of DenseMapInfo for the key that you want, if it isn’t already
supported.  This is required to tell DenseMap about two special marker values
(which can never be inserted into the map) that it needs internally.</p>
<p>DenseMap’s find_as() method supports lookup operations using an alternate key
type.  This is useful in cases where the normal key type is expensive to
construct, but cheap to compare against.  The DenseMapInfo is responsible for
defining the appropriate comparison and hashing methods for each alternate key
type used.</p>
</div>
<div class="section" id="llvm-ir-valuemap-h">
<span id="dss-valuemap"></span><h4><a class="toc-backref" href="#id82">llvm/IR/ValueMap.h</a><a class="headerlink" href="#llvm-ir-valuemap-h" title="Permalink to this headline">¶</a></h4>
<p>ValueMap is a wrapper around a <a class="reference internal" href="#dss-densemap"><span class="std std-ref">DenseMap</span></a> mapping
<code class="docutils literal notranslate"><span class="pre">Value*</span></code>s (or subclasses) to another type.  When a Value is deleted or
RAUW’ed, ValueMap will update itself so the new version of the key is mapped to
the same value, just as if the key were a WeakVH.  You can configure exactly how
this happens, and what else happens on these two events, by passing a <code class="docutils literal notranslate"><span class="pre">Config</span></code>
parameter to the ValueMap template.</p>
</div>
<div class="section" id="llvm-adt-intervalmap-h">
<span id="dss-intervalmap"></span><h4><a class="toc-backref" href="#id83">llvm/ADT/IntervalMap.h</a><a class="headerlink" href="#llvm-adt-intervalmap-h" title="Permalink to this headline">¶</a></h4>
<p>IntervalMap is a compact map for small keys and values.  It maps key intervals
instead of single keys, and it will automatically coalesce adjacent intervals.
When the map only contains a few intervals, they are stored in the map object
itself to avoid allocations.</p>
<p>The IntervalMap iterators are quite big, so they should not be passed around as
STL iterators.  The heavyweight iterators allow a smaller data structure.</p>
</div>
<div class="section" id="map">
<span id="dss-map"></span><h4><a class="toc-backref" href="#id84">&lt;map&gt;</a><a class="headerlink" href="#map" title="Permalink to this headline">¶</a></h4>
<p>std::map has similar characteristics to <a class="reference internal" href="#dss-set"><span class="std std-ref">std::set</span></a>: it uses a
single allocation per pair inserted into the map, it offers log(n) lookup with
an extremely large constant factor, imposes a space penalty of 3 pointers per
pair in the map, etc.</p>
<p>std::map is most useful when your keys or values are very large, if you need to
iterate over the collection in sorted order, or if you need stable iterators
into the map (i.e. they don’t get invalidated if an insertion or deletion of
another element takes place).</p>
</div>
<div class="section" id="llvm-adt-mapvector-h">
<span id="dss-mapvector"></span><h4><a class="toc-backref" href="#id85">llvm/ADT/MapVector.h</a><a class="headerlink" href="#llvm-adt-mapvector-h" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">MapVector&lt;KeyT,ValueT&gt;</span></code> provides a subset of the DenseMap interface.  The
main difference is that the iteration order is guaranteed to be the insertion
order, making it an easy (but somewhat expensive) solution for non-deterministic
iteration over maps of pointers.</p>
<p>It is implemented by mapping from key to an index in a vector of key,value
pairs.  This provides fast lookup and iteration, but has two main drawbacks:
the key is stored twice and removing elements takes linear time.  If it is
necessary to remove elements, it’s best to remove them in bulk using
<code class="docutils literal notranslate"><span class="pre">remove_if()</span></code>.</p>
</div>
<div class="section" id="llvm-adt-inteqclasses-h">
<span id="dss-inteqclasses"></span><h4><a class="toc-backref" href="#id86">llvm/ADT/IntEqClasses.h</a><a class="headerlink" href="#llvm-adt-inteqclasses-h" title="Permalink to this headline">¶</a></h4>
<p>IntEqClasses provides a compact representation of equivalence classes of small
integers.  Initially, each integer in the range 0..n-1 has its own equivalence
class.  Classes can be joined by passing two class representatives to the
join(a, b) method.  Two integers are in the same class when findLeader() returns
the same representative.</p>
<p>Once all equivalence classes are formed, the map can be compressed so each
integer 0..n-1 maps to an equivalence class number in the range 0..m-1, where m
is the total number of equivalence classes.  The map must be uncompressed before
it can be edited again.</p>
</div>
<div class="section" id="llvm-adt-immutablemap-h">
<span id="dss-immutablemap"></span><h4><a class="toc-backref" href="#id87">llvm/ADT/ImmutableMap.h</a><a class="headerlink" href="#llvm-adt-immutablemap-h" title="Permalink to this headline">¶</a></h4>
<p>ImmutableMap is an immutable (functional) map implementation based on an AVL
tree.  Adding or removing elements is done through a Factory object and results
in the creation of a new ImmutableMap object.  If an ImmutableMap already exists
with the given key set, then the existing one is returned; equality is compared
with a FoldingSetNodeID.  The time and space complexity of add or remove
operations is logarithmic in the size of the original map.</p>
</div>
<div class="section" id="other-map-like-container-options">
<span id="dss-othermap"></span><h4><a class="toc-backref" href="#id88">Other Map-Like Container Options</a><a class="headerlink" href="#other-map-like-container-options" title="Permalink to this headline">¶</a></h4>
<p>The STL provides several other options, such as std::multimap and the various
“hash_map” like containers (whether from C++ TR1 or from the SGI library).  We
never use hash_set and unordered_set because they are generally very expensive
(each insertion requires a malloc) and very non-portable.</p>
<p>std::multimap is useful if you want to map a key to multiple values, but has all
the drawbacks of std::map.  A sorted vector or some other approach is almost
always better.</p>
</div>
</div>
<div class="section" id="bit-storage-containers-bitvector-sparsebitvector">
<span id="ds-bit"></span><h3><a class="toc-backref" href="#id89">Bit storage containers (BitVector, SparseBitVector)</a><a class="headerlink" href="#bit-storage-containers-bitvector-sparsebitvector" title="Permalink to this headline">¶</a></h3>
<p>Unlike the other containers, there are only two bit storage containers, and
choosing when to use each is relatively straightforward.</p>
<p>One additional option is <code class="docutils literal notranslate"><span class="pre">std::vector&lt;bool&gt;</span></code>: we discourage its use for two
reasons 1) the implementation in many common compilers (e.g.  commonly
available versions of GCC) is extremely inefficient and 2) the C++ standards
committee is likely to deprecate this container and/or change it significantly
somehow.  In any case, please don’t use it.</p>
<div class="section" id="bitvector">
<span id="dss-bitvector"></span><h4><a class="toc-backref" href="#id90">BitVector</a><a class="headerlink" href="#bitvector" title="Permalink to this headline">¶</a></h4>
<p>The BitVector container provides a dynamic size set of bits for manipulation.
It supports individual bit setting/testing, as well as set operations.  The set
operations take time O(size of bitvector), but operations are performed one word
at a time, instead of one bit at a time.  This makes the BitVector very fast for
set operations compared to other containers.  Use the BitVector when you expect
the number of set bits to be high (i.e. a dense set).</p>
</div>
<div class="section" id="smallbitvector">
<span id="dss-smallbitvector"></span><h4><a class="toc-backref" href="#id91">SmallBitVector</a><a class="headerlink" href="#smallbitvector" title="Permalink to this headline">¶</a></h4>
<p>The SmallBitVector container provides the same interface as BitVector, but it is
optimized for the case where only a small number of bits, less than 25 or so,
are needed.  It also transparently supports larger bit counts, but slightly less
efficiently than a plain BitVector, so SmallBitVector should only be used when
larger counts are rare.</p>
<p>At this time, SmallBitVector does not support set operations (and, or, xor), and
its operator[] does not provide an assignable lvalue.</p>
</div>
<div class="section" id="sparsebitvector">
<span id="dss-sparsebitvector"></span><h4><a class="toc-backref" href="#id92">SparseBitVector</a><a class="headerlink" href="#sparsebitvector" title="Permalink to this headline">¶</a></h4>
<p>The SparseBitVector container is much like BitVector, with one major difference:
Only the bits that are set, are stored.  This makes the SparseBitVector much
more space efficient than BitVector when the set is sparse, as well as making
set operations O(number of set bits) instead of O(size of universe).  The
downside to the SparseBitVector is that setting and testing of random bits is
O(N), and on large SparseBitVectors, this can be slower than BitVector.  In our
implementation, setting or testing bits in sorted order (either forwards or
reverse) is O(1) worst case.  Testing and setting bits within 128 bits (depends
on size) of the current bit is also O(1).  As a general statement,
testing/setting bits in a SparseBitVector is O(distance away from last set bit).</p>
</div>
</div>
</div>
<div class="section" id="debugging">
<span id="id3"></span><h2><a class="toc-backref" href="#id93">Debugging</a><a class="headerlink" href="#debugging" title="Permalink to this headline">¶</a></h2>
<p>A handful of <a class="reference external" href="https://sourceware.org/gdb/onlinedocs/gdb/Pretty-Printing.html">GDB pretty printers</a> are
provided for some of the core LLVM libraries. To use them, execute the
following (or add it to your <code class="docutils literal notranslate"><span class="pre">~/.gdbinit</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">source</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">utils</span><span class="o">/</span><span class="n">gdb</span><span class="o">-</span><span class="n">scripts</span><span class="o">/</span><span class="n">prettyprinters</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>It also might be handy to enable the <a class="reference external" href="http://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_57.html">print pretty</a> option to
avoid data structures being printed as a big block of text.</p>
</div>
<div class="section" id="helpful-hints-for-common-operations">
<span id="common"></span><h2><a class="toc-backref" href="#id94">Helpful Hints for Common Operations</a><a class="headerlink" href="#helpful-hints-for-common-operations" title="Permalink to this headline">¶</a></h2>
<p>This section describes how to perform some very simple transformations of LLVM
code.  This is meant to give examples of common idioms used, showing the
practical side of LLVM transformations.</p>
<p>Because this is a “how-to” section, you should also read about the main classes
that you will be working with.  The <a class="reference internal" href="#coreclasses"><span class="std std-ref">Core LLVM Class Hierarchy Reference</span></a> contains details and descriptions of the main classes that you
should know about.</p>
<div class="section" id="basic-inspection-and-traversal-routines">
<span id="inspection"></span><h3><a class="toc-backref" href="#id95">Basic Inspection and Traversal Routines</a><a class="headerlink" href="#basic-inspection-and-traversal-routines" title="Permalink to this headline">¶</a></h3>
<p>The LLVM compiler infrastructure have many different data structures that may be
traversed.  Following the example of the C++ standard template library, the
techniques used to traverse these various data structures are all basically the
same.  For a enumerable sequence of values, the <code class="docutils literal notranslate"><span class="pre">XXXbegin()</span></code> function (or
method) returns an iterator to the start of the sequence, the <code class="docutils literal notranslate"><span class="pre">XXXend()</span></code>
function returns an iterator pointing to one past the last valid element of the
sequence, and there is some <code class="docutils literal notranslate"><span class="pre">XXXiterator</span></code> data type that is common between the
two operations.</p>
<p>Because the pattern for iteration is common across many different aspects of the
program representation, the standard template library algorithms may be used on
them, and it is easier to remember how to iterate.  First we show a few common
examples of the data structures that need to be traversed.  Other data
structures are traversed in very similar ways.</p>
<div class="section" id="iterating-over-the-basicblock-in-a-function">
<span id="iterate-function"></span><h4><a class="toc-backref" href="#id96">Iterating over the <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code> in a <code class="docutils literal notranslate"><span class="pre">Function</span></code></a><a class="headerlink" href="#iterating-over-the-basicblock-in-a-function" title="Permalink to this headline">¶</a></h4>
<p>It’s quite common to have a <code class="docutils literal notranslate"><span class="pre">Function</span></code> instance that you’d like to transform
in some way; in particular, you’d like to manipulate its <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code>s.  To
facilitate this, you’ll need to iterate over all of the <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code>s that
constitute the <code class="docutils literal notranslate"><span class="pre">Function</span></code>.  The following is an example that prints the name
of a <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code> and the number of <code class="docutils literal notranslate"><span class="pre">Instruction</span></code>s it contains:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Function</span> <span class="o">&amp;</span><span class="n">Func</span> <span class="o">=</span> <span class="p">...</span>
<span class="k">for</span> <span class="p">(</span><span class="n">BasicBlock</span> <span class="o">&amp;</span><span class="nl">BB</span> <span class="p">:</span> <span class="n">Func</span><span class="p">)</span>
  <span class="c1">// Print out the name of the basic block if it has one, and then the</span>
  <span class="c1">// number of instructions that it contains</span>
  <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Basic block (name=&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">BB</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;) has &quot;</span>
             <span class="o">&lt;&lt;</span> <span class="n">BB</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; instructions.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="iterating-over-the-instruction-in-a-basicblock">
<span id="iterate-basicblock"></span><h4><a class="toc-backref" href="#id97">Iterating over the <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> in a <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code></a><a class="headerlink" href="#iterating-over-the-instruction-in-a-basicblock" title="Permalink to this headline">¶</a></h4>
<p>Just like when dealing with <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code>s in <code class="docutils literal notranslate"><span class="pre">Function</span></code>s, it’s easy to
iterate over the individual instructions that make up <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code>s.  Here’s
a code snippet that prints out each instruction in a <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">BasicBlock</span><span class="o">&amp;</span> <span class="n">BB</span> <span class="o">=</span> <span class="p">...</span>
<span class="k">for</span> <span class="p">(</span><span class="n">Instruction</span> <span class="o">&amp;</span><span class="nl">I</span> <span class="p">:</span> <span class="n">BB</span><span class="p">)</span>
   <span class="c1">// The next statement works since operator&lt;&lt;(ostream&amp;,...)</span>
   <span class="c1">// is overloaded for Instruction&amp;</span>
   <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">I</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>However, this isn’t really the best way to print out the contents of a
<code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code>!  Since the ostream operators are overloaded for virtually
anything you’ll care about, you could have just invoked the print routine on the
basic block itself: <code class="docutils literal notranslate"><span class="pre">errs()</span> <span class="pre">&lt;&lt;</span> <span class="pre">BB</span> <span class="pre">&lt;&lt;</span> <span class="pre">&quot;\n&quot;;</span></code>.</p>
</div>
<div class="section" id="iterating-over-the-instruction-in-a-function">
<span id="iterate-insiter"></span><h4><a class="toc-backref" href="#id98">Iterating over the <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> in a <code class="docutils literal notranslate"><span class="pre">Function</span></code></a><a class="headerlink" href="#iterating-over-the-instruction-in-a-function" title="Permalink to this headline">¶</a></h4>
<p>If you’re finding that you commonly iterate over a <code class="docutils literal notranslate"><span class="pre">Function</span></code>’s
<code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code>s and then that <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code>’s <code class="docutils literal notranslate"><span class="pre">Instruction</span></code>s,
<code class="docutils literal notranslate"><span class="pre">InstIterator</span></code> should be used instead.  You’ll need to include
<code class="docutils literal notranslate"><span class="pre">llvm/IR/InstIterator.h</span></code> (<a class="reference external" href="http://llvm.org/doxygen/InstIterator_8h.html">doxygen</a>) and then instantiate
<code class="docutils literal notranslate"><span class="pre">InstIterator</span></code>s explicitly in your code.  Here’s a small example that shows
how to dump all instructions in a function to the standard error stream:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;llvm/IR/InstIterator.h&quot;</span><span class="cp"></span>

<span class="c1">// F is a pointer to a Function instance</span>
<span class="k">for</span> <span class="p">(</span><span class="n">inst_iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">inst_begin</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">E</span> <span class="o">=</span> <span class="n">inst_end</span><span class="p">(</span><span class="n">F</span><span class="p">);</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">E</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span>
  <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">I</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Easy, isn’t it?  You can also use <code class="docutils literal notranslate"><span class="pre">InstIterator</span></code>s to fill a work list with
its initial contents.  For example, if you wanted to initialize a work list to
contain all instructions in a <code class="docutils literal notranslate"><span class="pre">Function</span></code> F, all you would need to do is
something like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Instruction</span><span class="o">*&gt;</span> <span class="n">worklist</span><span class="p">;</span>
<span class="c1">// or better yet, SmallPtrSet&lt;Instruction*, 64&gt; worklist;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">inst_iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">inst_begin</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">E</span> <span class="o">=</span> <span class="n">inst_end</span><span class="p">(</span><span class="n">F</span><span class="p">);</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">E</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span>
  <span class="n">worklist</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">I</span><span class="p">);</span>
</pre></div>
</div>
<p>The STL set <code class="docutils literal notranslate"><span class="pre">worklist</span></code> would now contain all instructions in the <code class="docutils literal notranslate"><span class="pre">Function</span></code>
pointed to by F.</p>
</div>
<div class="section" id="turning-an-iterator-into-a-class-pointer-and-vice-versa">
<span id="iterate-convert"></span><h4><a class="toc-backref" href="#id99">Turning an iterator into a class pointer (and vice-versa)</a><a class="headerlink" href="#turning-an-iterator-into-a-class-pointer-and-vice-versa" title="Permalink to this headline">¶</a></h4>
<p>Sometimes, it’ll be useful to grab a reference (or pointer) to a class instance
when all you’ve got at hand is an iterator.  Well, extracting a reference or a
pointer from an iterator is very straight-forward.  Assuming that <code class="docutils literal notranslate"><span class="pre">i</span></code> is a
<code class="docutils literal notranslate"><span class="pre">BasicBlock::iterator</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> is a <code class="docutils literal notranslate"><span class="pre">BasicBlock::const_iterator</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Instruction</span><span class="o">&amp;</span> <span class="n">inst</span> <span class="o">=</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>   <span class="c1">// Grab reference to instruction reference</span>
<span class="n">Instruction</span><span class="o">*</span> <span class="n">pinst</span> <span class="o">=</span> <span class="o">&amp;*</span><span class="n">i</span><span class="p">;</span> <span class="c1">// Grab pointer to instruction reference</span>
<span class="k">const</span> <span class="n">Instruction</span><span class="o">&amp;</span> <span class="n">inst</span> <span class="o">=</span> <span class="o">*</span><span class="n">j</span><span class="p">;</span>
</pre></div>
</div>
<p>However, the iterators you’ll be working with in the LLVM framework are special:
they will automatically convert to a ptr-to-instance type whenever they need to.
Instead of dereferencing the iterator and then taking the address of the result,
you can simply assign the iterator to the proper pointer type and you get the
dereference and address-of operation as a result of the assignment (behind the
scenes, this is a result of overloading casting mechanisms).  Thus the second
line of the last example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Instruction</span> <span class="o">*</span><span class="n">pinst</span> <span class="o">=</span> <span class="o">&amp;*</span><span class="n">i</span><span class="p">;</span>
</pre></div>
</div>
<p>is semantically equivalent to</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Instruction</span> <span class="o">*</span><span class="n">pinst</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</pre></div>
</div>
<p>It’s also possible to turn a class pointer into the corresponding iterator, and
this is a constant time operation (very efficient).  The following code snippet
illustrates use of the conversion constructors provided by LLVM iterators.  By
using these, you can explicitly grab the iterator of something without actually
obtaining it via iteration over some structure:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">printNextInstruction</span><span class="p">(</span><span class="n">Instruction</span><span class="o">*</span> <span class="n">inst</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">BasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
  <span class="o">++</span><span class="n">it</span><span class="p">;</span> <span class="c1">// After this line, it refers to the instruction after *inst</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span> <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Unfortunately, these implicit conversions come at a cost; they prevent these
iterators from conforming to standard iterator conventions, and thus from being
usable with standard algorithms and containers.  For example, they prevent the
following code, where <code class="docutils literal notranslate"><span class="pre">B</span></code> is a <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code>, from compiling:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">llvm</span><span class="o">::</span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">Instruction</span> <span class="o">*</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">B</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">(),</span> <span class="n">B</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">());</span>
</pre></div>
</div>
<p>Because of this, these implicit conversions may be removed some day, and
<code class="docutils literal notranslate"><span class="pre">operator*</span></code> changed to return a pointer instead of a reference.</p>
</div>
<div class="section" id="finding-call-sites-a-slightly-more-complex-example">
<span id="iterate-complex"></span><h4><a class="toc-backref" href="#id100">Finding call sites: a slightly more complex example</a><a class="headerlink" href="#finding-call-sites-a-slightly-more-complex-example" title="Permalink to this headline">¶</a></h4>
<p>Say that you’re writing a FunctionPass and would like to count all the locations
in the entire module (that is, across every <code class="docutils literal notranslate"><span class="pre">Function</span></code>) where a certain
function (i.e., some <code class="docutils literal notranslate"><span class="pre">Function</span> <span class="pre">*</span></code>) is already in scope.  As you’ll learn
later, you may want to use an <code class="docutils literal notranslate"><span class="pre">InstVisitor</span></code> to accomplish this in a much more
straight-forward manner, but this example will allow us to explore how you’d do
it if you didn’t have <code class="docutils literal notranslate"><span class="pre">InstVisitor</span></code> around.  In pseudo-code, this is what we
want to do:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>initialize callCounter to zero
for each Function f in the Module
  for each BasicBlock b in f
    for each Instruction i in b
      if (i is a CallInst and calls the given function)
        increment callCounter
</pre></div>
</div>
<p>And the actual code is (remember, because we’re writing a <code class="docutils literal notranslate"><span class="pre">FunctionPass</span></code>, our
<code class="docutils literal notranslate"><span class="pre">FunctionPass</span></code>-derived class simply has to override the <code class="docutils literal notranslate"><span class="pre">runOnFunction</span></code>
method):</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Function</span><span class="o">*</span> <span class="n">targetFunc</span> <span class="o">=</span> <span class="p">...;</span>

<span class="k">class</span> <span class="nc">OurFunctionPass</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FunctionPass</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">OurFunctionPass</span><span class="p">()</span><span class="o">:</span> <span class="n">callCounter</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">virtual</span> <span class="n">runOnFunction</span><span class="p">(</span><span class="n">Function</span><span class="o">&amp;</span> <span class="n">F</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">BasicBlock</span> <span class="o">&amp;</span><span class="nl">B</span> <span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">Instruction</span> <span class="o">&amp;</span><span class="nl">I</span><span class="p">:</span> <span class="n">B</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="o">*</span><span class="n">CallInst</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">CallInst</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">I</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// We know we&#39;ve encountered a call instruction, so we</span>
            <span class="c1">// need to determine if it&#39;s a call to the</span>
            <span class="c1">// function pointed to by m_func or not.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">CallInst</span><span class="o">-&gt;</span><span class="n">getCalledFunction</span><span class="p">()</span> <span class="o">==</span> <span class="n">targetFunc</span><span class="p">)</span>
              <span class="o">++</span><span class="n">callCounter</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

  <span class="k">private</span><span class="o">:</span>
    <span class="kt">unsigned</span> <span class="n">callCounter</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="treating-calls-and-invokes-the-same-way">
<span id="calls-and-invokes"></span><h4><a class="toc-backref" href="#id101">Treating calls and invokes the same way</a><a class="headerlink" href="#treating-calls-and-invokes-the-same-way" title="Permalink to this headline">¶</a></h4>
<p>You may have noticed that the previous example was a bit oversimplified in that
it did not deal with call sites generated by ‘invoke’ instructions.  In this,
and in other situations, you may find that you want to treat <code class="docutils literal notranslate"><span class="pre">CallInst</span></code>s and
<code class="docutils literal notranslate"><span class="pre">InvokeInst</span></code>s the same way, even though their most-specific common base
class is <code class="docutils literal notranslate"><span class="pre">Instruction</span></code>, which includes lots of less closely-related things.
For these cases, LLVM provides a handy wrapper class called <code class="docutils literal notranslate"><span class="pre">CallSite</span></code>
(<a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1CallSite.html">doxygen</a>) It is
essentially a wrapper around an <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> pointer, with some methods that
provide functionality common to <code class="docutils literal notranslate"><span class="pre">CallInst</span></code>s and <code class="docutils literal notranslate"><span class="pre">InvokeInst</span></code>s.</p>
<p>This class has “value semantics”: it should be passed by value, not by reference
and it should not be dynamically allocated or deallocated using <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">new</span></code>
or <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">delete</span></code>.  It is efficiently copyable, assignable and
constructable, with costs equivalents to that of a bare pointer.  If you look at
its definition, it has only a single pointer member.</p>
</div>
<div class="section" id="iterating-over-def-use-use-def-chains">
<span id="iterate-chains"></span><h4><a class="toc-backref" href="#id102">Iterating over def-use &amp; use-def chains</a><a class="headerlink" href="#iterating-over-def-use-use-def-chains" title="Permalink to this headline">¶</a></h4>
<p>Frequently, we might have an instance of the <code class="docutils literal notranslate"><span class="pre">Value</span></code> class (<a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Value.html">doxygen</a>) and we want to determine
which <code class="docutils literal notranslate"><span class="pre">User</span></code>s use the <code class="docutils literal notranslate"><span class="pre">Value</span></code>.  The list of all <code class="docutils literal notranslate"><span class="pre">User</span></code>s of a particular
<code class="docutils literal notranslate"><span class="pre">Value</span></code> is called a <em>def-use</em> chain.  For example, let’s say we have a
<code class="docutils literal notranslate"><span class="pre">Function*</span></code> named <code class="docutils literal notranslate"><span class="pre">F</span></code> to a particular function <code class="docutils literal notranslate"><span class="pre">foo</span></code>.  Finding all of the
instructions that <em>use</em> <code class="docutils literal notranslate"><span class="pre">foo</span></code> is as simple as iterating over the <em>def-use</em>
chain of <code class="docutils literal notranslate"><span class="pre">F</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Function</span> <span class="o">*</span><span class="n">F</span> <span class="o">=</span> <span class="p">...;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">User</span> <span class="o">*</span><span class="nl">U</span> <span class="p">:</span> <span class="n">F</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Instruction</span> <span class="o">*</span><span class="n">Inst</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">Instruction</span><span class="o">&gt;</span><span class="p">(</span><span class="n">U</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;F is used in instruction:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">Inst</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>Alternatively, it’s common to have an instance of the <code class="docutils literal notranslate"><span class="pre">User</span></code> Class (<a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1User.html">doxygen</a>) and need to know what
<code class="docutils literal notranslate"><span class="pre">Value</span></code>s are used by it.  The list of all <code class="docutils literal notranslate"><span class="pre">Value</span></code>s used by a <code class="docutils literal notranslate"><span class="pre">User</span></code> is
known as a <em>use-def</em> chain.  Instances of class <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> are common
<code class="docutils literal notranslate"><span class="pre">User</span></code> s, so we might want to iterate over all of the values that a particular
instruction uses (that is, the operands of the particular <code class="docutils literal notranslate"><span class="pre">Instruction</span></code>):</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Instruction</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="p">...;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">Use</span> <span class="o">&amp;</span><span class="nl">U</span> <span class="p">:</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">operands</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">Value</span> <span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="n">U</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Declaring objects as <code class="docutils literal notranslate"><span class="pre">const</span></code> is an important tool of enforcing mutation free
algorithms (such as analyses, etc.).  For this purpose above iterators come in
constant flavors as <code class="docutils literal notranslate"><span class="pre">Value::const_use_iterator</span></code> and
<code class="docutils literal notranslate"><span class="pre">Value::const_op_iterator</span></code>.  They automatically arise when calling
<code class="docutils literal notranslate"><span class="pre">use/op_begin()</span></code> on <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">Value*</span></code>s or <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">User*</span></code>s respectively.
Upon dereferencing, they return <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">Use*</span></code>s.  Otherwise the above patterns
remain unchanged.</p>
</div>
<div class="section" id="iterating-over-predecessors-successors-of-blocks">
<span id="iterate-preds"></span><h4><a class="toc-backref" href="#id103">Iterating over predecessors &amp; successors of blocks</a><a class="headerlink" href="#iterating-over-predecessors-successors-of-blocks" title="Permalink to this headline">¶</a></h4>
<p>Iterating over the predecessors and successors of a block is quite easy with the
routines defined in <code class="docutils literal notranslate"><span class="pre">&quot;llvm/IR/CFG.h&quot;</span></code>.  Just use code like this to
iterate over all predecessors of BB:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;llvm/IR/CFG.h&quot;</span><span class="cp"></span>
<span class="n">BasicBlock</span> <span class="o">*</span><span class="n">BB</span> <span class="o">=</span> <span class="p">...;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">BasicBlock</span> <span class="o">*</span><span class="nl">Pred</span> <span class="p">:</span> <span class="n">predecessors</span><span class="p">(</span><span class="n">BB</span><span class="p">))</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Similarly, to iterate over successors use <code class="docutils literal notranslate"><span class="pre">successors</span></code>.</p>
</div>
</div>
<div class="section" id="making-simple-changes">
<span id="simplechanges"></span><h3><a class="toc-backref" href="#id104">Making simple changes</a><a class="headerlink" href="#making-simple-changes" title="Permalink to this headline">¶</a></h3>
<p>There are some primitive transformation operations present in the LLVM
infrastructure that are worth knowing about.  When performing transformations,
it’s fairly common to manipulate the contents of basic blocks.  This section
describes some of the common methods for doing so and gives example code.</p>
<div class="section" id="creating-and-inserting-new-instructions">
<span id="schanges-creating"></span><h4><a class="toc-backref" href="#id105">Creating and inserting new <code class="docutils literal notranslate"><span class="pre">Instruction</span></code>s</a><a class="headerlink" href="#creating-and-inserting-new-instructions" title="Permalink to this headline">¶</a></h4>
<p><em>Instantiating Instructions</em></p>
<p>Creation of <code class="docutils literal notranslate"><span class="pre">Instruction</span></code>s is straight-forward: simply call the constructor
for the kind of instruction to instantiate and provide the necessary parameters.
For example, an <code class="docutils literal notranslate"><span class="pre">AllocaInst</span></code> only <em>requires</em> a (const-ptr-to) <code class="docutils literal notranslate"><span class="pre">Type</span></code>.  Thus:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="o">*</span><span class="n">ai</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AllocaInst</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">Int32Ty</span><span class="p">);</span>
</pre></div>
</div>
<p>will create an <code class="docutils literal notranslate"><span class="pre">AllocaInst</span></code> instance that represents the allocation of one
integer in the current stack frame, at run time.  Each <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> subclass
is likely to have varying default parameters which change the semantics of the
instruction, so refer to the <a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Instruction.html">doxygen documentation for the subclass of
Instruction</a> that
you’re interested in instantiating.</p>
<p><em>Naming values</em></p>
<p>It is very useful to name the values of instructions when you’re able to, as
this facilitates the debugging of your transformations.  If you end up looking
at generated LLVM machine code, you definitely want to have logical names
associated with the results of instructions!  By supplying a value for the
<code class="docutils literal notranslate"><span class="pre">Name</span></code> (default) parameter of the <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> constructor, you associate a
logical name with the result of the instruction’s execution at run time.  For
example, say that I’m writing a transformation that dynamically allocates space
for an integer on the stack, and that integer is going to be used as some kind
of index by some other code.  To accomplish this, I place an <code class="docutils literal notranslate"><span class="pre">AllocaInst</span></code> at
the first point in the first <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code> of some <code class="docutils literal notranslate"><span class="pre">Function</span></code>, and I’m
intending to use it within the same <code class="docutils literal notranslate"><span class="pre">Function</span></code>.  I might do:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AllocaInst</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">Int32Ty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;indexLoc&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">indexLoc</span></code> is now the logical name of the instruction’s execution value,
which is a pointer to an integer on the run time stack.</p>
<p><em>Inserting instructions</em></p>
<p>There are essentially three ways to insert an <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> into an existing
sequence of instructions that form a <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code>:</p>
<ul>
<li><p>Insertion into an explicit instruction list</p>
<p>Given a <code class="docutils literal notranslate"><span class="pre">BasicBlock*</span> <span class="pre">pb</span></code>, an <code class="docutils literal notranslate"><span class="pre">Instruction*</span> <span class="pre">pi</span></code> within that <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code>,
and a newly-created instruction we wish to insert before <code class="docutils literal notranslate"><span class="pre">*pi</span></code>, we do the
following:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">BasicBlock</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">Instruction</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">auto</span> <span class="o">*</span><span class="n">newInst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Instruction</span><span class="p">(...);</span>

<span class="n">pb</span><span class="o">-&gt;</span><span class="n">getInstList</span><span class="p">().</span><span class="n">insert</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">newInst</span><span class="p">);</span> <span class="c1">// Inserts newInst before pi in pb</span>
</pre></div>
</div>
<p>Appending to the end of a <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code> is so common that the <code class="docutils literal notranslate"><span class="pre">Instruction</span></code>
class and <code class="docutils literal notranslate"><span class="pre">Instruction</span></code>-derived classes provide constructors which take a
pointer to a <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code> to be appended to.  For example code that looked
like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">BasicBlock</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">auto</span> <span class="o">*</span><span class="n">newInst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Instruction</span><span class="p">(...);</span>

<span class="n">pb</span><span class="o">-&gt;</span><span class="n">getInstList</span><span class="p">().</span><span class="n">push_back</span><span class="p">(</span><span class="n">newInst</span><span class="p">);</span> <span class="c1">// Appends newInst to pb</span>
</pre></div>
</div>
<p>becomes:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">BasicBlock</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">auto</span> <span class="o">*</span><span class="n">newInst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Instruction</span><span class="p">(...,</span> <span class="n">pb</span><span class="p">);</span>
</pre></div>
</div>
<p>which is much cleaner, especially if you are creating long instruction
streams.</p>
</li>
<li><p>Insertion into an implicit instruction list</p>
<p><code class="docutils literal notranslate"><span class="pre">Instruction</span></code> instances that are already in <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code>s are implicitly
associated with an existing instruction list: the instruction list of the
enclosing basic block.  Thus, we could have accomplished the same thing as the
above code without being given a <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code> by doing:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Instruction</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">auto</span> <span class="o">*</span><span class="n">newInst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Instruction</span><span class="p">(...);</span>

<span class="n">pi</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getInstList</span><span class="p">().</span><span class="n">insert</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">newInst</span><span class="p">);</span>
</pre></div>
</div>
<p>In fact, this sequence of steps occurs so frequently that the <code class="docutils literal notranslate"><span class="pre">Instruction</span></code>
class and <code class="docutils literal notranslate"><span class="pre">Instruction</span></code>-derived classes provide constructors which take (as
a default parameter) a pointer to an <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> which the newly-created
<code class="docutils literal notranslate"><span class="pre">Instruction</span></code> should precede.  That is, <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> constructors are
capable of inserting the newly-created instance into the <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code> of a
provided instruction, immediately before that instruction.  Using an
<code class="docutils literal notranslate"><span class="pre">Instruction</span></code> constructor with a <code class="docutils literal notranslate"><span class="pre">insertBefore</span></code> (default) parameter, the
above code becomes:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Instruction</span><span class="o">*</span> <span class="n">pi</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">auto</span> <span class="o">*</span><span class="n">newInst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Instruction</span><span class="p">(...,</span> <span class="n">pi</span><span class="p">);</span>
</pre></div>
</div>
<p>which is much cleaner, especially if you’re creating a lot of instructions and
adding them to <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code>s.</p>
</li>
<li><p>Insertion using an instance of <code class="docutils literal notranslate"><span class="pre">IRBuilder</span></code></p>
<p>Inserting several <code class="docutils literal notranslate"><span class="pre">Instruction</span></code>s can be quite laborious using the previous
methods. The <code class="docutils literal notranslate"><span class="pre">IRBuilder</span></code> is a convenience class that can be used to add
several instructions to the end of a <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code> or before a particular
<code class="docutils literal notranslate"><span class="pre">Instruction</span></code>. It also supports constant folding and renaming named
registers (see <code class="docutils literal notranslate"><span class="pre">IRBuilder</span></code>’s template arguments).</p>
<p>The example below demonstrates a very simple use of the <code class="docutils literal notranslate"><span class="pre">IRBuilder</span></code> where
three instructions are inserted before the instruction <code class="docutils literal notranslate"><span class="pre">pi</span></code>. The first two
instructions are Call instructions and third instruction multiplies the return
value of the two calls.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Instruction</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">IRBuilder</span><span class="o">&lt;&gt;</span> <span class="n">Builder</span><span class="p">(</span><span class="n">pi</span><span class="p">);</span>
<span class="n">CallInst</span><span class="o">*</span> <span class="n">callOne</span> <span class="o">=</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreateCall</span><span class="p">(...);</span>
<span class="n">CallInst</span><span class="o">*</span> <span class="n">callTwo</span> <span class="o">=</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreateCall</span><span class="p">(...);</span>
<span class="n">Value</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreateMul</span><span class="p">(</span><span class="n">callOne</span><span class="p">,</span> <span class="n">callTwo</span><span class="p">);</span>
</pre></div>
</div>
<p>The example below is similar to the above example except that the created
<code class="docutils literal notranslate"><span class="pre">IRBuilder</span></code> inserts instructions at the end of the <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code> <code class="docutils literal notranslate"><span class="pre">pb</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">BasicBlock</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">IRBuilder</span><span class="o">&lt;&gt;</span> <span class="n">Builder</span><span class="p">(</span><span class="n">pb</span><span class="p">);</span>
<span class="n">CallInst</span><span class="o">*</span> <span class="n">callOne</span> <span class="o">=</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreateCall</span><span class="p">(...);</span>
<span class="n">CallInst</span><span class="o">*</span> <span class="n">callTwo</span> <span class="o">=</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreateCall</span><span class="p">(...);</span>
<span class="n">Value</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Builder</span><span class="p">.</span><span class="n">CreateMul</span><span class="p">(</span><span class="n">callOne</span><span class="p">,</span> <span class="n">callTwo</span><span class="p">);</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="tutorial/LangImpl03.html"><span class="doc">Kaleidoscope: Code generation to LLVM IR</span></a> for a practical use of the <code class="docutils literal notranslate"><span class="pre">IRBuilder</span></code>.</p>
</li>
</ul>
</div>
<div class="section" id="deleting-instructions">
<span id="schanges-deleting"></span><h4><a class="toc-backref" href="#id106">Deleting Instructions</a><a class="headerlink" href="#deleting-instructions" title="Permalink to this headline">¶</a></h4>
<p>Deleting an instruction from an existing sequence of instructions that form a
<a class="reference internal" href="#basicblock">BasicBlock</a> is very straight-forward: just call the instruction’s
<code class="docutils literal notranslate"><span class="pre">eraseFromParent()</span></code> method.  For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Instruction</span> <span class="o">*</span><span class="n">I</span> <span class="o">=</span> <span class="p">..</span> <span class="p">;</span>
<span class="n">I</span><span class="o">-&gt;</span><span class="n">eraseFromParent</span><span class="p">();</span>
</pre></div>
</div>
<p>This unlinks the instruction from its containing basic block and deletes it.  If
you’d just like to unlink the instruction from its containing basic block but
not delete it, you can use the <code class="docutils literal notranslate"><span class="pre">removeFromParent()</span></code> method.</p>
</div>
<div class="section" id="replacing-an-instruction-with-another-value">
<span id="schanges-replacing"></span><h4><a class="toc-backref" href="#id107">Replacing an Instruction with another Value</a><a class="headerlink" href="#replacing-an-instruction-with-another-value" title="Permalink to this headline">¶</a></h4>
<div class="section" id="replacing-individual-instructions">
<h5><a class="toc-backref" href="#id108">Replacing individual instructions</a><a class="headerlink" href="#replacing-individual-instructions" title="Permalink to this headline">¶</a></h5>
<p>Including “<a class="reference external" href="http://llvm.org/doxygen/BasicBlockUtils_8h_source.html">llvm/Transforms/Utils/BasicBlockUtils.h</a>” permits use of two
very useful replace functions: <code class="docutils literal notranslate"><span class="pre">ReplaceInstWithValue</span></code> and
<code class="docutils literal notranslate"><span class="pre">ReplaceInstWithInst</span></code>.</p>
</div>
<div class="section" id="schanges-deleting-sub">
<span id="id4"></span><h5><a class="toc-backref" href="#id109">Deleting Instructions</a><a class="headerlink" href="#schanges-deleting-sub" title="Permalink to this headline">¶</a></h5>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">ReplaceInstWithValue</span></code></p>
<p>This function replaces all uses of a given instruction with a value, and then
removes the original instruction.  The following example illustrates the
replacement of the result of a particular <code class="docutils literal notranslate"><span class="pre">AllocaInst</span></code> that allocates memory
for a single integer with a null pointer to an integer.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">AllocaInst</span><span class="o">*</span> <span class="n">instToReplace</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">BasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">ii</span><span class="p">(</span><span class="n">instToReplace</span><span class="p">);</span>

<span class="n">ReplaceInstWithValue</span><span class="p">(</span><span class="n">instToReplace</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getInstList</span><span class="p">(),</span> <span class="n">ii</span><span class="p">,</span>
                     <span class="n">Constant</span><span class="o">::</span><span class="n">getNullValue</span><span class="p">(</span><span class="n">PointerType</span><span class="o">::</span><span class="n">getUnqual</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">Int32Ty</span><span class="p">)));</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">ReplaceInstWithInst</span></code></p>
<p>This function replaces a particular instruction with another instruction,
inserting the new instruction into the basic block at the location where the
old instruction was, and replacing any uses of the old instruction with the
new instruction.  The following example illustrates the replacement of one
<code class="docutils literal notranslate"><span class="pre">AllocaInst</span></code> with another.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">AllocaInst</span><span class="o">*</span> <span class="n">instToReplace</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">BasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">ii</span><span class="p">(</span><span class="n">instToReplace</span><span class="p">);</span>

<span class="n">ReplaceInstWithInst</span><span class="p">(</span><span class="n">instToReplace</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getInstList</span><span class="p">(),</span> <span class="n">ii</span><span class="p">,</span>
                    <span class="k">new</span> <span class="n">AllocaInst</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">Int32Ty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;ptrToReplacedInt&quot;</span><span class="p">));</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="replacing-multiple-uses-of-users-and-values">
<h5><a class="toc-backref" href="#id110">Replacing multiple uses of Users and Values</a><a class="headerlink" href="#replacing-multiple-uses-of-users-and-values" title="Permalink to this headline">¶</a></h5>
<p>You can use <code class="docutils literal notranslate"><span class="pre">Value::replaceAllUsesWith</span></code> and <code class="docutils literal notranslate"><span class="pre">User::replaceUsesOfWith</span></code> to
change more than one use at a time.  See the doxygen documentation for the
<a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Value.html">Value Class</a> and <a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1User.html">User Class</a>, respectively, for more
information.</p>
</div>
</div>
<div class="section" id="deleting-globalvariables">
<span id="schanges-deletinggv"></span><h4><a class="toc-backref" href="#id111">Deleting GlobalVariables</a><a class="headerlink" href="#deleting-globalvariables" title="Permalink to this headline">¶</a></h4>
<p>Deleting a global variable from a module is just as easy as deleting an
Instruction.  First, you must have a pointer to the global variable that you
wish to delete.  You use this pointer to erase it from its parent, the module.
For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">GlobalVariable</span> <span class="o">*</span><span class="n">GV</span> <span class="o">=</span> <span class="p">..</span> <span class="p">;</span>

<span class="n">GV</span><span class="o">-&gt;</span><span class="n">eraseFromParent</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="threads-and-llvm">
<span id="threading"></span><h2><a class="toc-backref" href="#id112">Threads and LLVM</a><a class="headerlink" href="#threads-and-llvm" title="Permalink to this headline">¶</a></h2>
<p>This section describes the interaction of the LLVM APIs with multithreading,
both on the part of client applications, and in the JIT, in the hosted
application.</p>
<p>Note that LLVM’s support for multithreading is still relatively young.  Up
through version 2.5, the execution of threaded hosted applications was
supported, but not threaded client access to the APIs.  While this use case is
now supported, clients <em>must</em> adhere to the guidelines specified below to ensure
proper operation in multithreaded mode.</p>
<p>Note that, on Unix-like platforms, LLVM requires the presence of GCC’s atomic
intrinsics in order to support threaded operation.  If you need a
multhreading-capable LLVM on a platform without a suitably modern system
compiler, consider compiling LLVM and LLVM-GCC in single-threaded mode, and
using the resultant compiler to build a copy of LLVM with multithreading
support.</p>
<div class="section" id="ending-execution-with-llvm-shutdown">
<span id="shutdown"></span><h3><a class="toc-backref" href="#id113">Ending Execution with <code class="docutils literal notranslate"><span class="pre">llvm_shutdown()</span></code></a><a class="headerlink" href="#ending-execution-with-llvm-shutdown" title="Permalink to this headline">¶</a></h3>
<p>When you are done using the LLVM APIs, you should call <code class="docutils literal notranslate"><span class="pre">llvm_shutdown()</span></code> to
deallocate memory used for internal structures.</p>
</div>
<div class="section" id="lazy-initialization-with-managedstatic">
<span id="managedstatic"></span><h3><a class="toc-backref" href="#id114">Lazy Initialization with <code class="docutils literal notranslate"><span class="pre">ManagedStatic</span></code></a><a class="headerlink" href="#lazy-initialization-with-managedstatic" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">ManagedStatic</span></code> is a utility class in LLVM used to implement static
initialization of static resources, such as the global type tables.  In a
single-threaded environment, it implements a simple lazy initialization scheme.
When LLVM is compiled with support for multi-threading, however, it uses
double-checked locking to implement thread-safe lazy initialization.</p>
</div>
<div class="section" id="achieving-isolation-with-llvmcontext">
<span id="llvmcontext"></span><h3><a class="toc-backref" href="#id115">Achieving Isolation with <code class="docutils literal notranslate"><span class="pre">LLVMContext</span></code></a><a class="headerlink" href="#achieving-isolation-with-llvmcontext" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">LLVMContext</span></code> is an opaque class in the LLVM API which clients can use to
operate multiple, isolated instances of LLVM concurrently within the same
address space.  For instance, in a hypothetical compile-server, the compilation
of an individual translation unit is conceptually independent from all the
others, and it would be desirable to be able to compile incoming translation
units concurrently on independent server threads.  Fortunately, <code class="docutils literal notranslate"><span class="pre">LLVMContext</span></code>
exists to enable just this kind of scenario!</p>
<p>Conceptually, <code class="docutils literal notranslate"><span class="pre">LLVMContext</span></code> provides isolation.  Every LLVM entity
(<code class="docutils literal notranslate"><span class="pre">Module</span></code>s, <code class="docutils literal notranslate"><span class="pre">Value</span></code>s, <code class="docutils literal notranslate"><span class="pre">Type</span></code>s, <code class="docutils literal notranslate"><span class="pre">Constant</span></code>s, etc.) in LLVM’s
in-memory IR belongs to an <code class="docutils literal notranslate"><span class="pre">LLVMContext</span></code>.  Entities in different contexts
<em>cannot</em> interact with each other: <code class="docutils literal notranslate"><span class="pre">Module</span></code>s in different contexts cannot be
linked together, <code class="docutils literal notranslate"><span class="pre">Function</span></code>s cannot be added to <code class="docutils literal notranslate"><span class="pre">Module</span></code>s in different
contexts, etc.  What this means is that is safe to compile on multiple
threads simultaneously, as long as no two threads operate on entities within the
same context.</p>
<p>In practice, very few places in the API require the explicit specification of a
<code class="docutils literal notranslate"><span class="pre">LLVMContext</span></code>, other than the <code class="docutils literal notranslate"><span class="pre">Type</span></code> creation/lookup APIs.  Because every
<code class="docutils literal notranslate"><span class="pre">Type</span></code> carries a reference to its owning context, most other entities can
determine what context they belong to by looking at their own <code class="docutils literal notranslate"><span class="pre">Type</span></code>.  If you
are adding new entities to LLVM IR, please try to maintain this interface
design.</p>
</div>
<div class="section" id="threads-and-the-jit">
<span id="jitthreading"></span><h3><a class="toc-backref" href="#id116">Threads and the JIT</a><a class="headerlink" href="#threads-and-the-jit" title="Permalink to this headline">¶</a></h3>
<p>LLVM’s “eager” JIT compiler is safe to use in threaded programs.  Multiple
threads can call <code class="docutils literal notranslate"><span class="pre">ExecutionEngine::getPointerToFunction()</span></code> or
<code class="docutils literal notranslate"><span class="pre">ExecutionEngine::runFunction()</span></code> concurrently, and multiple threads can run
code output by the JIT concurrently.  The user must still ensure that only one
thread accesses IR in a given <code class="docutils literal notranslate"><span class="pre">LLVMContext</span></code> while another thread might be
modifying it.  One way to do that is to always hold the JIT lock while accessing
IR outside the JIT (the JIT <em>modifies</em> the IR by adding <code class="docutils literal notranslate"><span class="pre">CallbackVH</span></code>s).
Another way is to only call <code class="docutils literal notranslate"><span class="pre">getPointerToFunction()</span></code> from the
<code class="docutils literal notranslate"><span class="pre">LLVMContext</span></code>’s thread.</p>
<p>When the JIT is configured to compile lazily (using
<code class="docutils literal notranslate"><span class="pre">ExecutionEngine::DisableLazyCompilation(false)</span></code>), there is currently a <a class="reference external" href="https://bugs.llvm.org/show_bug.cgi?id=5184">race
condition</a> in updating call sites
after a function is lazily-jitted.  It’s still possible to use the lazy JIT in a
threaded program if you ensure that only one thread at a time can call any
particular lazy stub and that the JIT lock guards any IR access, but we suggest
using only the eager JIT in threaded programs.</p>
</div>
</div>
<div class="section" id="advanced-topics">
<span id="advanced"></span><h2><a class="toc-backref" href="#id117">Advanced Topics</a><a class="headerlink" href="#advanced-topics" title="Permalink to this headline">¶</a></h2>
<p>This section describes some of the advanced or obscure API’s that most clients
do not need to be aware of.  These API’s tend manage the inner workings of the
LLVM system, and only need to be accessed in unusual circumstances.</p>
<div class="section" id="the-valuesymboltable-class">
<span id="symboltable"></span><h3><a class="toc-backref" href="#id118">The <code class="docutils literal notranslate"><span class="pre">ValueSymbolTable</span></code> class</a><a class="headerlink" href="#the-valuesymboltable-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ValueSymbolTable</span></code> (<a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1ValueSymbolTable.html">doxygen</a>) class provides
a symbol table that the <a class="reference internal" href="#c-function"><span class="std std-ref">Function</span></a> and <a class="reference internal" href="#module">Module</a> classes use for
naming value definitions.  The symbol table can provide a name for any <a class="reference internal" href="#value">Value</a>.</p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">SymbolTable</span></code> class should not be directly accessed by most
clients.  It should only be used when iteration over the symbol table names
themselves are required, which is very special purpose.  Note that not all LLVM
<a class="reference internal" href="#value">Value</a>s have names, and those without names (i.e. they have an empty name) do
not exist in the symbol table.</p>
<p>Symbol tables support iteration over the values in the symbol table with
<code class="docutils literal notranslate"><span class="pre">begin/end/iterator</span></code> and supports querying to see if a specific name is in the
symbol table (with <code class="docutils literal notranslate"><span class="pre">lookup</span></code>).  The <code class="docutils literal notranslate"><span class="pre">ValueSymbolTable</span></code> class exposes no
public mutator methods, instead, simply call <code class="docutils literal notranslate"><span class="pre">setName</span></code> on a value, which will
autoinsert it into the appropriate symbol table.</p>
</div>
<div class="section" id="the-user-and-owned-use-classes-memory-layout">
<span id="userlayout"></span><h3><a class="toc-backref" href="#id119">The <code class="docutils literal notranslate"><span class="pre">User</span></code> and owned <code class="docutils literal notranslate"><span class="pre">Use</span></code> classes’ memory layout</a><a class="headerlink" href="#the-user-and-owned-use-classes-memory-layout" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">User</span></code> (<a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1User.html">doxygen</a>)
class provides a basis for expressing the ownership of <code class="docutils literal notranslate"><span class="pre">User</span></code> towards other
<a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Value.html">Value instance</a>s.  The
<code class="docutils literal notranslate"><span class="pre">Use</span></code> (<a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Use.html">doxygen</a>) helper
class is employed to do the bookkeeping and to facilitate <em>O(1)</em> addition and
removal.</p>
<div class="section" id="interaction-and-relationship-between-user-and-use-objects">
<span id="use2user"></span><h4><a class="toc-backref" href="#id120">Interaction and relationship between <code class="docutils literal notranslate"><span class="pre">User</span></code> and <code class="docutils literal notranslate"><span class="pre">Use</span></code> objects</a><a class="headerlink" href="#interaction-and-relationship-between-user-and-use-objects" title="Permalink to this headline">¶</a></h4>
<p>A subclass of <code class="docutils literal notranslate"><span class="pre">User</span></code> can choose between incorporating its <code class="docutils literal notranslate"><span class="pre">Use</span></code> objects or
refer to them out-of-line by means of a pointer.  A mixed variant (some <code class="docutils literal notranslate"><span class="pre">Use</span></code>
s inline others hung off) is impractical and breaks the invariant that the
<code class="docutils literal notranslate"><span class="pre">Use</span></code> objects belonging to the same <code class="docutils literal notranslate"><span class="pre">User</span></code> form a contiguous array.</p>
<p>We have 2 different layouts in the <code class="docutils literal notranslate"><span class="pre">User</span></code> (sub)classes:</p>
<ul>
<li><p>Layout a)</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Use</span></code> object(s) are inside (resp. at fixed offset) of the <code class="docutils literal notranslate"><span class="pre">User</span></code>
object and there are a fixed number of them.</p>
</li>
<li><p>Layout b)</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Use</span></code> object(s) are referenced by a pointer to an array from the
<code class="docutils literal notranslate"><span class="pre">User</span></code> object and there may be a variable number of them.</p>
</li>
</ul>
<p>As of v2.4 each layout still possesses a direct pointer to the start of the
array of <code class="docutils literal notranslate"><span class="pre">Use</span></code>s.  Though not mandatory for layout a), we stick to this
redundancy for the sake of simplicity.  The <code class="docutils literal notranslate"><span class="pre">User</span></code> object also stores the
number of <code class="docutils literal notranslate"><span class="pre">Use</span></code> objects it has. (Theoretically this information can also be
calculated given the scheme presented below.)</p>
<p>Special forms of allocation operators (<code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">new</span></code>) enforce the following
memory layouts:</p>
<ul>
<li><p>Layout a) is modelled by prepending the <code class="docutils literal notranslate"><span class="pre">User</span></code> object by the <code class="docutils literal notranslate"><span class="pre">Use[]</span></code>
array.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>...---.---.---.---.-------...
  | P | P | P | P | User
&#39;&#39;&#39;---&#39;---&#39;---&#39;---&#39;-------&#39;&#39;&#39;
</pre></div>
</div>
</li>
<li><p>Layout b) is modelled by pointing at the <code class="docutils literal notranslate"><span class="pre">Use[]</span></code> array.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.-------...
| User
&#39;-------&#39;&#39;&#39;
    |
    v
    .---.---.---.---...
    | P | P | P | P |
    &#39;---&#39;---&#39;---&#39;---&#39;&#39;&#39;
</pre></div>
</div>
</li>
</ul>
<p><em>(In the above figures</em> ‘<code class="docutils literal notranslate"><span class="pre">P</span></code>’ <em>stands for the</em> <code class="docutils literal notranslate"><span class="pre">Use**</span></code> <em>that is stored in
each</em> <code class="docutils literal notranslate"><span class="pre">Use</span></code> <em>object in the member</em> <code class="docutils literal notranslate"><span class="pre">Use::Prev</span></code> <em>)</em></p>
</div>
<div class="section" id="the-waymarking-algorithm">
<span id="waymarking"></span><h4><a class="toc-backref" href="#id121">The waymarking algorithm</a><a class="headerlink" href="#the-waymarking-algorithm" title="Permalink to this headline">¶</a></h4>
<p>Since the <code class="docutils literal notranslate"><span class="pre">Use</span></code> objects are deprived of the direct (back)pointer to their
<code class="docutils literal notranslate"><span class="pre">User</span></code> objects, there must be a fast and exact method to recover it.  This is
accomplished by the following scheme:</p>
<p>A bit-encoding in the 2 LSBits (least significant bits) of the <code class="docutils literal notranslate"><span class="pre">Use::Prev</span></code>
allows to find the start of the <code class="docutils literal notranslate"><span class="pre">User</span></code> object:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">00</span></code> — binary digit 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">01</span></code> — binary digit 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">10</span></code> — stop and calculate (<code class="docutils literal notranslate"><span class="pre">s</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">11</span></code> — full stop (<code class="docutils literal notranslate"><span class="pre">S</span></code>)</p></li>
</ul>
<p>Given a <code class="docutils literal notranslate"><span class="pre">Use*</span></code>, all we have to do is to walk till we get a stop and we either
have a <code class="docutils literal notranslate"><span class="pre">User</span></code> immediately behind or we have to walk to the next stop picking
up digits and calculating the offset:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.---.---.---.---.---.---.---.---.---.---.---.---.---.---.---.---.----------------
| 1 | s | 1 | 0 | 1 | 0 | s | 1 | 1 | 0 | s | 1 | 1 | s | 1 | S | User (or User*)
&#39;---&#39;---&#39;---&#39;---&#39;---&#39;---&#39;---&#39;---&#39;---&#39;---&#39;---&#39;---&#39;---&#39;---&#39;---&#39;---&#39;----------------
    |+15                |+10            |+6         |+3     |+1
    |                   |               |           |       | __&gt;
    |                   |               |           | __________&gt;
    |                   |               | ______________________&gt;
    |                   | ______________________________________&gt;
    | __________________________________________________________&gt;
</pre></div>
</div>
<p>Only the significant number of bits need to be stored between the stops, so that
the <em>worst case is 20 memory accesses</em> when there are 1000 <code class="docutils literal notranslate"><span class="pre">Use</span></code> objects
associated with a <code class="docutils literal notranslate"><span class="pre">User</span></code>.</p>
</div>
<div class="section" id="reference-implementation">
<span id="referenceimpl"></span><h4><a class="toc-backref" href="#id122">Reference implementation</a><a class="headerlink" href="#reference-implementation" title="Permalink to this headline">¶</a></h4>
<p>The following literate Haskell fragment demonstrates the concept:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Test.QuickCheck</span>
<span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="n">digits</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="n">digits</span> <span class="mi">0</span> <span class="n">acc</span> <span class="ow">=</span> <span class="sc">&#39;0&#39;</span> <span class="kt">:</span> <span class="n">acc</span>
<span class="o">&gt;</span> <span class="n">digits</span> <span class="mi">1</span> <span class="n">acc</span> <span class="ow">=</span> <span class="sc">&#39;1&#39;</span> <span class="kt">:</span> <span class="n">acc</span>
<span class="o">&gt;</span> <span class="n">digits</span> <span class="n">n</span> <span class="n">acc</span> <span class="ow">=</span> <span class="n">digits</span> <span class="p">(</span><span class="n">n</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">2</span><span class="p">)</span> <span class="o">$</span> <span class="n">digits</span> <span class="p">(</span><span class="n">n</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">2</span><span class="p">)</span> <span class="n">acc</span>
<span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="n">dist</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="n">dist</span> <span class="mi">0</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="p">[</span><span class="sc">&#39;S&#39;</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="n">dist</span> <span class="mi">0</span> <span class="n">acc</span> <span class="ow">=</span> <span class="n">acc</span>
<span class="o">&gt;</span> <span class="n">dist</span> <span class="mi">1</span> <span class="n">acc</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">dist</span> <span class="mi">0</span> <span class="n">acc</span> <span class="kr">in</span> <span class="sc">&#39;s&#39;</span> <span class="kt">:</span> <span class="n">digits</span> <span class="p">(</span><span class="n">length</span> <span class="n">r</span><span class="p">)</span> <span class="n">r</span>
<span class="o">&gt;</span> <span class="n">dist</span> <span class="n">n</span> <span class="n">acc</span> <span class="ow">=</span> <span class="n">dist</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">$</span> <span class="n">dist</span> <span class="mi">1</span> <span class="n">acc</span>
<span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="n">takeLast</span> <span class="n">n</span> <span class="n">ss</span> <span class="ow">=</span> <span class="n">reverse</span> <span class="o">$</span> <span class="n">take</span> <span class="n">n</span> <span class="o">$</span> <span class="n">reverse</span> <span class="n">ss</span>
<span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="n">test</span> <span class="ow">=</span> <span class="n">takeLast</span> <span class="mi">40</span> <span class="o">$</span> <span class="n">dist</span> <span class="mi">20</span> <span class="kt">[]</span>
<span class="o">&gt;</span>
</pre></div>
</div>
<p>Printing &lt;test&gt; gives: <code class="docutils literal notranslate"><span class="pre">&quot;1s100000s11010s10100s1111s1010s110s11s1S&quot;</span></code></p>
<p>The reverse algorithm computes the length of the string just by examining a
certain prefix:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">pref</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="o">&gt;</span> <span class="n">pref</span> <span class="s">&quot;S&quot;</span> <span class="ow">=</span> <span class="mi">1</span>
<span class="o">&gt;</span> <span class="n">pref</span> <span class="p">(</span><span class="sc">&#39;s&#39;</span><span class="kt">:</span><span class="sc">&#39;1&#39;</span><span class="kt">:</span><span class="n">rest</span><span class="p">)</span> <span class="ow">=</span> <span class="n">decode</span> <span class="mi">2</span> <span class="mi">1</span> <span class="n">rest</span>
<span class="o">&gt;</span> <span class="n">pref</span> <span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="n">rest</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">pref</span> <span class="n">rest</span>
<span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="n">decode</span> <span class="n">walk</span> <span class="n">acc</span> <span class="p">(</span><span class="sc">&#39;0&#39;</span><span class="kt">:</span><span class="n">rest</span><span class="p">)</span> <span class="ow">=</span> <span class="n">decode</span> <span class="p">(</span><span class="n">walk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">acc</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="n">rest</span>
<span class="o">&gt;</span> <span class="n">decode</span> <span class="n">walk</span> <span class="n">acc</span> <span class="p">(</span><span class="sc">&#39;1&#39;</span><span class="kt">:</span><span class="n">rest</span><span class="p">)</span> <span class="ow">=</span> <span class="n">decode</span> <span class="p">(</span><span class="n">walk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">acc</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">rest</span>
<span class="o">&gt;</span> <span class="n">decode</span> <span class="n">walk</span> <span class="n">acc</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">walk</span> <span class="o">+</span> <span class="n">acc</span>
<span class="o">&gt;</span>
</pre></div>
</div>
<p>Now, as expected, printing &lt;pref test&gt; gives <code class="docutils literal notranslate"><span class="pre">40</span></code>.</p>
<p>We can <em>quickCheck</em> this with following property:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">testcase</span> <span class="ow">=</span> <span class="n">dist</span> <span class="mi">2000</span> <span class="kt">[]</span>
<span class="o">&gt;</span> <span class="n">testcaseLength</span> <span class="ow">=</span> <span class="n">length</span> <span class="n">testcase</span>
<span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="n">identityProp</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">testcaseLength</span> <span class="o">==&gt;</span> <span class="n">length</span> <span class="n">arr</span> <span class="o">==</span> <span class="n">pref</span> <span class="n">arr</span>
<span class="o">&gt;</span>     <span class="kr">where</span> <span class="n">arr</span> <span class="ow">=</span> <span class="n">takeLast</span> <span class="n">n</span> <span class="n">testcase</span>
<span class="o">&gt;</span>
</pre></div>
</div>
<p>As expected &lt;quickCheck identityProp&gt; gives:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="n">Main</span><span class="o">&gt;</span> <span class="n">quickCheck</span> <span class="n">identityProp</span>
<span class="n">OK</span><span class="p">,</span> <span class="n">passed</span> <span class="mi">100</span> <span class="n">tests</span><span class="o">.</span>
</pre></div>
</div>
<p>Let’s be a bit more exhaustive:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="n">deepCheck</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">check</span> <span class="p">(</span><span class="n">defaultConfig</span> <span class="p">{</span> <span class="n">configMaxTest</span> <span class="ow">=</span> <span class="mi">500</span> <span class="p">})</span> <span class="n">p</span>
<span class="o">&gt;</span>
</pre></div>
</div>
<p>And here is the result of &lt;deepCheck identityProp&gt;:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="n">Main</span><span class="o">&gt;</span> <span class="n">deepCheck</span> <span class="n">identityProp</span>
<span class="n">OK</span><span class="p">,</span> <span class="n">passed</span> <span class="mi">500</span> <span class="n">tests</span><span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="tagging-considerations">
<span id="tagging"></span><h4><a class="toc-backref" href="#id123">Tagging considerations</a><a class="headerlink" href="#tagging-considerations" title="Permalink to this headline">¶</a></h4>
<p>To maintain the invariant that the 2 LSBits of each <code class="docutils literal notranslate"><span class="pre">Use**</span></code> in <code class="docutils literal notranslate"><span class="pre">Use</span></code> never
change after being set up, setters of <code class="docutils literal notranslate"><span class="pre">Use::Prev</span></code> must re-tag the new
<code class="docutils literal notranslate"><span class="pre">Use**</span></code> on every modification.  Accordingly getters must strip the tag bits.</p>
<p>For layout b) instead of the <code class="docutils literal notranslate"><span class="pre">User</span></code> we find a pointer (<code class="docutils literal notranslate"><span class="pre">User*</span></code> with LSBit
set).  Following this pointer brings us to the <code class="docutils literal notranslate"><span class="pre">User</span></code>.  A portable trick
ensures that the first bytes of <code class="docutils literal notranslate"><span class="pre">User</span></code> (if interpreted as a pointer) never has
the LSBit set. (Portability is relying on the fact that all known compilers
place the <code class="docutils literal notranslate"><span class="pre">vptr</span></code> in the first word of the instances.)</p>
</div>
</div>
<div class="section" id="designing-type-hiercharies-and-polymorphic-interfaces">
<span id="polymorphism"></span><h3><a class="toc-backref" href="#id124">Designing Type Hiercharies and Polymorphic Interfaces</a><a class="headerlink" href="#designing-type-hiercharies-and-polymorphic-interfaces" title="Permalink to this headline">¶</a></h3>
<p>There are two different design patterns that tend to result in the use of
virtual dispatch for methods in a type hierarchy in C++ programs. The first is
a genuine type hierarchy where different types in the hierarchy model
a specific subset of the functionality and semantics, and these types nest
strictly within each other. Good examples of this can be seen in the <code class="docutils literal notranslate"><span class="pre">Value</span></code>
or <code class="docutils literal notranslate"><span class="pre">Type</span></code> type hierarchies.</p>
<p>A second is the desire to dispatch dynamically across a collection of
polymorphic interface implementations. This latter use case can be modeled with
virtual dispatch and inheritance by defining an abstract interface base class
which all implementations derive from and override. However, this
implementation strategy forces an <strong>“is-a”</strong> relationship to exist that is not
actually meaningful. There is often not some nested hierarchy of useful
generalizations which code might interact with and move up and down. Instead,
there is a singular interface which is dispatched across a range of
implementations.</p>
<p>The preferred implementation strategy for the second use case is that of
generic programming (sometimes called “compile-time duck typing” or “static
polymorphism”). For example, a template over some type parameter <code class="docutils literal notranslate"><span class="pre">T</span></code> can be
instantiated across any particular implementation that conforms to the
interface or <em>concept</em>. A good example here is the highly generic properties of
any type which models a node in a directed graph. LLVM models these primarily
through templates and generic programming. Such templates include the
<code class="docutils literal notranslate"><span class="pre">LoopInfoBase</span></code> and <code class="docutils literal notranslate"><span class="pre">DominatorTreeBase</span></code>. When this type of polymorphism
truly needs <strong>dynamic</strong> dispatch you can generalize it using a technique
called <em>concept-based polymorphism</em>. This pattern emulates the interfaces and
behaviors of templates using a very limited form of virtual dispatch for type
erasure inside its implementation. You can find examples of this technique in
the <code class="docutils literal notranslate"><span class="pre">PassManager.h</span></code> system, and there is a more detailed introduction to it
by Sean Parent in several of his talks and papers:</p>
<ol class="arabic simple">
<li><p><a class="reference external" href="http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil">Inheritance Is The Base Class of Evil</a>
- The GoingNative 2013 talk describing this technique, and probably the best
place to start.</p></li>
<li><p><a class="reference external" href="http://www.youtube.com/watch?v=_BpMYeUFXv8">Value Semantics and Concepts-based Polymorphism</a> - The C++Now! 2012 talk
describing this technique in more detail.</p></li>
<li><p><a class="reference external" href="http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations">Sean Parent’s Papers and Presentations</a>
- A Github project full of links to slides, video, and sometimes code.</p></li>
</ol>
<p>When deciding between creating a type hierarchy (with either tagged or virtual
dispatch) and using templates or concepts-based polymorphism, consider whether
there is some refinement of an abstract base class which is a semantically
meaningful type on an interface boundary. If anything more refined than the
root abstract interface is meaningless to talk about as a partial extension of
the semantic model, then your use case likely fits better with polymorphism and
you should avoid using virtual dispatch. However, there may be some exigent
circumstances that require one technique or the other to be used.</p>
<p>If you do need to introduce a type hierarchy, we prefer to use explicitly
closed type hierarchies with manual tagged dispatch and/or RTTI rather than the
open inheritance model and virtual dispatch that is more common in C++ code.
This is because LLVM rarely encourages library consumers to extend its core
types, and leverages the closed and tag-dispatched nature of its hierarchies to
generate significantly more efficient code. We have also found that a large
amount of our usage of type hierarchies fits better with tag-based pattern
matching rather than dynamic dispatch across a common interface. Within LLVM we
have built custom helpers to facilitate this design. See this document’s
section on <a class="reference internal" href="#isa"><span class="std std-ref">isa and dyn_cast</span></a> and our <a class="reference internal" href="HowToSetUpLLVMStyleRTTI.html"><span class="doc">detailed document</span></a> which describes how you can implement this
pattern for use with the LLVM helpers.</p>
</div>
<div class="section" id="abi-breaking-checks">
<span id="id5"></span><h3><a class="toc-backref" href="#id125">ABI Breaking Checks</a><a class="headerlink" href="#abi-breaking-checks" title="Permalink to this headline">¶</a></h3>
<p>Checks and asserts that alter the LLVM C++ ABI are predicated on the
preprocessor symbol <cite>LLVM_ENABLE_ABI_BREAKING_CHECKS</cite> – LLVM
libraries built with <cite>LLVM_ENABLE_ABI_BREAKING_CHECKS</cite> are not ABI
compatible LLVM libraries built without it defined.  By default,
turning on assertions also turns on <cite>LLVM_ENABLE_ABI_BREAKING_CHECKS</cite>
so a default +Asserts build is not ABI compatible with a
default -Asserts build.  Clients that want ABI compatibility
between +Asserts and -Asserts builds should use the CMake build system
to set <cite>LLVM_ENABLE_ABI_BREAKING_CHECKS</cite> independently
of <cite>LLVM_ENABLE_ASSERTIONS</cite>.</p>
</div>
</div>
<div class="section" id="the-core-llvm-class-hierarchy-reference">
<span id="coreclasses"></span><h2><a class="toc-backref" href="#id126">The Core LLVM Class Hierarchy Reference</a><a class="headerlink" href="#the-core-llvm-class-hierarchy-reference" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;llvm/IR/Type.h&quot;</span></code></p>
<p>header source: <a class="reference external" href="http://llvm.org/doxygen/Type_8h_source.html">Type.h</a></p>
<p>doxygen info: <a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Type.html">Type Clases</a></p>
<p>The Core LLVM classes are the primary means of representing the program being
inspected or transformed.  The core LLVM classes are defined in header files in
the <code class="docutils literal notranslate"><span class="pre">include/llvm/IR</span></code> directory, and implemented in the <code class="docutils literal notranslate"><span class="pre">lib/IR</span></code>
directory. It’s worth noting that, for historical reasons, this library is
called <code class="docutils literal notranslate"><span class="pre">libLLVMCore.so</span></code>, not <code class="docutils literal notranslate"><span class="pre">libLLVMIR.so</span></code> as you might expect.</p>
<div class="section" id="the-type-class-and-derived-types">
<span id="type"></span><h3><a class="toc-backref" href="#id127">The Type class and Derived Types</a><a class="headerlink" href="#the-type-class-and-derived-types" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Type</span></code> is a superclass of all type classes.  Every <code class="docutils literal notranslate"><span class="pre">Value</span></code> has a <code class="docutils literal notranslate"><span class="pre">Type</span></code>.
<code class="docutils literal notranslate"><span class="pre">Type</span></code> cannot be instantiated directly but only through its subclasses.
Certain primitive types (<code class="docutils literal notranslate"><span class="pre">VoidType</span></code>, <code class="docutils literal notranslate"><span class="pre">LabelType</span></code>, <code class="docutils literal notranslate"><span class="pre">FloatType</span></code> and
<code class="docutils literal notranslate"><span class="pre">DoubleType</span></code>) have hidden subclasses.  They are hidden because they offer no
useful functionality beyond what the <code class="docutils literal notranslate"><span class="pre">Type</span></code> class offers except to distinguish
themselves from other subclasses of <code class="docutils literal notranslate"><span class="pre">Type</span></code>.</p>
<p>All other types are subclasses of <code class="docutils literal notranslate"><span class="pre">DerivedType</span></code>.  Types can be named, but this
is not a requirement.  There exists exactly one instance of a given shape at any
one time.  This allows type equality to be performed with address equality of
the Type Instance.  That is, given two <code class="docutils literal notranslate"><span class="pre">Type*</span></code> values, the types are identical
if the pointers are identical.</p>
<div class="section" id="important-public-methods">
<span id="m-type"></span><h4><a class="toc-backref" href="#id128">Important Public Methods</a><a class="headerlink" href="#important-public-methods" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">isIntegerTy()</span> <span class="pre">const</span></code>: Returns true for any integer type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">isFloatingPointTy()</span></code>: Return true if this is one of the five
floating point types.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">isSized()</span></code>: Return true if the type has known size.  Things
that don’t have a size are abstract types, labels and void.</p></li>
</ul>
</div>
<div class="section" id="important-derived-types">
<span id="derivedtypes"></span><h4><a class="toc-backref" href="#id129">Important Derived Types</a><a class="headerlink" href="#important-derived-types" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IntegerType</span></code></dt><dd><p>Subclass of DerivedType that represents integer types of any bit width.  Any
bit width between <code class="docutils literal notranslate"><span class="pre">IntegerType::MIN_INT_BITS</span></code> (1) and
<code class="docutils literal notranslate"><span class="pre">IntegerType::MAX_INT_BITS</span></code> (~8 million) can be represented.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">const</span> <span class="pre">IntegerType*</span> <span class="pre">get(unsigned</span> <span class="pre">NumBits)</span></code>: get an integer
type of a specific bit width.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">getBitWidth()</span> <span class="pre">const</span></code>: Get the bit width of an integer type.</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SequentialType</span></code></dt><dd><p>This is subclassed by ArrayType and VectorType.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">Type</span> <span class="pre">*</span> <span class="pre">getElementType()</span> <span class="pre">const</span></code>: Returns the type of each
of the elements in the sequential type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">getNumElements()</span> <span class="pre">const</span></code>: Returns the number of elements
in the sequential type.</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ArrayType</span></code></dt><dd><p>This is a subclass of SequentialType and defines the interface for array
types.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PointerType</span></code></dt><dd><p>Subclass of Type for pointer types.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VectorType</span></code></dt><dd><p>Subclass of SequentialType for vector types.  A vector type is similar to an
ArrayType but is distinguished because it is a first class type whereas
ArrayType is not.  Vector types are used for vector operations and are usually
small vectors of an integer or floating point type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">StructType</span></code></dt><dd><p>Subclass of DerivedTypes for struct types.</p>
</dd>
</dl>
<dl class="simple" id="functiontype">
<dt><code class="docutils literal notranslate"><span class="pre">FunctionType</span></code></dt><dd><p>Subclass of DerivedTypes for function types.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">isVarArg()</span> <span class="pre">const</span></code>: Returns true if it’s a vararg function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">Type</span> <span class="pre">*</span> <span class="pre">getReturnType()</span> <span class="pre">const</span></code>: Returns the return type of the
function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">Type</span> <span class="pre">*</span> <span class="pre">getParamType</span> <span class="pre">(unsigned</span> <span class="pre">i)</span></code>: Returns the type of the ith
parameter.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">getNumParams()</span> <span class="pre">const</span></code>: Returns the number of formal
parameters.</p></li>
</ul>
</dd>
</dl>
</div>
</div>
<div class="section" id="the-module-class">
<span id="module"></span><h3><a class="toc-backref" href="#id130">The <code class="docutils literal notranslate"><span class="pre">Module</span></code> class</a><a class="headerlink" href="#the-module-class" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;llvm/IR/Module.h&quot;</span></code></p>
<p>header source: <a class="reference external" href="http://llvm.org/doxygen/Module_8h_source.html">Module.h</a></p>
<p>doxygen info: <a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Module.html">Module Class</a></p>
<p>The <code class="docutils literal notranslate"><span class="pre">Module</span></code> class represents the top level structure present in LLVM
programs.  An LLVM module is effectively either a translation unit of the
original program or a combination of several translation units merged by the
linker.  The <code class="docutils literal notranslate"><span class="pre">Module</span></code> class keeps track of a list of <a class="reference internal" href="#c-function"><span class="std std-ref">Function</span></a>s, a list of <a class="reference internal" href="#globalvariable">GlobalVariable</a>s, and a <a class="reference internal" href="#symboltable">SymbolTable</a>.
Additionally, it contains a few helpful member functions that try to make common
operations easy.</p>
<div class="section" id="important-public-members-of-the-module-class">
<span id="m-module"></span><h4><a class="toc-backref" href="#id131">Important Public Members of the <code class="docutils literal notranslate"><span class="pre">Module</span></code> class</a><a class="headerlink" href="#important-public-members-of-the-module-class" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Module::Module(std::string</span> <span class="pre">name</span> <span class="pre">=</span> <span class="pre">&quot;&quot;)</span></code></p>
<p>Constructing a <a class="reference internal" href="#module">Module</a> is easy.  You can optionally provide a name for it
(probably based on the name of the translation unit).</p>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">Module::iterator</span></code> - Typedef for function list iterator</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">Module::const_iterator</span></code> - Typedef for const_iterator.</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">begin()</span></code>, <code class="docutils literal notranslate"><span class="pre">end()</span></code>, <code class="docutils literal notranslate"><span class="pre">size()</span></code>, <code class="docutils literal notranslate"><span class="pre">empty()</span></code></div>
</div>
<p>These are forwarding methods that make it easy to access the contents of a
<code class="docutils literal notranslate"><span class="pre">Module</span></code> object’s <a class="reference internal" href="#c-function"><span class="std std-ref">Function</span></a> list.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Module::FunctionListType</span> <span class="pre">&amp;getFunctionList()</span></code></p>
<p>Returns the list of <a class="reference internal" href="#c-function"><span class="std std-ref">Function</span></a>s.  This is necessary to use
when you need to update the list or perform a complex action that doesn’t have
a forwarding method.</p>
</li>
</ul>
<hr class="docutils" />
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">Module::global_iterator</span></code> - Typedef for global variable list iterator</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">Module::const_global_iterator</span></code> - Typedef for const_iterator.</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">global_begin()</span></code>, <code class="docutils literal notranslate"><span class="pre">global_end()</span></code>, <code class="docutils literal notranslate"><span class="pre">global_size()</span></code>, <code class="docutils literal notranslate"><span class="pre">global_empty()</span></code></div>
</div>
<p>These are forwarding methods that make it easy to access the contents of a
<code class="docutils literal notranslate"><span class="pre">Module</span></code> object’s <a class="reference internal" href="#globalvariable">GlobalVariable</a> list.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Module::GlobalListType</span> <span class="pre">&amp;getGlobalList()</span></code></p>
<p>Returns the list of <a class="reference internal" href="#globalvariable">GlobalVariable</a>s.  This is necessary to use when you
need to update the list or perform a complex action that doesn’t have a
forwarding method.</p>
</li>
</ul>
<hr class="docutils" />
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">SymbolTable</span> <span class="pre">*getSymbolTable()</span></code></p>
<p>Return a reference to the <a class="reference internal" href="#symboltable">SymbolTable</a> for this <code class="docutils literal notranslate"><span class="pre">Module</span></code>.</p>
</li>
</ul>
<hr class="docutils" />
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Function</span> <span class="pre">*getFunction(StringRef</span> <span class="pre">Name)</span> <span class="pre">const</span></code></p>
<p>Look up the specified function in the <code class="docutils literal notranslate"><span class="pre">Module</span></code> <a class="reference internal" href="#symboltable">SymbolTable</a>.  If it does not
exist, return <code class="docutils literal notranslate"><span class="pre">null</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">FunctionCallee</span> <span class="pre">getOrInsertFunction(const</span> <span class="pre">std::string</span> <span class="pre">&amp;Name,</span>
<span class="pre">const</span> <span class="pre">FunctionType</span> <span class="pre">*T)</span></code></p>
<p>Look up the specified function in the <code class="docutils literal notranslate"><span class="pre">Module</span></code> <a class="reference internal" href="#symboltable">SymbolTable</a>.  If
it does not exist, add an external declaration for the function and
return it. Note that the function signature already present may not
match the requested signature. Thus, in order to enable the common
usage of passing the result directly to EmitCall, the return type is
a struct of <code class="docutils literal notranslate"><span class="pre">{FunctionType</span> <span class="pre">*T,</span> <span class="pre">Constant</span> <span class="pre">*FunctionPtr}</span></code>, rather
than simply the <code class="docutils literal notranslate"><span class="pre">Function*</span></code> with potentially an unexpected
signature.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::string</span> <span class="pre">getTypeName(const</span> <span class="pre">Type</span> <span class="pre">*Ty)</span></code></p>
<p>If there is at least one entry in the <a class="reference internal" href="#symboltable">SymbolTable</a> for the specified <a class="reference internal" href="#type">Type</a>,
return it.  Otherwise return the empty string.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">addTypeName(const</span> <span class="pre">std::string</span> <span class="pre">&amp;Name,</span> <span class="pre">const</span> <span class="pre">Type</span> <span class="pre">*Ty)</span></code></p>
<p>Insert an entry in the <a class="reference internal" href="#symboltable">SymbolTable</a> mapping <code class="docutils literal notranslate"><span class="pre">Name</span></code> to <code class="docutils literal notranslate"><span class="pre">Ty</span></code>.  If there is
already an entry for this name, true is returned and the <a class="reference internal" href="#symboltable">SymbolTable</a> is not
modified.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="the-value-class">
<span id="value"></span><h3><a class="toc-backref" href="#id132">The <code class="docutils literal notranslate"><span class="pre">Value</span></code> class</a><a class="headerlink" href="#the-value-class" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;llvm/IR/Value.h&quot;</span></code></p>
<p>header source: <a class="reference external" href="http://llvm.org/doxygen/Value_8h_source.html">Value.h</a></p>
<p>doxygen info: <a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Value.html">Value Class</a></p>
<p>The <code class="docutils literal notranslate"><span class="pre">Value</span></code> class is the most important class in the LLVM Source base.  It
represents a typed value that may be used (among other things) as an operand to
an instruction.  There are many different types of <code class="docutils literal notranslate"><span class="pre">Value</span></code>s, such as
<a class="reference internal" href="#constant">Constant</a>s, <a class="reference internal" href="#argument">Argument</a>s.  Even <a class="reference internal" href="#instruction">Instruction</a>s and <a class="reference internal" href="#c-function"><span class="std std-ref">Function</span></a>s are <code class="docutils literal notranslate"><span class="pre">Value</span></code>s.</p>
<p>A particular <code class="docutils literal notranslate"><span class="pre">Value</span></code> may be used many times in the LLVM representation for a
program.  For example, an incoming argument to a function (represented with an
instance of the <a class="reference internal" href="#argument">Argument</a> class) is “used” by every instruction in the function
that references the argument.  To keep track of this relationship, the <code class="docutils literal notranslate"><span class="pre">Value</span></code>
class keeps a list of all of the <code class="docutils literal notranslate"><span class="pre">User</span></code>s that is using it (the <a class="reference internal" href="#user">User</a> class
is a base class for all nodes in the LLVM graph that can refer to <code class="docutils literal notranslate"><span class="pre">Value</span></code>s).
This use list is how LLVM represents def-use information in the program, and is
accessible through the <code class="docutils literal notranslate"><span class="pre">use_*</span></code> methods, shown below.</p>
<p>Because LLVM is a typed representation, every LLVM <code class="docutils literal notranslate"><span class="pre">Value</span></code> is typed, and this
<a class="reference internal" href="#type">Type</a> is available through the <code class="docutils literal notranslate"><span class="pre">getType()</span></code> method.  In addition, all LLVM
values can be named.  The “name” of the <code class="docutils literal notranslate"><span class="pre">Value</span></code> is a symbolic string printed
in the LLVM code:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">%foo</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span>
</pre></div>
</div>
<p id="namewarning">The name of this instruction is “foo”. <strong>NOTE</strong> that the name of any value may
be missing (an empty string), so names should <strong>ONLY</strong> be used for debugging
(making the source code easier to read, debugging printouts), they should not be
used to keep track of values or map between them.  For this purpose, use a
<code class="docutils literal notranslate"><span class="pre">std::map</span></code> of pointers to the <code class="docutils literal notranslate"><span class="pre">Value</span></code> itself instead.</p>
<p>One important aspect of LLVM is that there is no distinction between an SSA
variable and the operation that produces it.  Because of this, any reference to
the value produced by an instruction (or the value available as an incoming
argument, for example) is represented as a direct pointer to the instance of the
class that represents this value.  Although this may take some getting used to,
it simplifies the representation and makes it easier to manipulate.</p>
<div class="section" id="important-public-members-of-the-value-class">
<span id="m-value"></span><h4><a class="toc-backref" href="#id133">Important Public Members of the <code class="docutils literal notranslate"><span class="pre">Value</span></code> class</a><a class="headerlink" href="#important-public-members-of-the-value-class" title="Permalink to this headline">¶</a></h4>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">Value::use_iterator</span></code> - Typedef for iterator over the use-list</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">Value::const_use_iterator</span></code> - Typedef for const_iterator over the
use-list</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">use_size()</span></code> - Returns the number of users of the value.</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">use_empty()</span></code> - Returns true if there are no users.</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">use_iterator</span> <span class="pre">use_begin()</span></code> - Get an iterator to the start of the
use-list.</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">use_iterator</span> <span class="pre">use_end()</span></code> - Get an iterator to the end of the use-list.</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">User</span> <span class="pre">*use_back()</span></code> - Returns the last element in the list.</div>
</div>
<p>These methods are the interface to access the def-use information in LLVM.
As with all other iterators in LLVM, the naming conventions follow the
conventions defined by the <a class="reference internal" href="#stl">STL</a>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">*getType()</span> <span class="pre">const</span></code>
This method returns the Type of the Value.</p></li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">hasName()</span> <span class="pre">const</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">std::string</span> <span class="pre">getName()</span> <span class="pre">const</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">setName(const</span> <span class="pre">std::string</span> <span class="pre">&amp;Name)</span></code></div>
</div>
<p>This family of methods is used to access and assign a name to a <code class="docutils literal notranslate"><span class="pre">Value</span></code>, be
aware of the <a class="reference internal" href="#namewarning"><span class="std std-ref">precaution above</span></a>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">replaceAllUsesWith(Value</span> <span class="pre">*V)</span></code></p>
<p>This method traverses the use list of a <code class="docutils literal notranslate"><span class="pre">Value</span></code> changing all <a class="reference internal" href="#user">User</a>s of the
current value to refer to “<code class="docutils literal notranslate"><span class="pre">V</span></code>” instead.  For example, if you detect that an
instruction always produces a constant value (for example through constant
folding), you can replace all uses of the instruction with the constant like
this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Inst</span><span class="o">-&gt;</span><span class="n">replaceAllUsesWith</span><span class="p">(</span><span class="n">ConstVal</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="the-user-class">
<span id="user"></span><h3><a class="toc-backref" href="#id134">The <code class="docutils literal notranslate"><span class="pre">User</span></code> class</a><a class="headerlink" href="#the-user-class" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;llvm/IR/User.h&quot;</span></code></p>
<p>header source: <a class="reference external" href="http://llvm.org/doxygen/User_8h_source.html">User.h</a></p>
<p>doxygen info: <a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1User.html">User Class</a></p>
<p>Superclass: <a class="reference internal" href="#value">Value</a></p>
<p>The <code class="docutils literal notranslate"><span class="pre">User</span></code> class is the common base class of all LLVM nodes that may refer to
<code class="docutils literal notranslate"><span class="pre">Value</span></code>s.  It exposes a list of “Operands” that are all of the <code class="docutils literal notranslate"><span class="pre">Value</span></code>s
that the User is referring to.  The <code class="docutils literal notranslate"><span class="pre">User</span></code> class itself is a subclass of
<code class="docutils literal notranslate"><span class="pre">Value</span></code>.</p>
<p>The operands of a <code class="docutils literal notranslate"><span class="pre">User</span></code> point directly to the LLVM <code class="docutils literal notranslate"><span class="pre">Value</span></code> that it refers
to.  Because LLVM uses Static Single Assignment (SSA) form, there can only be
one definition referred to, allowing this direct connection.  This connection
provides the use-def information in LLVM.</p>
<div class="section" id="important-public-members-of-the-user-class">
<span id="m-user"></span><h4><a class="toc-backref" href="#id135">Important Public Members of the <code class="docutils literal notranslate"><span class="pre">User</span></code> class</a><a class="headerlink" href="#important-public-members-of-the-user-class" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">User</span></code> class exposes the operand list in two ways: through an index access
interface and through an iterator based interface.</p>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">Value</span> <span class="pre">*getOperand(unsigned</span> <span class="pre">i)</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">getNumOperands()</span></code></div>
</div>
<p>These two methods expose the operands of the <code class="docutils literal notranslate"><span class="pre">User</span></code> in a convenient form for
direct access.</p>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">User::op_iterator</span></code> - Typedef for iterator over the operand list</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">op_iterator</span> <span class="pre">op_begin()</span></code> - Get an iterator to the start of the operand
list.</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">op_iterator</span> <span class="pre">op_end()</span></code> - Get an iterator to the end of the operand list.</div>
</div>
<p>Together, these methods make up the iterator based interface to the operands
of a <code class="docutils literal notranslate"><span class="pre">User</span></code>.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="the-instruction-class">
<span id="instruction"></span><h3><a class="toc-backref" href="#id136">The <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> class</a><a class="headerlink" href="#the-instruction-class" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;llvm/IR/Instruction.h&quot;</span></code></p>
<p>header source: <a class="reference external" href="http://llvm.org/doxygen/Instruction_8h_source.html">Instruction.h</a></p>
<p>doxygen info: <a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Instruction.html">Instruction Class</a></p>
<p>Superclasses: <a class="reference internal" href="#user">User</a>, <a class="reference internal" href="#value">Value</a></p>
<p>The <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> class is the common base class for all LLVM instructions.
It provides only a few methods, but is a very commonly used class.  The primary
data tracked by the <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> class itself is the opcode (instruction
type) and the parent <a class="reference internal" href="#basicblock">BasicBlock</a> the <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> is embedded into.  To
represent a specific type of instruction, one of many subclasses of
<code class="docutils literal notranslate"><span class="pre">Instruction</span></code> are used.</p>
<p>Because the <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> class subclasses the <a class="reference internal" href="#user">User</a> class, its operands can
be accessed in the same way as for other <code class="docutils literal notranslate"><span class="pre">User</span></code>s (with the
<code class="docutils literal notranslate"><span class="pre">getOperand()</span></code>/<code class="docutils literal notranslate"><span class="pre">getNumOperands()</span></code> and <code class="docutils literal notranslate"><span class="pre">op_begin()</span></code>/<code class="docutils literal notranslate"><span class="pre">op_end()</span></code> methods).
An important file for the <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> class is the <code class="docutils literal notranslate"><span class="pre">llvm/Instruction.def</span></code>
file.  This file contains some meta-data about the various different types of
instructions in LLVM.  It describes the enum values that are used as opcodes
(for example <code class="docutils literal notranslate"><span class="pre">Instruction::Add</span></code> and <code class="docutils literal notranslate"><span class="pre">Instruction::ICmp</span></code>), as well as the
concrete sub-classes of <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> that implement the instruction (for
example <a class="reference internal" href="#binaryoperator">BinaryOperator</a> and <a class="reference internal" href="#cmpinst">CmpInst</a>).  Unfortunately, the use of macros in this
file confuses doxygen, so these enum values don’t show up correctly in the
<a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Instruction.html">doxygen output</a>.</p>
<div class="section" id="important-subclasses-of-the-instruction-class">
<span id="s-instruction"></span><h4><a class="toc-backref" href="#id137">Important Subclasses of the <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> class</a><a class="headerlink" href="#important-subclasses-of-the-instruction-class" title="Permalink to this headline">¶</a></h4>
<ul id="binaryoperator">
<li><p><code class="docutils literal notranslate"><span class="pre">BinaryOperator</span></code></p>
<p>This subclasses represents all two operand instructions whose operands must be
the same type, except for the comparison instructions.</p>
</li>
</ul>
<ul class="simple" id="castinst">
<li><p><code class="docutils literal notranslate"><span class="pre">CastInst</span></code>
This subclass is the parent of the 12 casting instructions.  It provides
common operations on cast instructions.</p></li>
</ul>
<ul id="cmpinst">
<li><p><code class="docutils literal notranslate"><span class="pre">CmpInst</span></code></p>
<p>This subclass represents the two comparison instructions,
<a class="reference external" href="LangRef.html#i_icmp">ICmpInst</a> (integer opreands), and
<a class="reference external" href="LangRef.html#i_fcmp">FCmpInst</a> (floating point operands).</p>
</li>
</ul>
</div>
<div class="section" id="important-public-members-of-the-instruction-class">
<span id="m-instruction"></span><h4><a class="toc-backref" href="#id138">Important Public Members of the <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> class</a><a class="headerlink" href="#important-public-members-of-the-instruction-class" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">BasicBlock</span> <span class="pre">*getParent()</span></code></p>
<p>Returns the <a class="reference internal" href="#basicblock">BasicBlock</a> that this
<code class="docutils literal notranslate"><span class="pre">Instruction</span></code> is embedded into.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">mayWriteToMemory()</span></code></p>
<p>Returns true if the instruction writes to memory, i.e. it is a <code class="docutils literal notranslate"><span class="pre">call</span></code>,
<code class="docutils literal notranslate"><span class="pre">free</span></code>, <code class="docutils literal notranslate"><span class="pre">invoke</span></code>, or <code class="docutils literal notranslate"><span class="pre">store</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">getOpcode()</span></code></p>
<p>Returns the opcode for the <code class="docutils literal notranslate"><span class="pre">Instruction</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Instruction</span> <span class="pre">*clone()</span> <span class="pre">const</span></code></p>
<p>Returns another instance of the specified instruction, identical in all ways
to the original except that the instruction has no parent (i.e. it’s not
embedded into a <a class="reference internal" href="#basicblock">BasicBlock</a>), and it has no name.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="the-constant-class-and-subclasses">
<span id="constant"></span><h3><a class="toc-backref" href="#id139">The <code class="docutils literal notranslate"><span class="pre">Constant</span></code> class and subclasses</a><a class="headerlink" href="#the-constant-class-and-subclasses" title="Permalink to this headline">¶</a></h3>
<p>Constant represents a base class for different types of constants.  It is
subclassed by ConstantInt, ConstantArray, etc. for representing the various
types of Constants.  <a class="reference internal" href="#globalvalue">GlobalValue</a> is also a subclass, which represents the
address of a global variable or function.</p>
<div class="section" id="important-subclasses-of-constant">
<span id="s-constant"></span><h4><a class="toc-backref" href="#id140">Important Subclasses of Constant</a><a class="headerlink" href="#important-subclasses-of-constant" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>ConstantInt : This subclass of Constant represents an integer constant of
any width.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">APInt&amp;</span> <span class="pre">getValue()</span> <span class="pre">const</span></code>: Returns the underlying
value of this constant, an APInt value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int64_t</span> <span class="pre">getSExtValue()</span> <span class="pre">const</span></code>: Converts the underlying APInt value to an
int64_t via sign extension.  If the value (not the bit width) of the APInt
is too large to fit in an int64_t, an assertion will result.  For this
reason, use of this method is discouraged.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">getZExtValue()</span> <span class="pre">const</span></code>: Converts the underlying APInt value
to a uint64_t via zero extension.  IF the value (not the bit width) of the
APInt is too large to fit in a uint64_t, an assertion will result.  For this
reason, use of this method is discouraged.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">ConstantInt*</span> <span class="pre">get(const</span> <span class="pre">APInt&amp;</span> <span class="pre">Val)</span></code>: Returns the ConstantInt
object that represents the value provided by <code class="docutils literal notranslate"><span class="pre">Val</span></code>.  The type is implied
as the IntegerType that corresponds to the bit width of <code class="docutils literal notranslate"><span class="pre">Val</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">ConstantInt*</span> <span class="pre">get(const</span> <span class="pre">Type</span> <span class="pre">*Ty,</span> <span class="pre">uint64_t</span> <span class="pre">Val)</span></code>: Returns the
ConstantInt object that represents the value provided by <code class="docutils literal notranslate"><span class="pre">Val</span></code> for integer
type <code class="docutils literal notranslate"><span class="pre">Ty</span></code>.</p></li>
</ul>
</li>
<li><p>ConstantFP : This class represents a floating point constant.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">double</span> <span class="pre">getValue()</span> <span class="pre">const</span></code>: Returns the underlying value of this constant.</p></li>
</ul>
</li>
<li><p>ConstantArray : This represents a constant array.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">std::vector&lt;Use&gt;</span> <span class="pre">&amp;getValues()</span> <span class="pre">const</span></code>: Returns a vector of
component constants that makeup this array.</p></li>
</ul>
</li>
<li><p>ConstantStruct : This represents a constant struct.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">std::vector&lt;Use&gt;</span> <span class="pre">&amp;getValues()</span> <span class="pre">const</span></code>: Returns a vector of
component constants that makeup this array.</p></li>
</ul>
</li>
<li><p>GlobalValue : This represents either a global variable or a function.  In
either case, the value is a constant fixed address (after linking).</p></li>
</ul>
</div>
</div>
<div class="section" id="the-globalvalue-class">
<span id="globalvalue"></span><h3><a class="toc-backref" href="#id141">The <code class="docutils literal notranslate"><span class="pre">GlobalValue</span></code> class</a><a class="headerlink" href="#the-globalvalue-class" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;llvm/IR/GlobalValue.h&quot;</span></code></p>
<p>header source: <a class="reference external" href="http://llvm.org/doxygen/GlobalValue_8h_source.html">GlobalValue.h</a></p>
<p>doxygen info: <a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1GlobalValue.html">GlobalValue Class</a></p>
<p>Superclasses: <a class="reference internal" href="#constant">Constant</a>, <a class="reference internal" href="#user">User</a>, <a class="reference internal" href="#value">Value</a></p>
<p>Global values ( <a class="reference internal" href="#globalvariable">GlobalVariable</a>s or <a class="reference internal" href="#c-function"><span class="std std-ref">Function</span></a>s) are the
only LLVM values that are visible in the bodies of all <a class="reference internal" href="#c-function"><span class="std std-ref">Function</span></a>s.  Because they are visible at global scope, they are also
subject to linking with other globals defined in different translation units.
To control the linking process, <code class="docutils literal notranslate"><span class="pre">GlobalValue</span></code>s know their linkage rules.
Specifically, <code class="docutils literal notranslate"><span class="pre">GlobalValue</span></code>s know whether they have internal or external
linkage, as defined by the <code class="docutils literal notranslate"><span class="pre">LinkageTypes</span></code> enumeration.</p>
<p>If a <code class="docutils literal notranslate"><span class="pre">GlobalValue</span></code> has internal linkage (equivalent to being <code class="docutils literal notranslate"><span class="pre">static</span></code> in C),
it is not visible to code outside the current translation unit, and does not
participate in linking.  If it has external linkage, it is visible to external
code, and does participate in linking.  In addition to linkage information,
<code class="docutils literal notranslate"><span class="pre">GlobalValue</span></code>s keep track of which <a class="reference internal" href="#module">Module</a> they are currently part of.</p>
<p>Because <code class="docutils literal notranslate"><span class="pre">GlobalValue</span></code>s are memory objects, they are always referred to by
their <strong>address</strong>.  As such, the <a class="reference internal" href="#type">Type</a> of a global is always a pointer to its
contents.  It is important to remember this when using the <code class="docutils literal notranslate"><span class="pre">GetElementPtrInst</span></code>
instruction because this pointer must be dereferenced first.  For example, if
you have a <code class="docutils literal notranslate"><span class="pre">GlobalVariable</span></code> (a subclass of <code class="docutils literal notranslate"><span class="pre">GlobalValue)</span></code> that is an array
of 24 ints, type <code class="docutils literal notranslate"><span class="pre">[24</span> <span class="pre">x</span> <span class="pre">i32]</span></code>, then the <code class="docutils literal notranslate"><span class="pre">GlobalVariable</span></code> is a pointer to
that array.  Although the address of the first element of this array and the
value of the <code class="docutils literal notranslate"><span class="pre">GlobalVariable</span></code> are the same, they have different types.  The
<code class="docutils literal notranslate"><span class="pre">GlobalVariable</span></code>’s type is <code class="docutils literal notranslate"><span class="pre">[24</span> <span class="pre">x</span> <span class="pre">i32]</span></code>.  The first element’s type is
<code class="docutils literal notranslate"><span class="pre">i32.</span></code> Because of this, accessing a global value requires you to dereference
the pointer with <code class="docutils literal notranslate"><span class="pre">GetElementPtrInst</span></code> first, then its elements can be accessed.
This is explained in the <a class="reference external" href="LangRef.html#globalvars">LLVM Language Reference Manual</a>.</p>
<div class="section" id="important-public-members-of-the-globalvalue-class">
<span id="m-globalvalue"></span><h4><a class="toc-backref" href="#id142">Important Public Members of the <code class="docutils literal notranslate"><span class="pre">GlobalValue</span></code> class</a><a class="headerlink" href="#important-public-members-of-the-globalvalue-class" title="Permalink to this headline">¶</a></h4>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">hasInternalLinkage()</span> <span class="pre">const</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">hasExternalLinkage()</span> <span class="pre">const</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">setInternalLinkage(bool</span> <span class="pre">HasInternalLinkage)</span></code></div>
</div>
<p>These methods manipulate the linkage characteristics of the <code class="docutils literal notranslate"><span class="pre">GlobalValue</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Module</span> <span class="pre">*getParent()</span></code></p>
<p>This returns the <a class="reference internal" href="#module">Module</a> that the
GlobalValue is currently embedded into.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="the-function-class">
<span id="c-function"></span><h3><a class="toc-backref" href="#id143">The <code class="docutils literal notranslate"><span class="pre">Function</span></code> class</a><a class="headerlink" href="#the-function-class" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;llvm/IR/Function.h&quot;</span></code></p>
<p>header source: <a class="reference external" href="http://llvm.org/doxygen/Function_8h_source.html">Function.h</a></p>
<p>doxygen info: <a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Function.html">Function Class</a></p>
<p>Superclasses: <a class="reference internal" href="#globalvalue">GlobalValue</a>, <a class="reference internal" href="#constant">Constant</a>, <a class="reference internal" href="#user">User</a>, <a class="reference internal" href="#value">Value</a></p>
<p>The <code class="docutils literal notranslate"><span class="pre">Function</span></code> class represents a single procedure in LLVM.  It is actually
one of the more complex classes in the LLVM hierarchy because it must keep track
of a large amount of data.  The <code class="docutils literal notranslate"><span class="pre">Function</span></code> class keeps track of a list of
<a class="reference internal" href="#basicblock">BasicBlock</a>s, a list of formal <a class="reference internal" href="#argument">Argument</a>s, and a <a class="reference internal" href="#symboltable">SymbolTable</a>.</p>
<p>The list of <a class="reference internal" href="#basicblock">BasicBlock</a>s is the most commonly used part of <code class="docutils literal notranslate"><span class="pre">Function</span></code>
objects.  The list imposes an implicit ordering of the blocks in the function,
which indicate how the code will be laid out by the backend.  Additionally, the
first <a class="reference internal" href="#basicblock">BasicBlock</a> is the implicit entry node for the <code class="docutils literal notranslate"><span class="pre">Function</span></code>.  It is not
legal in LLVM to explicitly branch to this initial block.  There are no implicit
exit nodes, and in fact there may be multiple exit nodes from a single
<code class="docutils literal notranslate"><span class="pre">Function</span></code>.  If the <a class="reference internal" href="#basicblock">BasicBlock</a> list is empty, this indicates that the
<code class="docutils literal notranslate"><span class="pre">Function</span></code> is actually a function declaration: the actual body of the function
hasn’t been linked in yet.</p>
<p>In addition to a list of <a class="reference internal" href="#basicblock">BasicBlock</a>s, the <code class="docutils literal notranslate"><span class="pre">Function</span></code> class also keeps track
of the list of formal <a class="reference internal" href="#argument">Argument</a>s that the function receives.  This container
manages the lifetime of the <a class="reference internal" href="#argument">Argument</a> nodes, just like the <a class="reference internal" href="#basicblock">BasicBlock</a> list does
for the <a class="reference internal" href="#basicblock">BasicBlock</a>s.</p>
<p>The <a class="reference internal" href="#symboltable">SymbolTable</a> is a very rarely used LLVM feature that is only used when you
have to look up a value by name.  Aside from that, the <a class="reference internal" href="#symboltable">SymbolTable</a> is used
internally to make sure that there are not conflicts between the names of
<a class="reference internal" href="#instruction">Instruction</a>s, <a class="reference internal" href="#basicblock">BasicBlock</a>s, or <a class="reference internal" href="#argument">Argument</a>s in the function body.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">Function</span></code> is a <a class="reference internal" href="#globalvalue">GlobalValue</a> and therefore also a <a class="reference internal" href="#constant">Constant</a>.  The
value of the function is its address (after linking) which is guaranteed to be
constant.</p>
<div class="section" id="important-public-members-of-the-function">
<span id="m-function"></span><h4><a class="toc-backref" href="#id144">Important Public Members of the <code class="docutils literal notranslate"><span class="pre">Function</span></code></a><a class="headerlink" href="#important-public-members-of-the-function" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Function(const</span> <span class="pre">FunctionType</span> <span class="pre">*Ty,</span> <span class="pre">LinkageTypes</span> <span class="pre">Linkage,</span>
<span class="pre">const</span> <span class="pre">std::string</span> <span class="pre">&amp;N</span> <span class="pre">=</span> <span class="pre">&quot;&quot;,</span> <span class="pre">Module*</span> <span class="pre">Parent</span> <span class="pre">=</span> <span class="pre">0)</span></code></p>
<p>Constructor used when you need to create new <code class="docutils literal notranslate"><span class="pre">Function</span></code>s to add the
program.  The constructor must specify the type of the function to create and
what type of linkage the function should have.  The <a class="reference internal" href="#functiontype">FunctionType</a> argument
specifies the formal arguments and return value for the function.  The same
<a class="reference internal" href="#functiontype">FunctionType</a> value can be used to create multiple functions.  The <code class="docutils literal notranslate"><span class="pre">Parent</span></code>
argument specifies the Module in which the function is defined.  If this
argument is provided, the function will automatically be inserted into that
module’s list of functions.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">isDeclaration()</span></code></p>
<p>Return whether or not the <code class="docutils literal notranslate"><span class="pre">Function</span></code> has a body defined.  If the function is
“external”, it does not have a body, and thus must be resolved by linking with
a function defined in a different translation unit.</p>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">Function::iterator</span></code> - Typedef for basic block list iterator</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">Function::const_iterator</span></code> - Typedef for const_iterator.</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">begin()</span></code>, <code class="docutils literal notranslate"><span class="pre">end()</span></code>, <code class="docutils literal notranslate"><span class="pre">size()</span></code>, <code class="docutils literal notranslate"><span class="pre">empty()</span></code></div>
</div>
<p>These are forwarding methods that make it easy to access the contents of a
<code class="docutils literal notranslate"><span class="pre">Function</span></code> object’s <a class="reference internal" href="#basicblock">BasicBlock</a> list.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Function::BasicBlockListType</span> <span class="pre">&amp;getBasicBlockList()</span></code></p>
<p>Returns the list of <a class="reference internal" href="#basicblock">BasicBlock</a>s.  This is necessary to use when you need to
update the list or perform a complex action that doesn’t have a forwarding
method.</p>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">Function::arg_iterator</span></code> - Typedef for the argument list iterator</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">Function::const_arg_iterator</span></code> - Typedef for const_iterator.</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">arg_begin()</span></code>, <code class="docutils literal notranslate"><span class="pre">arg_end()</span></code>, <code class="docutils literal notranslate"><span class="pre">arg_size()</span></code>, <code class="docutils literal notranslate"><span class="pre">arg_empty()</span></code></div>
</div>
<p>These are forwarding methods that make it easy to access the contents of a
<code class="docutils literal notranslate"><span class="pre">Function</span></code> object’s <a class="reference internal" href="#argument">Argument</a> list.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Function::ArgumentListType</span> <span class="pre">&amp;getArgumentList()</span></code></p>
<p>Returns the list of <a class="reference internal" href="#argument">Argument</a>.  This is necessary to use when you need to
update the list or perform a complex action that doesn’t have a forwarding
method.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">BasicBlock</span> <span class="pre">&amp;getEntryBlock()</span></code></p>
<p>Returns the entry <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code> for the function.  Because the entry block
for the function is always the first block, this returns the first block of
the <code class="docutils literal notranslate"><span class="pre">Function</span></code>.</p>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">*getReturnType()</span></code></div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">FunctionType</span> <span class="pre">*getFunctionType()</span></code></div>
</div>
<p>This traverses the <a class="reference internal" href="#type">Type</a> of the <code class="docutils literal notranslate"><span class="pre">Function</span></code> and returns the return type of
the function, or the <a class="reference internal" href="#functiontype">FunctionType</a> of the actual function.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">SymbolTable</span> <span class="pre">*getSymbolTable()</span></code></p>
<p>Return a pointer to the <a class="reference internal" href="#symboltable">SymbolTable</a> for this <code class="docutils literal notranslate"><span class="pre">Function</span></code>.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="the-globalvariable-class">
<span id="globalvariable"></span><h3><a class="toc-backref" href="#id145">The <code class="docutils literal notranslate"><span class="pre">GlobalVariable</span></code> class</a><a class="headerlink" href="#the-globalvariable-class" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;llvm/IR/GlobalVariable.h&quot;</span></code></p>
<p>header source: <a class="reference external" href="http://llvm.org/doxygen/GlobalVariable_8h_source.html">GlobalVariable.h</a></p>
<p>doxygen info: <a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1GlobalVariable.html">GlobalVariable Class</a></p>
<p>Superclasses: <a class="reference internal" href="#globalvalue">GlobalValue</a>, <a class="reference internal" href="#constant">Constant</a>, <a class="reference internal" href="#user">User</a>, <a class="reference internal" href="#value">Value</a></p>
<p>Global variables are represented with the (surprise surprise) <code class="docutils literal notranslate"><span class="pre">GlobalVariable</span></code>
class.  Like functions, <code class="docutils literal notranslate"><span class="pre">GlobalVariable</span></code>s are also subclasses of
<a class="reference internal" href="#globalvalue">GlobalValue</a>, and as such are always referenced by their address (global values
must live in memory, so their “name” refers to their constant address).  See
<a class="reference internal" href="#globalvalue">GlobalValue</a> for more on this.  Global variables may have an initial value
(which must be a <a class="reference internal" href="#constant">Constant</a>), and if they have an initializer, they may be marked
as “constant” themselves (indicating that their contents never change at
runtime).</p>
<div class="section" id="important-public-members-of-the-globalvariable-class">
<span id="m-globalvariable"></span><h4><a class="toc-backref" href="#id146">Important Public Members of the <code class="docutils literal notranslate"><span class="pre">GlobalVariable</span></code> class</a><a class="headerlink" href="#important-public-members-of-the-globalvariable-class" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">GlobalVariable(const</span> <span class="pre">Type</span> <span class="pre">*Ty,</span> <span class="pre">bool</span> <span class="pre">isConstant,</span> <span class="pre">LinkageTypes</span> <span class="pre">&amp;Linkage,</span>
<span class="pre">Constant</span> <span class="pre">*Initializer</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">const</span> <span class="pre">std::string</span> <span class="pre">&amp;Name</span> <span class="pre">=</span> <span class="pre">&quot;&quot;,</span> <span class="pre">Module*</span> <span class="pre">Parent</span> <span class="pre">=</span> <span class="pre">0)</span></code></p>
<p>Create a new global variable of the specified type.  If <code class="docutils literal notranslate"><span class="pre">isConstant</span></code> is true
then the global variable will be marked as unchanging for the program.  The
Linkage parameter specifies the type of linkage (internal, external, weak,
linkonce, appending) for the variable.  If the linkage is InternalLinkage,
WeakAnyLinkage, WeakODRLinkage, LinkOnceAnyLinkage or LinkOnceODRLinkage, then
the resultant global variable will have internal linkage.  AppendingLinkage
concatenates together all instances (in different translation units) of the
variable into a single variable but is only applicable to arrays.  See the
<a class="reference external" href="LangRef.html#modulestructure">LLVM Language Reference</a> for further details
on linkage types.  Optionally an initializer, a name, and the module to put
the variable into may be specified for the global variable as well.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">isConstant()</span> <span class="pre">const</span></code></p>
<p>Returns true if this is a global variable that is known not to be modified at
runtime.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">hasInitializer()</span></code></p>
<p>Returns true if this <code class="docutils literal notranslate"><span class="pre">GlobalVariable</span></code> has an intializer.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Constant</span> <span class="pre">*getInitializer()</span></code></p>
<p>Returns the initial value for a <code class="docutils literal notranslate"><span class="pre">GlobalVariable</span></code>.  It is not legal to call
this method if there is no initializer.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="the-basicblock-class">
<span id="basicblock"></span><h3><a class="toc-backref" href="#id147">The <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code> class</a><a class="headerlink" href="#the-basicblock-class" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;llvm/IR/BasicBlock.h&quot;</span></code></p>
<p>header source: <a class="reference external" href="http://llvm.org/doxygen/BasicBlock_8h_source.html">BasicBlock.h</a></p>
<p>doxygen info: <a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1BasicBlock.html">BasicBlock Class</a></p>
<p>Superclass: <a class="reference internal" href="#value">Value</a></p>
<p>This class represents a single entry single exit section of the code, commonly
known as a basic block by the compiler community.  The <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code> class
maintains a list of <a class="reference internal" href="#instruction">Instruction</a>s, which form the body of the block.  Matching
the language definition, the last element of this list of instructions is always
a terminator instruction.</p>
<p>In addition to tracking the list of instructions that make up the block, the
<code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code> class also keeps track of the <a class="reference internal" href="#c-function"><span class="std std-ref">Function</span></a> that
it is embedded into.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code>s themselves are <a class="reference internal" href="#value">Value</a>s, because they are
referenced by instructions like branches and can go in the switch tables.
<code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code>s have type <code class="docutils literal notranslate"><span class="pre">label</span></code>.</p>
<div class="section" id="important-public-members-of-the-basicblock-class">
<span id="m-basicblock"></span><h4><a class="toc-backref" href="#id148">Important Public Members of the <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code> class</a><a class="headerlink" href="#important-public-members-of-the-basicblock-class" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">BasicBlock(const</span> <span class="pre">std::string</span> <span class="pre">&amp;Name</span> <span class="pre">=</span> <span class="pre">&quot;&quot;,</span> <span class="pre">Function</span> <span class="pre">*Parent</span> <span class="pre">=</span> <span class="pre">0)</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code> constructor is used to create new basic blocks for
insertion into a function.  The constructor optionally takes a name for the
new block, and a <a class="reference internal" href="#c-function"><span class="std std-ref">Function</span></a> to insert it into.  If the
<code class="docutils literal notranslate"><span class="pre">Parent</span></code> parameter is specified, the new <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code> is automatically
inserted at the end of the specified <a class="reference internal" href="#c-function"><span class="std std-ref">Function</span></a>, if not
specified, the BasicBlock must be manually inserted into the <a class="reference internal" href="#c-function"><span class="std std-ref">Function</span></a>.</p>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">BasicBlock::iterator</span></code> - Typedef for instruction list iterator</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">BasicBlock::const_iterator</span></code> - Typedef for const_iterator.</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">begin()</span></code>, <code class="docutils literal notranslate"><span class="pre">end()</span></code>, <code class="docutils literal notranslate"><span class="pre">front()</span></code>, <code class="docutils literal notranslate"><span class="pre">back()</span></code>,
<code class="docutils literal notranslate"><span class="pre">size()</span></code>, <code class="docutils literal notranslate"><span class="pre">empty()</span></code>
STL-style functions for accessing the instruction list.</div>
</div>
<p>These methods and typedefs are forwarding functions that have the same
semantics as the standard library methods of the same names.  These methods
expose the underlying instruction list of a basic block in a way that is easy
to manipulate.  To get the full complement of container operations (including
operations to update the list), you must use the <code class="docutils literal notranslate"><span class="pre">getInstList()</span></code> method.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">BasicBlock::InstListType</span> <span class="pre">&amp;getInstList()</span></code></p>
<p>This method is used to get access to the underlying container that actually
holds the Instructions.  This method must be used when there isn’t a
forwarding function in the <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code> class for the operation that you
would like to perform.  Because there are no forwarding functions for
“updating” operations, you need to use this if you want to update the contents
of a <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Function</span> <span class="pre">*getParent()</span></code></p>
<p>Returns a pointer to <a class="reference internal" href="#c-function"><span class="std std-ref">Function</span></a> the block is embedded into,
or a null pointer if it is homeless.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Instruction</span> <span class="pre">*getTerminator()</span></code></p>
<p>Returns a pointer to the terminator instruction that appears at the end of the
<code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code>.  If there is no terminator instruction, or if the last
instruction in the block is not a terminator, then a null pointer is returned.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="the-argument-class">
<span id="argument"></span><h3><a class="toc-backref" href="#id149">The <code class="docutils literal notranslate"><span class="pre">Argument</span></code> class</a><a class="headerlink" href="#the-argument-class" title="Permalink to this headline">¶</a></h3>
<p>This subclass of Value defines the interface for incoming formal arguments to a
function.  A Function maintains a list of its formal arguments.  An argument has
a pointer to the parent Function.</p>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="Extensions.html" title="LLVM Extensions"
             >next</a> |</li>
        <li class="right" >
          <a href="HowToSetUpLLVMStyleRTTI.html" title="How to set up LLVM-style RTTI for your class hierarchy"
             >previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2003-2020, LLVM Project.
      Last updated on 2020-01-13.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.3.1.
    </div>
  </body>
</html>