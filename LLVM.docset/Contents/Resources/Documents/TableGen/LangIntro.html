

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>TableGen Language Introduction &#8212; LLVM 9 documentation</title>
    <link rel="stylesheet" href="../_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="TableGen Deficiencies" href="Deficiencies.html" />
    <link rel="prev" title="TableGen Language Reference" href="LangRef.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="../index.html">
    <img src="../_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="Deficiencies.html" title="TableGen Deficiencies"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="LangRef.html" title="TableGen Language Reference"
             accesskey="P">previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="../index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">TableGen</a> &#187;</li> 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="tablegen-language-introduction">
<h1>TableGen Language Introduction<a class="headerlink" href="#tablegen-language-introduction" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id4">Introduction</a></p></li>
<li><p><a class="reference internal" href="#tablegen-syntax" id="id5">TableGen syntax</a></p>
<ul>
<li><p><a class="reference internal" href="#tablegen-primitives" id="id6">TableGen primitives</a></p>
<ul>
<li><p><a class="reference internal" href="#tablegen-comments" id="id7">TableGen comments</a></p></li>
<li><p><a class="reference internal" href="#the-tablegen-type-system" id="id8">The TableGen type system</a></p></li>
<li><p><a class="reference internal" href="#tablegen-values-and-expressions" id="id9">TableGen values and expressions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#classes-and-definitions" id="id10">Classes and definitions</a></p>
<ul>
<li><p><a class="reference internal" href="#value-definitions" id="id11">Value definitions</a></p></li>
<li><p><a class="reference internal" href="#let-expressions-within-a-record" id="id12">‘let’ expressions</a></p></li>
<li><p><a class="reference internal" href="#class-template-arguments" id="id13">Class template arguments</a></p></li>
<li><p><a class="reference internal" href="#multiclass-definitions-and-instances" id="id14">Multiclass definitions and instances</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#file-scope-entities" id="id15">File scope entities</a></p>
<ul>
<li><p><a class="reference internal" href="#file-inclusion" id="id16">File inclusion</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id17">‘let’ expressions</a></p></li>
<li><p><a class="reference internal" href="#looping" id="id18">Looping</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#code-generator-backend-info" id="id19">Code Generator backend info</a></p></li>
</ul>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This document is extremely rough. If you find something lacking, please
fix it, file a documentation bug, or ask about it on llvm-dev.</p>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id4">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document is not meant to be a normative spec about the TableGen language
in and of itself (i.e. how to understand a given construct in terms of how
it affects the final set of records represented by the TableGen file). For
the formal language specification, see <a class="reference internal" href="LangRef.html"><span class="doc">TableGen Language Reference</span></a>.</p>
</div>
<div class="section" id="tablegen-syntax">
<h2><a class="toc-backref" href="#id5">TableGen syntax</a><a class="headerlink" href="#tablegen-syntax" title="Permalink to this headline">¶</a></h2>
<p>TableGen doesn’t care about the meaning of data (that is up to the backend to
define), but it does care about syntax, and it enforces a simple type system.
This section describes the syntax and the constructs allowed in a TableGen file.</p>
<div class="section" id="tablegen-primitives">
<h3><a class="toc-backref" href="#id6">TableGen primitives</a><a class="headerlink" href="#tablegen-primitives" title="Permalink to this headline">¶</a></h3>
<div class="section" id="tablegen-comments">
<h4><a class="toc-backref" href="#id7">TableGen comments</a><a class="headerlink" href="#tablegen-comments" title="Permalink to this headline">¶</a></h4>
<p>TableGen supports C++ style “<code class="docutils literal notranslate"><span class="pre">//</span></code>” comments, which run to the end of the
line, and it also supports <strong>nestable</strong> “<code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">*/</span></code>” comments.</p>
</div>
<div class="section" id="the-tablegen-type-system">
<span id="tablegen-type"></span><h4><a class="toc-backref" href="#id8">The TableGen type system</a><a class="headerlink" href="#the-tablegen-type-system" title="Permalink to this headline">¶</a></h4>
<p>TableGen files are strongly typed, in a simple (but complete) type-system.
These types are used to perform automatic conversions, check for errors, and to
help interface designers constrain the input that they allow.  Every <a class="reference internal" href="#value-definition">value
definition</a> is required to have an associated type.</p>
<p>TableGen supports a mixture of very low-level types (such as <code class="docutils literal notranslate"><span class="pre">bit</span></code>) and very
high-level types (such as <code class="docutils literal notranslate"><span class="pre">dag</span></code>).  This flexibility is what allows it to
describe a wide range of information conveniently and compactly.  The TableGen
types are:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bit</span></code></dt><dd><p>A ‘bit’ is a boolean value that can hold either 0 or 1.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span></code></dt><dd><p>The ‘int’ type represents a simple 32-bit integer value, such as 5.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">string</span></code></dt><dd><p>The ‘string’ type represents an ordered sequence of characters of arbitrary
length.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code</span></code></dt><dd><p>The <cite>code</cite> type represents a code fragment, which can be single/multi-line
string literal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bits&lt;n&gt;</span></code></dt><dd><p>A ‘bits’ type is an arbitrary, but fixed, size integer that is broken up
into individual bits.  This type is useful because it can handle some bits
being defined while others are undefined.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list&lt;ty&gt;</span></code></dt><dd><p>This type represents a list whose elements are some other type.  The
contained type is arbitrary: it can even be another list type.</p>
</dd>
<dt>Class type</dt><dd><p>Specifying a class name in a type context means that the defined value must
be a subclass of the specified class.  This is useful in conjunction with
the <code class="docutils literal notranslate"><span class="pre">list</span></code> type, for example, to constrain the elements of the list to a
common base class (e.g., a <code class="docutils literal notranslate"><span class="pre">list&lt;Register&gt;</span></code> can only contain definitions
derived from the “<code class="docutils literal notranslate"><span class="pre">Register</span></code>” class).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dag</span></code></dt><dd><p>This type represents a nestable directed graph of elements.</p>
</dd>
</dl>
<p>To date, these types have been sufficient for describing things that TableGen
has been used for, but it is straight-forward to extend this list if needed.</p>
</div>
<div class="section" id="tablegen-values-and-expressions">
<span id="tablegen-expressions"></span><h4><a class="toc-backref" href="#id9">TableGen values and expressions</a><a class="headerlink" href="#tablegen-values-and-expressions" title="Permalink to this headline">¶</a></h4>
<p>TableGen allows for a pretty reasonable number of different expression forms
when building up values.  These forms allow the TableGen file to be written in a
natural syntax and flavor for the application.  The current expression forms
supported include:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">?</span></code></dt><dd><p>uninitialized field</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">0b1001011</span></code></dt><dd><p>binary integer value.
Note that this is sized by the number of bits given and will not be
silently extended/truncated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">7</span></code></dt><dd><p>decimal integer value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">0x7F</span></code></dt><dd><p>hexadecimal integer value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&quot;foo&quot;</span></code></dt><dd><p>a single-line string value, can be assigned to <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">code</span></code> variable.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[{</span> <span class="pre">...</span> <span class="pre">}]</span></code></dt><dd><p>usually called a “code fragment”, but is just a multiline string literal</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">X,</span> <span class="pre">Y,</span> <span class="pre">Z</span> <span class="pre">]&lt;type&gt;</span></code></dt><dd><p>list value.  &lt;type&gt; is the type of the list element and is usually optional.
In rare cases, TableGen is unable to deduce the element type in which case
the user must specify it explicitly.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">0b10</span> <span class="pre">}</span></code></dt><dd><p>initializer for a “bits&lt;4&gt;” value.
1-bit from “a”, 1-bit from “b”, 2-bits from 0b10.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">value</span></code></dt><dd><p>value reference</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">value{17}</span></code></dt><dd><p>access to one bit of a value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">value{15-17}</span></code></dt><dd><p>access to an ordered sequence of bits of a value, in particular <code class="docutils literal notranslate"><span class="pre">value{15-17}</span></code>
produces an order that is the reverse of <code class="docutils literal notranslate"><span class="pre">value{17-15}</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEF</span></code></dt><dd><p>reference to a record definition</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CLASS&lt;val</span> <span class="pre">list&gt;</span></code></dt><dd><p>reference to a new anonymous definition of CLASS with the specified template
arguments.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X.Y</span></code></dt><dd><p>reference to the subfield of a value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list[4-7,17,2-3]</span></code></dt><dd><p>A slice of the ‘list’ list, including elements 4,5,6,7,17,2, and 3 from it.
Elements may be included multiple times.</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">foreach</span> <span class="pre">&lt;var&gt;</span> <span class="pre">=</span> <span class="pre">[</span> <span class="pre">&lt;list&gt;</span> <span class="pre">]</span> <span class="pre">in</span> <span class="pre">{</span> <span class="pre">&lt;body&gt;</span> <span class="pre">}</span></code></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">foreach</span> <span class="pre">&lt;var&gt;</span> <span class="pre">=</span> <span class="pre">[</span> <span class="pre">&lt;list&gt;</span> <span class="pre">]</span> <span class="pre">in</span> <span class="pre">&lt;def&gt;</span></code></dt><dd><p>Replicate &lt;body&gt; or &lt;def&gt;, replacing instances of &lt;var&gt; with each value
in &lt;list&gt;.  &lt;var&gt; is scoped at the level of the <code class="docutils literal notranslate"><span class="pre">foreach</span></code> loop and must
not conflict with any other object introduced in &lt;body&gt; or &lt;def&gt;.  Only
<code class="docutils literal notranslate"><span class="pre">def</span></code>s and <code class="docutils literal notranslate"><span class="pre">defm</span></code>s are expanded within &lt;body&gt;.</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">foreach</span> <span class="pre">&lt;var&gt;</span> <span class="pre">=</span> <span class="pre">0-15</span> <span class="pre">in</span> <span class="pre">...</span></code></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">foreach</span> <span class="pre">&lt;var&gt;</span> <span class="pre">=</span> <span class="pre">{0-15,32-47}</span> <span class="pre">in</span> <span class="pre">...</span></code></dt><dd><p>Loop over ranges of integers. The braces are required for multiple ranges.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(DEF</span> <span class="pre">a,</span> <span class="pre">b)</span></code></dt><dd><p>a dag value.  The first element is required to be a record definition, the
remaining elements in the list may be arbitrary other values, including
nested <code class="docutils literal notranslate"><span class="pre">`dag</span></code>’ values.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!con(a,</span> <span class="pre">b,</span> <span class="pre">...)</span></code></dt><dd><p>Concatenate two or more DAG nodes. Their operations must equal.</p>
<p>Example: !con((op a1:$name1, a2:$name2), (op b1:$name3)) results in
the DAG node (op a1:$name1, a2:$name2, b1:$name3).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!dag(op,</span> <span class="pre">children,</span> <span class="pre">names)</span></code></dt><dd><p>Generate a DAG node programmatically. ‘children’ and ‘names’ must be lists
of equal length or unset (‘?’). ‘names’ must be a ‘list&lt;string&gt;’.</p>
<p>Due to limitations of the type system, ‘children’ must be a list of items
of a common type. In practice, this means that they should either have the
same type or be records with a common superclass. Mixing dag and non-dag
items is not possible. However, ‘?’ can be used.</p>
<p>Example: !dag(op, [a1, a2, ?], [“name1”, “name2”, “name3”]) results in
(op a1:$name1, a2:$name2, ?:$name3).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!listconcat(a,</span> <span class="pre">b,</span> <span class="pre">...)</span></code></dt><dd><p>A list value that is the result of concatenating the ‘a’ and ‘b’ lists.
The lists must have the same element type.
More than two arguments are accepted with the result being the concatenation
of all the lists given.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!listsplat(a,</span> <span class="pre">size)</span></code></dt><dd><p>A list value that contains the value <code class="docutils literal notranslate"><span class="pre">a</span></code> <code class="docutils literal notranslate"><span class="pre">size</span></code> times.
Example: <code class="docutils literal notranslate"><span class="pre">!listsplat(0,</span> <span class="pre">2)</span></code> results in <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">0]</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!strconcat(a,</span> <span class="pre">b,</span> <span class="pre">...)</span></code></dt><dd><p>A string value that is the result of concatenating the ‘a’ and ‘b’ strings.
More than two arguments are accepted with the result being the concatenation
of all the strings given.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">str1#str2</span></code></dt><dd><p>“#” (paste) is a shorthand for !strconcat.  It may concatenate things that
are not quoted strings, in which case an implicit !cast&lt;string&gt; is done on
the operand of the paste.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!cast&lt;type&gt;(a)</span></code></dt><dd><p>If ‘a’ is a string, a record of type <em>type</em> obtained by looking up the
string ‘a’ in the list of all records defined by the time that all template
arguments in ‘a’ are fully resolved.</p>
<p>For example, if !cast&lt;type&gt;(a) appears in a multiclass definition, or in a
class instantiated inside of a multiclass definition, and ‘a’ does not
reference any template arguments of the multiclass, then a record of name
‘a’ must be instantiated earlier in the source file. If ‘a’ does reference
a template argument, then the lookup is delayed until defm statements
instantiating the multiclass (or later, if the defm occurs in another
multiclass and template arguments of the inner multiclass that are
referenced by ‘a’ are substituted by values that themselves contain
references to template arguments of the outer multiclass).</p>
<p>If the type of ‘a’ does not match <em>type</em>, TableGen aborts with an error.</p>
<p>Otherwise, perform a normal type cast e.g. between an int and a bit, or
between record types. This allows casting a record to a subclass, though if
the types do not match, constant folding will be inhibited. !cast&lt;string&gt;
is a special case in that the argument can be an int or a record. In the
latter case, the record’s name is returned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!isa&lt;type&gt;(a)</span></code></dt><dd><p>Returns an integer: 1 if ‘a’ is dynamically of the given type, 0 otherwise.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!subst(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code></dt><dd><p>If ‘a’ and ‘b’ are of string type or are symbol references, substitute ‘b’
for ‘a’ in ‘c.’  This operation is analogous to $(subst) in GNU make.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!foreach(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code></dt><dd><p>For each member of dag or list ‘b’ apply operator ‘c’. ‘a’ is the name
of a variable that will be substituted by members of ‘b’ in ‘c’.
This operation is analogous to $(foreach) in GNU make.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!foldl(start,</span> <span class="pre">lst,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">expr)</span></code></dt><dd><p>Perform a left-fold over ‘lst’ with the given starting value. ‘a’ and ‘b’
are variable names which will be substituted in ‘expr’. If you think of
expr as a function f(a,b), the fold will compute
‘f(…f(f(start, lst[0]), lst[1]), …), lst[n-1])’ for a list of length n.
As usual, ‘a’ will be of the type of ‘start’, and ‘b’ will be of the type
of elements of ‘lst’. These types need not be the same, but ‘expr’ must be
of the same type as ‘start’.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!head(a)</span></code></dt><dd><p>The first element of list ‘a.’</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!tail(a)</span></code></dt><dd><p>The 2nd-N elements of list ‘a.’</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!empty(a)</span></code></dt><dd><p>An integer {0,1} indicating whether list ‘a’ is empty.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!size(a)</span></code></dt><dd><p>An integer indicating the number of elements in list ‘a’.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!if(a,b,c)</span></code></dt><dd><p>‘b’ if the result of ‘int’ or ‘bit’ operator ‘a’ is nonzero, ‘c’ otherwise.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!cond(condition_1</span> <span class="pre">:</span> <span class="pre">val1,</span> <span class="pre">condition_2</span> <span class="pre">:</span> <span class="pre">val2,</span> <span class="pre">...,</span> <span class="pre">condition_n</span> <span class="pre">:</span> <span class="pre">valn)</span></code></dt><dd><p>Instead of embedding !if inside !if which can get cumbersome,
one can use !cond. !cond returns ‘val1’ if the result of ‘int’ or ‘bit’
operator ‘condition1’ is nonzero. Otherwise, it checks ‘condition2’.
If ‘condition2’ is nonzero, returns ‘val2’, and so on.
If all conditions are zero, it reports an error.</p>
<dl class="simple">
<dt>For example, to convert an integer ‘x’ into a string:</dt><dd><p>!cond(!lt(x,0) : “negative”, !eq(x,0) : “zero”, 1 : “positive”)</p>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!eq(a,b)</span></code></dt><dd><p>‘bit 1’ if string a is equal to string b, 0 otherwise.  This only operates
on string, int and bit objects.  Use !cast&lt;string&gt; to compare other types of
objects.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!ne(a,b)</span></code></dt><dd><p>The negation of <code class="docutils literal notranslate"><span class="pre">!eq(a,b)</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!le(a,b),</span> <span class="pre">!lt(a,b),</span> <span class="pre">!ge(a,b),</span> <span class="pre">!gt(a,b)</span></code></dt><dd><p>(Signed) comparison of integer values that returns bit 1 or 0 depending on
the result of the comparison.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!shl(a,b)</span></code> <code class="docutils literal notranslate"><span class="pre">!srl(a,b)</span></code> <code class="docutils literal notranslate"><span class="pre">!sra(a,b)</span></code></dt><dd><p>The usual shift operators. Operations are on 64-bit integers, the result
is undefined for shift counts outside [0, 63].</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!add(a,b,...)</span></code> <code class="docutils literal notranslate"><span class="pre">!mul(a,b,...)</span></code> <code class="docutils literal notranslate"><span class="pre">!and(a,b,...)</span></code> <code class="docutils literal notranslate"><span class="pre">!or(a,b,...)</span></code></dt><dd><p>The usual arithmetic and binary operators.</p>
</dd>
</dl>
<p>Note that all of the values have rules specifying how they convert to values
for different types.  These rules allow you to assign a value like “<code class="docutils literal notranslate"><span class="pre">7</span></code>”
to a “<code class="docutils literal notranslate"><span class="pre">bits&lt;4&gt;</span></code>” value, for example.</p>
</div>
</div>
<div class="section" id="classes-and-definitions">
<h3><a class="toc-backref" href="#id10">Classes and definitions</a><a class="headerlink" href="#classes-and-definitions" title="Permalink to this headline">¶</a></h3>
<p>As mentioned in the <a class="reference internal" href="index.html"><span class="doc">introduction</span></a>, classes and definitions (collectively known as
‘records’) in TableGen are the main high-level unit of information that TableGen
collects.  Records are defined with a <code class="docutils literal notranslate"><span class="pre">def</span></code> or <code class="docutils literal notranslate"><span class="pre">class</span></code> keyword, the record
name, and an optional list of “<a class="reference internal" href="#template-arguments">template arguments</a>”.  If the record has
superclasses, they are specified as a comma separated list that starts with a
colon character (“<code class="docutils literal notranslate"><span class="pre">:</span></code>”).  If <a class="reference internal" href="#value-definitions">value definitions</a> or <a class="reference internal" href="#let-expressions">let expressions</a> are
needed for the class, they are enclosed in curly braces (“<code class="docutils literal notranslate"><span class="pre">{}</span></code>”); otherwise,
the record ends with a semicolon.</p>
<p>Here is a simple TableGen file:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>class C { bit V = 1; }
def X : C;
def Y : C {
  string Greeting = &quot;hello&quot;;
}
</pre></div>
</div>
<p>This example defines two definitions, <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code>, both of which derive from
the <code class="docutils literal notranslate"><span class="pre">C</span></code> class.  Because of this, they both get the <code class="docutils literal notranslate"><span class="pre">V</span></code> bit value.  The <code class="docutils literal notranslate"><span class="pre">Y</span></code>
definition also gets the Greeting member as well.</p>
<p>In general, classes are useful for collecting together the commonality between a
group of records and isolating it in a single place.  Also, classes permit the
specification of default values for their subclasses, allowing the subclasses to
override them as they wish.</p>
<div class="section" id="value-definitions">
<span id="value-definition"></span><span id="id1"></span><h4><a class="toc-backref" href="#id11">Value definitions</a><a class="headerlink" href="#value-definitions" title="Permalink to this headline">¶</a></h4>
<p>Value definitions define named entries in records.  A value must be defined
before it can be referred to as the operand for another value definition or
before the value is reset with a <a class="reference internal" href="#let-expression">let expression</a>.  A value is defined by
specifying a <a class="reference internal" href="#tablegen-type">TableGen type</a> and a name.  If an initial value is available, it
may be specified after the type with an equal sign.  Value definitions require
terminating semicolons.</p>
</div>
<div class="section" id="let-expressions-within-a-record">
<span id="let-expressions"></span><span id="let-expression"></span><span id="id2"></span><h4><a class="toc-backref" href="#id12">‘let’ expressions</a><a class="headerlink" href="#let-expressions-within-a-record" title="Permalink to this headline">¶</a></h4>
<p>A record-level let expression is used to change the value of a value definition
in a record.  This is primarily useful when a superclass defines a value that a
derived class or definition wants to override.  Let expressions consist of the
‘<code class="docutils literal notranslate"><span class="pre">let</span></code>’ keyword followed by a value name, an equal sign (“<code class="docutils literal notranslate"><span class="pre">=</span></code>”), and a new
value.  For example, a new class could be added to the example above, redefining
the <code class="docutils literal notranslate"><span class="pre">V</span></code> field for all of its subclasses:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>class D : C { let V = 0; }
def Z : D;
</pre></div>
</div>
<p>In this case, the <code class="docutils literal notranslate"><span class="pre">Z</span></code> definition will have a zero value for its <code class="docutils literal notranslate"><span class="pre">V</span></code> value,
despite the fact that it derives (indirectly) from the <code class="docutils literal notranslate"><span class="pre">C</span></code> class, because the
<code class="docutils literal notranslate"><span class="pre">D</span></code> class overrode its value.</p>
<p>References between variables in a record are substituted late, which gives
<code class="docutils literal notranslate"><span class="pre">let</span></code> expressions unusual power. Consider this admittedly silly example:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>class A&lt;int x&gt; {
  int Y = x;
  int Yplus1 = !add(Y, 1);
  int xplus1 = !add(x, 1);
}
def Z : A&lt;5&gt; {
  let Y = 10;
}
</pre></div>
</div>
<p>The value of <code class="docutils literal notranslate"><span class="pre">Z.xplus1</span></code> will be 6, but the value of <code class="docutils literal notranslate"><span class="pre">Z.Yplus1</span></code> is 11. Use
this power wisely.</p>
</div>
<div class="section" id="class-template-arguments">
<span id="template-arguments"></span><h4><a class="toc-backref" href="#id13">Class template arguments</a><a class="headerlink" href="#class-template-arguments" title="Permalink to this headline">¶</a></h4>
<p>TableGen permits the definition of parameterized classes as well as normal
concrete classes.  Parameterized TableGen classes specify a list of variable
bindings (which may optionally have defaults) that are bound when used.  Here is
a simple example:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>class FPFormat&lt;bits&lt;3&gt; val&gt; {
  bits&lt;3&gt; Value = val;
}
def NotFP      : FPFormat&lt;0&gt;;
def ZeroArgFP  : FPFormat&lt;1&gt;;
def OneArgFP   : FPFormat&lt;2&gt;;
def OneArgFPRW : FPFormat&lt;3&gt;;
def TwoArgFP   : FPFormat&lt;4&gt;;
def CompareFP  : FPFormat&lt;5&gt;;
def CondMovFP  : FPFormat&lt;6&gt;;
def SpecialFP  : FPFormat&lt;7&gt;;
</pre></div>
</div>
<p>In this case, template arguments are used as a space efficient way to specify a
list of “enumeration values”, each with a “<code class="docutils literal notranslate"><span class="pre">Value</span></code>” field set to the specified
integer.</p>
<p>The more esoteric forms of <a class="reference internal" href="#tablegen-expressions">TableGen expressions</a> are useful in conjunction
with template arguments.  As an example:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>class ModRefVal&lt;bits&lt;2&gt; val&gt; {
  bits&lt;2&gt; Value = val;
}

def None   : ModRefVal&lt;0&gt;;
def Mod    : ModRefVal&lt;1&gt;;
def Ref    : ModRefVal&lt;2&gt;;
def ModRef : ModRefVal&lt;3&gt;;

class Value&lt;ModRefVal MR&gt; {
  // Decode some information into a more convenient format, while providing
  // a nice interface to the user of the &quot;Value&quot; class.
  bit isMod = MR.Value{0};
  bit isRef = MR.Value{1};

  // other stuff...
}

// Example uses
def bork : Value&lt;Mod&gt;;
def zork : Value&lt;Ref&gt;;
def hork : Value&lt;ModRef&gt;;
</pre></div>
</div>
<p>This is obviously a contrived example, but it shows how template arguments can
be used to decouple the interface provided to the user of the class from the
actual internal data representation expected by the class.  In this case,
running <code class="docutils literal notranslate"><span class="pre">llvm-tblgen</span></code> on the example prints the following definitions:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def bork {      // Value
  bit isMod = 1;
  bit isRef = 0;
}
def hork {      // Value
  bit isMod = 1;
  bit isRef = 1;
}
def zork {      // Value
  bit isMod = 0;
  bit isRef = 1;
}
</pre></div>
</div>
<p>This shows that TableGen was able to dig into the argument and extract a piece
of information that was requested by the designer of the “Value” class.  For
more realistic examples, please see existing users of TableGen, such as the X86
backend.</p>
</div>
<div class="section" id="multiclass-definitions-and-instances">
<h4><a class="toc-backref" href="#id14">Multiclass definitions and instances</a><a class="headerlink" href="#multiclass-definitions-and-instances" title="Permalink to this headline">¶</a></h4>
<p>While classes with template arguments are a good way to factor commonality
between two instances of a definition, multiclasses allow a convenient notation
for defining multiple definitions at once (instances of implicitly constructed
classes).  For example, consider an 3-address instruction set whose instructions
come in two forms: “<code class="docutils literal notranslate"><span class="pre">reg</span> <span class="pre">=</span> <span class="pre">reg</span> <span class="pre">op</span> <span class="pre">reg</span></code>” and “<code class="docutils literal notranslate"><span class="pre">reg</span> <span class="pre">=</span> <span class="pre">reg</span> <span class="pre">op</span> <span class="pre">imm</span></code>”
(e.g. SPARC). In this case, you’d like to specify in one place that this
commonality exists, then in a separate place indicate what all the ops are.</p>
<p>Here is an example TableGen fragment that shows this idea:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def ops;
def GPR;
def Imm;
class inst&lt;int opc, string asmstr, dag operandlist&gt;;

multiclass ri_inst&lt;int opc, string asmstr&gt; {
  def _rr : inst&lt;opc, !strconcat(asmstr, &quot; $dst, $src1, $src2&quot;),
                 (ops GPR:$dst, GPR:$src1, GPR:$src2)&gt;;
  def _ri : inst&lt;opc, !strconcat(asmstr, &quot; $dst, $src1, $src2&quot;),
                 (ops GPR:$dst, GPR:$src1, Imm:$src2)&gt;;
}

// Instantiations of the ri_inst multiclass.
defm ADD : ri_inst&lt;0b111, &quot;add&quot;&gt;;
defm SUB : ri_inst&lt;0b101, &quot;sub&quot;&gt;;
defm MUL : ri_inst&lt;0b100, &quot;mul&quot;&gt;;
...
</pre></div>
</div>
<p>The name of the resultant definitions has the multidef fragment names appended
to them, so this defines <code class="docutils literal notranslate"><span class="pre">ADD_rr</span></code>, <code class="docutils literal notranslate"><span class="pre">ADD_ri</span></code>, <code class="docutils literal notranslate"><span class="pre">SUB_rr</span></code>, etc.  A defm may
inherit from multiple multiclasses, instantiating definitions from each
multiclass.  Using a multiclass this way is exactly equivalent to instantiating
the classes multiple times yourself, e.g. by writing:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def ops;
def GPR;
def Imm;
class inst&lt;int opc, string asmstr, dag operandlist&gt;;

class rrinst&lt;int opc, string asmstr&gt;
  : inst&lt;opc, !strconcat(asmstr, &quot; $dst, $src1, $src2&quot;),
         (ops GPR:$dst, GPR:$src1, GPR:$src2)&gt;;

class riinst&lt;int opc, string asmstr&gt;
  : inst&lt;opc, !strconcat(asmstr, &quot; $dst, $src1, $src2&quot;),
         (ops GPR:$dst, GPR:$src1, Imm:$src2)&gt;;

// Instantiations of the ri_inst multiclass.
def ADD_rr : rrinst&lt;0b111, &quot;add&quot;&gt;;
def ADD_ri : riinst&lt;0b111, &quot;add&quot;&gt;;
def SUB_rr : rrinst&lt;0b101, &quot;sub&quot;&gt;;
def SUB_ri : riinst&lt;0b101, &quot;sub&quot;&gt;;
def MUL_rr : rrinst&lt;0b100, &quot;mul&quot;&gt;;
def MUL_ri : riinst&lt;0b100, &quot;mul&quot;&gt;;
...
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">defm</span></code> can also be used inside a multiclass providing several levels of
multiclass instantiations.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>class Instruction&lt;bits&lt;4&gt; opc, string Name&gt; {
  bits&lt;4&gt; opcode = opc;
  string name = Name;
}

multiclass basic_r&lt;bits&lt;4&gt; opc&gt; {
  def rr : Instruction&lt;opc, &quot;rr&quot;&gt;;
  def rm : Instruction&lt;opc, &quot;rm&quot;&gt;;
}

multiclass basic_s&lt;bits&lt;4&gt; opc&gt; {
  defm SS : basic_r&lt;opc&gt;;
  defm SD : basic_r&lt;opc&gt;;
  def X : Instruction&lt;opc, &quot;x&quot;&gt;;
}

multiclass basic_p&lt;bits&lt;4&gt; opc&gt; {
  defm PS : basic_r&lt;opc&gt;;
  defm PD : basic_r&lt;opc&gt;;
  def Y : Instruction&lt;opc, &quot;y&quot;&gt;;
}

defm ADD : basic_s&lt;0xf&gt;, basic_p&lt;0xf&gt;;
...

// Results
def ADDPDrm { ...
def ADDPDrr { ...
def ADDPSrm { ...
def ADDPSrr { ...
def ADDSDrm { ...
def ADDSDrr { ...
def ADDY { ...
def ADDX { ...
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">defm</span></code> declarations can inherit from classes too, the rule to follow is that
the class list must start after the last multiclass, and there must be at least
one multiclass before them.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>class XD { bits&lt;4&gt; Prefix = 11; }
class XS { bits&lt;4&gt; Prefix = 12; }

class I&lt;bits&lt;4&gt; op&gt; {
  bits&lt;4&gt; opcode = op;
}

multiclass R {
  def rr : I&lt;4&gt;;
  def rm : I&lt;2&gt;;
}

multiclass Y {
  defm SS : R, XD;
  defm SD : R, XS;
}

defm Instr : Y;

// Results
def InstrSDrm {
  bits&lt;4&gt; opcode = { 0, 0, 1, 0 };
  bits&lt;4&gt; Prefix = { 1, 1, 0, 0 };
}
...
def InstrSSrr {
  bits&lt;4&gt; opcode = { 0, 1, 0, 0 };
  bits&lt;4&gt; Prefix = { 1, 0, 1, 1 };
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="file-scope-entities">
<h3><a class="toc-backref" href="#id15">File scope entities</a><a class="headerlink" href="#file-scope-entities" title="Permalink to this headline">¶</a></h3>
<div class="section" id="file-inclusion">
<h4><a class="toc-backref" href="#id16">File inclusion</a><a class="headerlink" href="#file-inclusion" title="Permalink to this headline">¶</a></h4>
<p>TableGen supports the ‘<code class="docutils literal notranslate"><span class="pre">include</span></code>’ token, which textually substitutes the
specified file in place of the include directive.  The filename should be
specified as a double quoted string immediately after the ‘<code class="docutils literal notranslate"><span class="pre">include</span></code>’ keyword.
Example:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>include &quot;foo.td&quot;
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4><a class="toc-backref" href="#id17">‘let’ expressions</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>“Let” expressions at file scope are similar to <a class="reference internal" href="#let-expressions-within-a-record">“let” expressions within a
record</a>, except they can specify a value binding for multiple records at a
time, and may be useful in certain other cases.  File-scope let expressions are
really just another way that TableGen allows the end-user to factor out
commonality from the records.</p>
<p>File-scope “let” expressions take a comma-separated list of bindings to apply,
and one or more records to bind the values in.  Here are some examples:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>let isTerminator = 1, isReturn = 1, isBarrier = 1, hasCtrlDep = 1 in
  def RET : I&lt;0xC3, RawFrm, (outs), (ins), &quot;ret&quot;, [(X86retflag 0)]&gt;;

let isCall = 1 in
  // All calls clobber the non-callee saved registers...
  let Defs = [EAX, ECX, EDX, FP0, FP1, FP2, FP3, FP4, FP5, FP6, ST0,
              MM0, MM1, MM2, MM3, MM4, MM5, MM6, MM7,
              XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6, XMM7, EFLAGS] in {
    def CALLpcrel32 : Ii32&lt;0xE8, RawFrm, (outs), (ins i32imm:$dst,variable_ops),
                           &quot;call\t${dst:call}&quot;, []&gt;;
    def CALL32r     : I&lt;0xFF, MRM2r, (outs), (ins GR32:$dst, variable_ops),
                        &quot;call\t{*}$dst&quot;, [(X86call GR32:$dst)]&gt;;
    def CALL32m     : I&lt;0xFF, MRM2m, (outs), (ins i32mem:$dst, variable_ops),
                        &quot;call\t{*}$dst&quot;, []&gt;;
  }
</pre></div>
</div>
<p>File-scope “let” expressions are often useful when a couple of definitions need
to be added to several records, and the records do not otherwise need to be
opened, as in the case with the <code class="docutils literal notranslate"><span class="pre">CALL*</span></code> instructions above.</p>
<p>It’s also possible to use “let” expressions inside multiclasses, providing more
ways to factor out commonality from the records, specially if using several
levels of multiclass instantiations. This also avoids the need of using “let”
expressions within subsequent records inside a multiclass.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>multiclass basic_r&lt;bits&lt;4&gt; opc&gt; {
  let Predicates = [HasSSE2] in {
    def rr : Instruction&lt;opc, &quot;rr&quot;&gt;;
    def rm : Instruction&lt;opc, &quot;rm&quot;&gt;;
  }
  let Predicates = [HasSSE3] in
    def rx : Instruction&lt;opc, &quot;rx&quot;&gt;;
}

multiclass basic_ss&lt;bits&lt;4&gt; opc&gt; {
  let IsDouble = 0 in
    defm SS : basic_r&lt;opc&gt;;

  let IsDouble = 1 in
    defm SD : basic_r&lt;opc&gt;;
}

defm ADD : basic_ss&lt;0xf&gt;;
</pre></div>
</div>
</div>
<div class="section" id="looping">
<h4><a class="toc-backref" href="#id18">Looping</a><a class="headerlink" href="#looping" title="Permalink to this headline">¶</a></h4>
<p>TableGen supports the ‘<code class="docutils literal notranslate"><span class="pre">foreach</span></code>’ block, which textually replicates the loop
body, substituting iterator values for iterator references in the body.
Example:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>foreach i = [0, 1, 2, 3] in {
  def R#i : Register&lt;...&gt;;
  def F#i : Register&lt;...&gt;;
}
</pre></div>
</div>
<p>This will create objects <code class="docutils literal notranslate"><span class="pre">R0</span></code>, <code class="docutils literal notranslate"><span class="pre">R1</span></code>, <code class="docutils literal notranslate"><span class="pre">R2</span></code> and <code class="docutils literal notranslate"><span class="pre">R3</span></code>.  <code class="docutils literal notranslate"><span class="pre">foreach</span></code> blocks
may be nested. If there is only one item in the body the braces may be
elided:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>foreach i = [0, 1, 2, 3] in
  def R#i : Register&lt;...&gt;;
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="code-generator-backend-info">
<h2><a class="toc-backref" href="#id19">Code Generator backend info</a><a class="headerlink" href="#code-generator-backend-info" title="Permalink to this headline">¶</a></h2>
<p>Expressions used by code generator to describe instructions and isel patterns:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">(implicit</span> <span class="pre">a)</span></code></dt><dd><p>an implicitly defined physical register.  This tells the dag instruction
selection emitter the input pattern’s extra definitions matches implicit
physical register definitions.</p>
</dd>
</dl>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="Deficiencies.html" title="TableGen Deficiencies"
             >next</a> |</li>
        <li class="right" >
          <a href="LangRef.html" title="TableGen Language Reference"
             >previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="../index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >TableGen</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2003-2020, LLVM Project.
      Last updated on 2020-01-13.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.3.1.
    </div>
  </body>
</html>