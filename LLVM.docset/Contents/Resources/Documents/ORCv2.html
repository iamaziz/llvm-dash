

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>ORC Design and Implementation &#8212; LLVM 9 documentation</title>
    <link rel="stylesheet" href="_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="LLVM Community Code of Conduct" href="CodeOfConduct.html" />
    <link rel="prev" title="MCJIT Design and Implementation" href="MCJITDesignAndImplementation.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="CodeOfConduct.html" title="LLVM Community Code of Conduct"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="MCJITDesignAndImplementation.html" title="MCJIT Design and Implementation"
             accesskey="P">previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="orc-design-and-implementation">
<h1>ORC Design and Implementation<a class="headerlink" href="#orc-design-and-implementation" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id6">Introduction</a></p></li>
<li><p><a class="reference internal" href="#use-cases" id="id7">Use-cases</a></p></li>
<li><p><a class="reference internal" href="#features" id="id8">Features</a></p></li>
<li><p><a class="reference internal" href="#lljit-and-lllazyjit" id="id9">LLJIT and LLLazyJIT</a></p></li>
<li><p><a class="reference internal" href="#design-overview" id="id10">Design Overview</a></p></li>
<li><p><a class="reference internal" href="#top-level-apis" id="id11">Top Level APIs</a></p></li>
<li><p><a class="reference internal" href="#handy-utilities" id="id12">Handy utilities</a></p></li>
<li><p><a class="reference internal" href="#laziness" id="id13">Laziness</a></p></li>
<li><p><a class="reference internal" href="#supporting-custom-compilers" id="id14">Supporting Custom Compilers</a></p></li>
<li><p><a class="reference internal" href="#transitioning-from-orcv1-to-orcv2" id="id15">Transitioning from ORCv1 to ORCv2</a></p></li>
<li><p><a class="reference internal" href="#how-tos" id="id16">How-tos</a></p>
<ul>
<li><p><a class="reference internal" href="#how-to-manage-symbol-strings" id="id17">How to manage symbol strings</a></p></li>
<li><p><a class="reference internal" href="#how-to-create-jitdylibs-and-set-up-linkage-relationships" id="id18">How to create JITDylibs and set up linkage relationships</a></p></li>
<li><p><a class="reference internal" href="#how-to-use-threadsafemodule-and-threadsafecontext" id="id19">How to use ThreadSafeModule and ThreadSafeContext</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#how-to-add-process-and-library-symbols-to-the-jitdylibs" id="id20">How to Add Process and Library Symbols to the JITDylibs</a></p></li>
<li><p><a class="reference internal" href="#future-features" id="id21">Future Features</a></p></li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id6">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document aims to provide a high-level overview of the design and
implementation of the ORC JIT APIs. Except where otherwise stated, all
discussion applies to the design of the APIs as of LLVM verison 9 (ORCv2).</p>
</div>
<div class="section" id="use-cases">
<h2><a class="toc-backref" href="#id7">Use-cases</a><a class="headerlink" href="#use-cases" title="Permalink to this headline">¶</a></h2>
<p>ORC provides a modular API for building JIT compilers. There are a range
of use cases for such an API. For example:</p>
<p>1. The LLVM tutorials use a simple ORC-based JIT class to execute expressions
compiled from a toy languge: Kaleidoscope.</p>
<p>2. The LLVM debugger, LLDB, uses a cross-compiling JIT for expression
evaluation. In this use case, cross compilation allows expressions compiled
in the debugger process to be executed on the debug target process, which may
be on a different device/architecture.</p>
<p>3. In high-performance JITs (e.g. JVMs, Julia) that want to make use of LLVM’s
optimizations within an existing JIT infrastructure.</p>
<ol class="arabic simple" start="4">
<li><p>In interpreters and REPLs, e.g. Cling (C++) and the Swift interpreter.</p></li>
</ol>
<p>By adoping a modular, library-based design we aim to make ORC useful in as many
of these contexts as possible.</p>
</div>
<div class="section" id="features">
<h2><a class="toc-backref" href="#id8">Features</a><a class="headerlink" href="#features" title="Permalink to this headline">¶</a></h2>
<p>ORC provides the following features:</p>
<ul class="simple">
<li><p><em>JIT-linking</em> links relocatable object files (COFF, ELF, MachO) <a class="footnote-reference brackets" href="#id2" id="id1">1</a> into a
target process an runtime. The target process may be the same process that
contains the JIT session object and jit-linker, or may be another process
(even one running on a different machine or architecture) that communicates
with the JIT via RPC.</p></li>
<li><p><em>LLVM IR compilation</em>, which is provided by off the shelf components
(IRCompileLayer, SimpleCompiler, ConcurrentIRCompiler) that make it easy to
add LLVM IR to a JIT’d process.</p></li>
<li><p><em>Eager and lazy compilation</em>. By default, ORC will compile symbols as soon as
they are looked up in the JIT session object (<code class="docutils literal notranslate"><span class="pre">ExecutionSession</span></code>). Compiling
eagerly by default makes it easy to use ORC as a simple in-memory compiler for
an existing JIT. ORC also provides a simple mechanism, lazy-reexports, for
deferring compilation until first call.</p></li>
<li><p><em>Support for custom compilers and program representations</em>. Clients can supply
custom compilers for each symbol that they define in their JIT session. ORC
will run the user-supplied compiler when the a definition of a symbol is
needed. ORC is actually fully language agnostic: LLVM IR is not treated
specially, and is supported via the same wrapper mechanism (the
<code class="docutils literal notranslate"><span class="pre">MaterializationUnit</span></code> class) that is used for custom compilers.</p></li>
<li><p><em>Concurrent JIT’d code</em> and <em>concurrent compilation</em>. JIT’d code may spawn
multiple threads, and may re-enter the JIT (e.g. for lazy compilation)
concurrently from multiple threads. The ORC APIs also support running multiple
compilers concurrently, and provides off-the-shelf infrastructure to track
dependencies on running compiles (e.g. to ensure that we never call into code
until it is safe to do so, even if that involves waiting on multiple
compiles).</p></li>
<li><p><em>Orthogonality</em> and <em>composability</em>: Each of the features above can be used (or
not) independently. It is possible to put ORC components together to make a
non-lazy, in-process, single threaded JIT or a lazy, out-of-process,
concurrent JIT, or anything in between.</p></li>
</ul>
</div>
<div class="section" id="lljit-and-lllazyjit">
<h2><a class="toc-backref" href="#id9">LLJIT and LLLazyJIT</a><a class="headerlink" href="#lljit-and-lllazyjit" title="Permalink to this headline">¶</a></h2>
<p>ORC provides two basic JIT classes off-the-shelf. These are useful both as
examples of how to assemble ORC components to make a JIT, and as replacements
for earlier LLVM JIT APIs (e.g. MCJIT).</p>
<p>The LLJIT class uses an IRCompileLayer and RTDyldObjectLinkingLayer to support
compilation of LLVM IR and linking of relocatable object files. All operations
are performed eagerly on symbol lookup (i.e. a symbol’s definition is compiled
as soon as you attempt to look up its address). LLJIT is a suitable replacement
for MCJIT in most cases (note: some more advanced features, e.g.
JITEventListeners are not supported yet).</p>
<p>The LLLazyJIT extends LLJIT and adds a CompileOnDemandLayer to enable lazy
compilation of LLVM IR. When an LLVM IR module is added via the addLazyIRModule
method, function bodies in that module will not be compiled until they are first
called. LLLazyJIT aims to provide a replacement of LLVM’s original (pre-MCJIT)
JIT API.</p>
<p>LLJIT and LLLazyJIT instances can be created using their respective builder
classes: LLJITBuilder and LLazyJITBuilder. For example, assuming you have a
module <code class="docutils literal notranslate"><span class="pre">M</span></code> loaded on an ThreadSafeContext <code class="docutils literal notranslate"><span class="pre">Ctx</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Try to detect the host arch and construct an LLJIT instance.</span>
<span class="k">auto</span> <span class="n">JIT</span> <span class="o">=</span> <span class="n">LLJITBuilder</span><span class="p">().</span><span class="n">create</span><span class="p">();</span>

<span class="c1">// If we could not construct an instance, return an error.</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">JIT</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">JIT</span><span class="p">.</span><span class="n">takeError</span><span class="p">();</span>

<span class="c1">// Add the module.</span>
<span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">Err</span> <span class="o">=</span> <span class="n">JIT</span><span class="o">-&gt;</span><span class="n">addIRModule</span><span class="p">(</span><span class="n">TheadSafeModule</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">M</span><span class="p">),</span> <span class="n">Ctx</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">Err</span><span class="p">;</span>

<span class="c1">// Look up the JIT&#39;d code entry point.</span>
<span class="k">auto</span> <span class="n">EntrySym</span> <span class="o">=</span> <span class="n">JIT</span><span class="o">-&gt;</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;entry&quot;</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EntrySym</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">EntrySym</span><span class="p">.</span><span class="n">takeError</span><span class="p">();</span>

<span class="k">auto</span> <span class="o">*</span><span class="n">Entry</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">EntrySym</span><span class="p">.</span><span class="n">getAddress</span><span class="p">();</span>

<span class="n">Entry</span><span class="p">();</span>
</pre></div>
</div>
<p>The builder clasess provide a number of configuration options that can be
specified before the JIT instance is constructed. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Build an LLLazyJIT instance that uses four worker threads for compilation,</span>
<span class="c1">// and jumps to a specific error handler (rather than null) on lazy compile</span>
<span class="c1">// failures.</span>

<span class="kt">void</span> <span class="nf">handleLazyCompileFailure</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// JIT&#39;d code will jump here if lazy compilation fails, giving us an</span>
  <span class="c1">// opportunity to exit or throw an exception into JIT&#39;d code.</span>
  <span class="k">throw</span> <span class="n">JITFailed</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="n">JIT</span> <span class="o">=</span> <span class="n">LLLazyJITBuilder</span><span class="p">()</span>
             <span class="p">.</span><span class="n">setNumCompileThreads</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
             <span class="p">.</span><span class="n">setLazyCompileFailureAddr</span><span class="p">(</span>
                 <span class="n">toJITTargetAddress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handleLazyCompileFailure</span><span class="p">))</span>
             <span class="p">.</span><span class="n">create</span><span class="p">();</span>

<span class="c1">// ...</span>
</pre></div>
</div>
<p>For users wanting to get started with LLJIT a minimal example program can be
found at <code class="docutils literal notranslate"><span class="pre">llvm/examples/HowToUseLLJIT</span></code>.</p>
</div>
<div class="section" id="design-overview">
<h2><a class="toc-backref" href="#id10">Design Overview</a><a class="headerlink" href="#design-overview" title="Permalink to this headline">¶</a></h2>
<p>ORC’s JIT’d program model aims to emulate the linking and symbol resolution
rules used by the static and dynamic linkers. This allows ORC to JIT
arbitrary LLVM IR, including IR produced by an ordinary static compiler (e.g.
clang) that uses constructs like symbol linkage and visibility, and weak and
common symbol definitions.</p>
<p>To see how this works, imagine a program <code class="docutils literal notranslate"><span class="pre">foo</span></code> which links against a pair
of dynamic libraries: <code class="docutils literal notranslate"><span class="pre">libA</span></code> and <code class="docutils literal notranslate"><span class="pre">libB</span></code>. On the command line, building this
program might look like:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ clang++ -shared -o libA.dylib a1.cpp a2.cpp
$ clang++ -shared -o libB.dylib b1.cpp b2.cpp
$ clang++ -o myapp myapp.cpp -L. -lA -lB
$ ./myapp
</pre></div>
</div>
<p>In ORC, this would translate into API calls on a “CXXCompilingLayer” (with error
checking omitted for brevity) as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ExecutionSession</span> <span class="n">ES</span><span class="p">;</span>
<span class="n">RTDyldObjectLinkingLayer</span> <span class="nf">ObjLinkingLayer</span><span class="p">(</span>
    <span class="n">ES</span><span class="p">,</span> <span class="p">[]()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">llvm</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">SectionMemoryManager</span><span class="o">&gt;</span><span class="p">();</span> <span class="p">});</span>
<span class="n">CXXCompileLayer</span> <span class="nf">CXXLayer</span><span class="p">(</span><span class="n">ES</span><span class="p">,</span> <span class="n">ObjLinkingLayer</span><span class="p">);</span>

<span class="c1">// Create JITDylib &quot;A&quot; and add code to it using the CXX layer.</span>
<span class="k">auto</span> <span class="o">&amp;</span><span class="n">LibA</span> <span class="o">=</span> <span class="n">ES</span><span class="p">.</span><span class="n">createJITDylib</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">);</span>
<span class="n">CXXLayer</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">LibA</span><span class="p">,</span> <span class="n">MemoryBuffer</span><span class="o">::</span><span class="n">getFile</span><span class="p">(</span><span class="s">&quot;a1.cpp&quot;</span><span class="p">));</span>
<span class="n">CXXLayer</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">LibA</span><span class="p">,</span> <span class="n">MemoryBuffer</span><span class="o">::</span><span class="n">getFile</span><span class="p">(</span><span class="s">&quot;a2.cpp&quot;</span><span class="p">));</span>

<span class="c1">// Create JITDylib &quot;B&quot; and add code to it using the CXX layer.</span>
<span class="k">auto</span> <span class="o">&amp;</span><span class="n">LibB</span> <span class="o">=</span> <span class="n">ES</span><span class="p">.</span><span class="n">createJITDylib</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">);</span>
<span class="n">CXXLayer</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">LibB</span><span class="p">,</span> <span class="n">MemoryBuffer</span><span class="o">::</span><span class="n">getFile</span><span class="p">(</span><span class="s">&quot;b1.cpp&quot;</span><span class="p">));</span>
<span class="n">CXXLayer</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">LibB</span><span class="p">,</span> <span class="n">MemoryBuffer</span><span class="o">::</span><span class="n">getFile</span><span class="p">(</span><span class="s">&quot;b2.cpp&quot;</span><span class="p">));</span>

<span class="c1">// Specify the search order for the main JITDylib. This is equivalent to a</span>
<span class="c1">// &quot;links against&quot; relationship in a command-line link.</span>
<span class="n">ES</span><span class="p">.</span><span class="n">getMainJITDylib</span><span class="p">().</span><span class="n">setSearchOrder</span><span class="p">({{</span><span class="o">&amp;</span><span class="n">LibA</span><span class="p">,</span> <span class="nb">false</span><span class="p">},</span> <span class="p">{</span><span class="o">&amp;</span><span class="n">LibB</span><span class="p">,</span> <span class="nb">false</span><span class="p">}});</span>
<span class="n">CXXLayer</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">ES</span><span class="p">.</span><span class="n">getMainJITDylib</span><span class="p">(),</span> <span class="n">MemoryBuffer</span><span class="o">::</span><span class="n">getFile</span><span class="p">(</span><span class="s">&quot;main.cpp&quot;</span><span class="p">));</span>

<span class="c1">// Look up the JIT&#39;d main, cast it to a function pointer, then call it.</span>
<span class="k">auto</span> <span class="n">MainSym</span> <span class="o">=</span> <span class="n">ExitOnErr</span><span class="p">(</span><span class="n">ES</span><span class="p">.</span><span class="n">lookup</span><span class="p">({</span><span class="o">&amp;</span><span class="n">ES</span><span class="p">.</span><span class="n">getMainJITDylib</span><span class="p">()},</span> <span class="s">&quot;main&quot;</span><span class="p">));</span>
<span class="k">auto</span> <span class="o">*</span><span class="n">Main</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span><span class="p">[]))</span><span class="n">MainSym</span><span class="p">.</span><span class="n">getAddress</span><span class="p">();</span>
</pre></div>
</div>
<p>v  int Result = Main(…);</p>
<p>This example tells us nothing about <em>how</em> or <em>when</em> compilation will happen.
That will depend on the implementation of the hypothetical CXXCompilingLayer.
The same linker-based symbol resolution rules will apply regardless of that
implementation, however. For example, if a1.cpp and a2.cpp both define a
function “foo” then ORCv2 will generate a duplicate definition error. On the
other hand, if a1.cpp and b1.cpp both define “foo” there is no error (different
dynamic libraries may define the same symbol). If main.cpp refers to “foo”, it
should bind to the definition in LibA rather than the one in LibB, since
main.cpp is part of the “main” dylib, and the main dylib links against LibA
before LibB.</p>
<p>Many JIT clients will have no need for this strict adherence to the usual
ahead-of-time linking rules, and should be able to get by just fine by putting
all of their code in a single JITDylib. However, clients who want to JIT code
for languages/projects that traditionally rely on ahead-of-time linking (e.g.
C++) will find that this feature makes life much easier.</p>
<p>Symbol lookup in ORC serves two other important functions, beyond providing
addresses for symbols: (1) It triggers compilation of the symbol(s) searched for
(if they have not been compiled already), and (2) it provides the
synchronization mechanism for concurrent compilation. The pseudo-code for the
lookup process is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>construct a query object from a query set and query handler
lock the session
lodge query against requested symbols, collect required materializers (if any)
unlock the session
dispatch materializers (if any)
</pre></div>
</div>
<p>In this context a materializer is something that provides a working definition
of a symbol upon request. Usually materializers are just wrappers for compilers,
but they may also wrap a jit-linker directly (if the program representation
backing the definitions is an object file), or may even be a class that writes
bits directly into memory (for example, if the definitions are
stubs). Materialization is the blanket term for any actions (compiling, linking,
splatting bits, registering with runtimes, etc.) that are requried to generate a
symbol definition that is safe to call or access.</p>
<p>As each materializer completes its work it notifies the JITDylib, which in turn
notifies any query objects that are waiting on the newly materialized
definitions. Each query object maintains a count of the number of symbols that
it is still waiting on, and once this count reaches zero the query object calls
the query handler with a <em>SymbolMap</em> (a map of symbol names to addresses)
describing the result. If any symbol fails to materialize the query immediately
calls the query handler with an error.</p>
<p>The collected materialization units are sent to the ExecutionSession to be
dispatched, and the dispatch behavior can be set by the client. By default each
materializer is run on the calling thread. Clients are free to create new
threads to run materializers, or to send the work to a work queue for a thread
pool (this is what LLJIT/LLLazyJIT do).</p>
</div>
<div class="section" id="top-level-apis">
<h2><a class="toc-backref" href="#id11">Top Level APIs</a><a class="headerlink" href="#top-level-apis" title="Permalink to this headline">¶</a></h2>
<p>Many of ORC’s top-level APIs are visible in the example above:</p>
<ul class="simple">
<li><p><em>ExecutionSession</em> represents the JIT’d program and provides context for the
JIT: It contains the JITDylibs, error reporting mechanisms, and dispatches the
materializers.</p></li>
<li><p><em>JITDylibs</em> provide the symbol tables.</p></li>
<li><p><em>Layers</em> (ObjLinkingLayer and CXXLayer) are wrappers around compilers and
allow clients to add uncompiled program representations supported by those
compilers to JITDylibs.</p></li>
</ul>
<p>Several other important APIs are used explicitly. JIT clients need not be aware
of them, but Layer authors will use them:</p>
<ul class="simple">
<li><p><em>MaterializationUnit</em> - When XXXLayer::add is invoked it wraps the given
program representation (in this example, C++ source) in a MaterializationUnit,
which is then stored in the JITDylib. MaterializationUnits are responsible for
describing the definitions they provide, and for unwrapping the program
representation and passing it back to the layer when compilation is required
(this ownership shuffle makes writing thread-safe layers easier, since the
ownership of the program representation will be passed back on the stack,
rather than having to be fished out of a Layer member, which would require
synchronization).</p></li>
<li><p><em>MaterializationResponsibility</em> - When a MaterializationUnit hands a program
representation back to the layer it comes with an associated
MaterializationResponsibility object. This object tracks the definitions
that must be materialized and provides a way to notify the JITDylib once they
are either successfully materialized or a failure occurs.</p></li>
</ul>
</div>
<div class="section" id="handy-utilities">
<h2><a class="toc-backref" href="#id12">Handy utilities</a><a class="headerlink" href="#handy-utilities" title="Permalink to this headline">¶</a></h2>
<p>TBD: absolute symbols, aliases, off-the-shelf layers.</p>
</div>
<div class="section" id="laziness">
<h2><a class="toc-backref" href="#id13">Laziness</a><a class="headerlink" href="#laziness" title="Permalink to this headline">¶</a></h2>
<p>Laziness in ORC is provided by a utility called “lazy-reexports”. The aim of
this utility is to re-use the synchronization provided by the symbol lookup
mechanism to make it safe to lazily compile functions, even if calls to the
stub occur simultaneously on multiple threads of JIT’d code. It does this by
reducing lazy compilation to symbol lookup: The lazy stub performs a lookup of
its underlying definition on first call, updating the function body pointer
once the definition is available. If additional calls arrive on other threads
while compilation is ongoing they will be safely blocked by the normal lookup
synchronization guarantee (no result until the result is safe) and can also
proceed as soon as compilation completes.</p>
<p>TBD: Usage example.</p>
</div>
<div class="section" id="supporting-custom-compilers">
<h2><a class="toc-backref" href="#id14">Supporting Custom Compilers</a><a class="headerlink" href="#supporting-custom-compilers" title="Permalink to this headline">¶</a></h2>
<p>TBD.</p>
</div>
<div class="section" id="transitioning-from-orcv1-to-orcv2">
<h2><a class="toc-backref" href="#id15">Transitioning from ORCv1 to ORCv2</a><a class="headerlink" href="#transitioning-from-orcv1-to-orcv2" title="Permalink to this headline">¶</a></h2>
<p>Since LLVM 7.0, new ORC development work has focused on adding support for
concurrent JIT compilation. The new APIs (including new layer interfaces and
implementations, and new utilities) that support concurrency are collectively
referred to as ORCv2, and the original, non-concurrent layers and utilities
are now referred to as ORCv1.</p>
<p>The majority of the ORCv1 layers and utilities were renamed with a ‘Legacy’
prefix in LLVM 8.0, and have deprecation warnings attached in LLVM 9.0. In LLVM
10.0 ORCv1 will be removed entirely.</p>
<p>Transitioning from ORCv1 to ORCv2 should be easy for most clients. Most of the
ORCv1 layers and utilities have ORCv2 counterparts[2]_ that can be directly
substituted. However there are some design differences between ORCv1 and ORCv2
to be aware of:</p>
<blockquote>
<div><ol class="arabic">
<li><p>ORCv2 fully adopts the JIT-as-linker model that began with MCJIT. Modules
(and other program representations, e.g. Object Files)  are no longer added
directly to JIT classes or layers. Instead, they are added to <code class="docutils literal notranslate"><span class="pre">JITDylib</span></code>
instances <em>by</em> layers. The <code class="docutils literal notranslate"><span class="pre">JITDylib</span></code> determines <em>where</em> the definitions
reside, the layers determine <em>how</em> the definitions will be compiled.
Linkage relationships between <code class="docutils literal notranslate"><span class="pre">JITDylibs</span></code> determine how inter-module
references are resolved, and symbol resolvers are no longer used. See the
section <a class="reference internal" href="#design-overview">Design Overview</a> for more details.</p>
<p>Unless multiple JITDylibs are needed to model linkage relationsips, ORCv1
clients should place all code in the main JITDylib (returned by
<code class="docutils literal notranslate"><span class="pre">ExecutionSession::getMainJITDylib()</span></code>). MCJIT clients should use LLJIT
(see <a class="reference internal" href="#lljit-and-lllazyjit">LLJIT and LLLazyJIT</a>).</p>
</li>
<li><p>All JIT stacks now need an <code class="docutils literal notranslate"><span class="pre">ExecutionSession</span></code> instance. ExecutionSession
manages the string pool, error reporting, synchronization, and symbol
lookup.</p></li>
<li><p>ORCv2 uses uniqued strings (<code class="docutils literal notranslate"><span class="pre">SymbolStringPtr</span></code> instances) rather than
string values in order to reduce memory overhead and improve lookup
performance. See the subsection <a class="reference internal" href="#how-to-manage-symbol-strings">How to manage symbol strings</a>.</p></li>
<li><p>IR layers require ThreadSafeModule instances, rather than
std::unique_ptr&lt;Module&gt;s. ThreadSafeModule is a wrapper that ensures that
Modules that use the same LLVMContext are not accessed concurrently.
See <a class="reference internal" href="#how-to-use-threadsafemodule-and-threadsafecontext">How to use ThreadSafeModule and ThreadSafeContext</a>.</p></li>
<li><p>Symbol lookup is no longer handled by layers. Instead, there is a
<code class="docutils literal notranslate"><span class="pre">lookup</span></code> method on JITDylib that takes a list of JITDylibs to scan.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ExecutionSession</span> <span class="n">ES</span><span class="p">;</span>
<span class="n">JITDylib</span> <span class="o">&amp;</span><span class="n">JD1</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">JITDylib</span> <span class="o">&amp;</span><span class="n">JD2</span> <span class="o">=</span> <span class="p">...;</span>

<span class="k">auto</span> <span class="n">Sym</span> <span class="o">=</span> <span class="n">ES</span><span class="p">.</span><span class="n">lookup</span><span class="p">({</span><span class="o">&amp;</span><span class="n">JD1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">JD2</span><span class="p">},</span> <span class="n">ES</span><span class="p">.</span><span class="n">intern</span><span class="p">(</span><span class="s">&quot;_main&quot;</span><span class="p">));</span>
</pre></div>
</div>
</li>
<li><p>Module removal is not yet supported. There is no equivalent of the
layer concept removeModule/removeObject methods. Work on resource tracking
and removal in ORCv2 is ongoing.</p></li>
</ol>
</div></blockquote>
<p>For code examples and suggestions of how to use the ORCv2 APIs, please see
the section <a class="reference internal" href="#how-tos">How-tos</a>.</p>
</div>
<div class="section" id="how-tos">
<h2><a class="toc-backref" href="#id16">How-tos</a><a class="headerlink" href="#how-tos" title="Permalink to this headline">¶</a></h2>
<div class="section" id="how-to-manage-symbol-strings">
<h3><a class="toc-backref" href="#id17">How to manage symbol strings</a><a class="headerlink" href="#how-to-manage-symbol-strings" title="Permalink to this headline">¶</a></h3>
<p>Symbol strings in ORC are uniqued to improve lookup performance, reduce memory
overhead, and allow symbol names to function as efficient keys. To get the
unique <code class="docutils literal notranslate"><span class="pre">SymbolStringPtr</span></code> for a string value, call the
<code class="docutils literal notranslate"><span class="pre">ExecutionSession::intern</span></code> method:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ExecutionSession</span> <span class="n">ES</span><span class="p">;</span>
<span class="c1">/// ...</span>
<span class="k">auto</span> <span class="n">MainSymbolName</span> <span class="o">=</span> <span class="n">ES</span><span class="p">.</span><span class="n">intern</span><span class="p">(</span><span class="s">&quot;main&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>If you wish to perform lookup using the C/IR name of a symbol you will also
need to apply the platform linker-mangling before interning the string. On
Linux this mangling is a no-op, but on other platforms it usually involves
adding a prefix to the string (e.g. ‘_’ on Darwin). The mangling scheme is
based on the DataLayout for the target. Given a DataLayout and an
ExecutionSession, you can create a MangleAndInterner function object that
will perform both jobs for you:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ExecutionSession</span> <span class="n">ES</span><span class="p">;</span>
<span class="k">const</span> <span class="n">DataLayout</span> <span class="o">&amp;</span><span class="n">DL</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">MangleAndInterner</span> <span class="nf">Mangle</span><span class="p">(</span><span class="n">ES</span><span class="p">,</span> <span class="n">DL</span><span class="p">);</span>

<span class="c1">// ...</span>

<span class="c1">// Portable IR-symbol-name lookup:</span>
<span class="k">auto</span> <span class="n">Sym</span> <span class="o">=</span> <span class="n">ES</span><span class="p">.</span><span class="n">lookup</span><span class="p">({</span><span class="o">&amp;</span><span class="n">ES</span><span class="p">.</span><span class="n">getMainJITDylib</span><span class="p">()},</span> <span class="n">Mangle</span><span class="p">(</span><span class="s">&quot;main&quot;</span><span class="p">));</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="how-to-create-jitdylibs-and-set-up-linkage-relationships">
<h3><a class="toc-backref" href="#id18">How to create JITDylibs and set up linkage relationships</a><a class="headerlink" href="#how-to-create-jitdylibs-and-set-up-linkage-relationships" title="Permalink to this headline">¶</a></h3>
<p>In ORC, all symbol definitions reside in JITDylibs. JITDylibs are created by
calling the <code class="docutils literal notranslate"><span class="pre">ExecutionSession::createJITDylib</span></code> method with a unique name:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ExecutionSession</span> <span class="n">ES</span><span class="p">;</span>
<span class="k">auto</span> <span class="o">&amp;</span><span class="n">JD</span> <span class="o">=</span> <span class="n">ES</span><span class="p">.</span><span class="n">createJITDylib</span><span class="p">(</span><span class="s">&quot;libFoo.dylib&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>The JITDylib is owned by the <code class="docutils literal notranslate"><span class="pre">ExecutionEngine</span></code> instance and will be freed
when it is destroyed.</p>
<p>A JITDylib representing the JIT main program is created by ExecutionEngine by
default. A reference to it can be obtained by calling
<code class="docutils literal notranslate"><span class="pre">ExecutionSession::getMainJITDylib()</span></code>:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ExecutionSession</span> <span class="n">ES</span><span class="p">;</span>
<span class="k">auto</span> <span class="o">&amp;</span><span class="n">MainJD</span> <span class="o">=</span> <span class="n">ES</span><span class="p">.</span><span class="n">getMainJITDylib</span><span class="p">();</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="how-to-use-threadsafemodule-and-threadsafecontext">
<h3><a class="toc-backref" href="#id19">How to use ThreadSafeModule and ThreadSafeContext</a><a class="headerlink" href="#how-to-use-threadsafemodule-and-threadsafecontext" title="Permalink to this headline">¶</a></h3>
<p>ThreadSafeModule and ThreadSafeContext are wrappers around Modules and
LLVMContexts respectively. A ThreadSafeModule is a pair of a
std::unique_ptr&lt;Module&gt; and a (possibly shared) ThreadSafeContext value. A
ThreadSafeContext is a pair of a std::unique_ptr&lt;LLVMContext&gt; and a lock.
This design serves two purposes: providing both a locking scheme and lifetime
management for LLVMContexts. The ThreadSafeContext may be locked to prevent
accidental concurrent access by two Modules that use the same LLVMContext.
The underlying LLVMContext is freed once all ThreadSafeContext values pointing
to it are destroyed, allowing the context memory to be reclaimed as soon as
the Modules referring to it are destroyed.</p>
<p>ThreadSafeContexts can be explicitly constructed from a
std::unique_ptr&lt;LLVMContext&gt;:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ThreadSafeContext</span> <span class="nf">TSCtx</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">LLVMContext</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
</div></blockquote>
<p>ThreadSafeModules can be constructed from a pair of a std::unique_ptr&lt;Module&gt;
and a ThreadSafeContext value. ThreadSafeContext values may be shared between
multiple ThreadSafeModules:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ThreadSafeModule</span> <span class="nf">TSM1</span><span class="p">(</span>
  <span class="n">llvm</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Module</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;M1&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">TSCtx</span><span class="p">.</span><span class="n">getContext</span><span class="p">()),</span> <span class="n">TSCtx</span><span class="p">);</span>

<span class="n">ThreadSafeModule</span> <span class="nf">TSM2</span><span class="p">(</span>
  <span class="n">llvm</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Module</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;M2&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">TSCtx</span><span class="p">.</span><span class="n">getContext</span><span class="p">()),</span> <span class="n">TSCtx</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>Before using a ThreadSafeContext, clients should ensure that either the context
is only accessible on the current thread, or that the context is locked. In the
example above (where the context is never locked) we rely on the fact that both
<code class="docutils literal notranslate"><span class="pre">TSM1</span></code> and <code class="docutils literal notranslate"><span class="pre">TSM2</span></code>, and TSCtx are all created on one thread. If a context is
going to be shared between threads then it must be locked before the context,
or any Modules attached to it, are accessed. When code is added to in-tree IR
layers this locking is is done automatically by the
<code class="docutils literal notranslate"><span class="pre">BasicIRLayerMaterializationUnit::materialize</span></code> method. In all other
situations, for example when writing a custom IR materialization unit, or
constructing a new ThreadSafeModule from higher-level program representations,
locking must be done explicitly:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">HighLevelRepresentationLayer</span><span class="o">::</span><span class="n">emit</span><span class="p">(</span><span class="n">MaterializationResponsibility</span> <span class="n">R</span><span class="p">,</span>
                                        <span class="n">HighLevelProgramRepresentation</span> <span class="n">H</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Get or create a context value that may be shared between threads.</span>
  <span class="n">ThreadSafeContext</span> <span class="n">TSCtx</span> <span class="o">=</span> <span class="n">getContext</span><span class="p">();</span>

  <span class="c1">// Lock the context to prevent concurrent access.</span>
  <span class="k">auto</span> <span class="n">Lock</span> <span class="o">=</span> <span class="n">TSCtx</span><span class="p">.</span><span class="n">getLock</span><span class="p">();</span>

  <span class="c1">// IRGen a module onto the locked Context.</span>
  <span class="n">ThreadSafeModule</span> <span class="nf">TSM</span><span class="p">(</span><span class="n">IRGen</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="o">*</span><span class="n">TSCtx</span><span class="p">.</span><span class="n">getContext</span><span class="p">()),</span> <span class="n">TSCtx</span><span class="p">);</span>

  <span class="c1">// Emit the module to the base layer with the context still locked.</span>
  <span class="n">BaseIRLayer</span><span class="p">.</span><span class="n">emit</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">R</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">TSM</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Clients wishing to maximize possibilities for concurrent compilation will want
to create every new ThreadSafeModule on a new ThreadSafeContext. For this reason
a convenience constructor for ThreadSafeModule is provided that implicitly
constructs a new ThreadSafeContext value from a std::unique_ptr&lt;LLVMContext&gt;:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Maximize concurrency opportunities by loading every module on a</span>
<span class="c1">// separate context.</span>
<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="nl">IRPath</span> <span class="p">:</span> <span class="n">IRPaths</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">Ctx</span> <span class="o">=</span> <span class="n">llvm</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">LLVMContext</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">M</span> <span class="o">=</span> <span class="n">llvm</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">LLVMContext</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;M&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">Ctx</span><span class="p">);</span>
  <span class="n">CompileLayer</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">ES</span><span class="p">.</span><span class="n">getMainJITDylib</span><span class="p">(),</span>
                   <span class="n">ThreadSafeModule</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">M</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Ctx</span><span class="p">)));</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Clients who plan to run single-threaded may choose to save memory by loading
all modules on the same context:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Save memory by using one context for all Modules:</span>
<span class="n">ThreadSafeContext</span> <span class="nf">TSCtx</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">LLVMContext</span><span class="o">&gt;</span><span class="p">());</span>
<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="nl">IRPath</span> <span class="p">:</span> <span class="n">IRPaths</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ThreadSafeModule</span> <span class="n">TSM</span><span class="p">(</span><span class="n">parsePath</span><span class="p">(</span><span class="n">IRPath</span><span class="p">,</span> <span class="o">*</span><span class="n">TSCtx</span><span class="p">.</span><span class="n">getContext</span><span class="p">()),</span> <span class="n">TSCtx</span><span class="p">);</span>
  <span class="n">CompileLayer</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">ES</span><span class="p">.</span><span class="n">getMainJITDylib</span><span class="p">(),</span> <span class="n">ThreadSafeModule</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">TSM</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="how-to-add-process-and-library-symbols-to-the-jitdylibs">
<h2><a class="toc-backref" href="#id20">How to Add Process and Library Symbols to the JITDylibs</a><a class="headerlink" href="#how-to-add-process-and-library-symbols-to-the-jitdylibs" title="Permalink to this headline">¶</a></h2>
<p>JIT’d code typically needs access to symbols in the host program or in
supporting libraries. References to process symbols can be “baked in” to code
as it is compiled by turning external references into pre-resolved integer
constants, however this ties the JIT’d code to the current process’s virtual
memory layout (meaning that it can not be cached between runs) and makes
debugging lower level program representations difficult (as all external
references are opaque integer values). A bettor solution is to maintain symbolic
external references and let the jit-linker bind them for you at runtime. To
allow the JIT linker to find these external definitions their addresses must
be added to a JITDylib that the JIT’d definitions link against.</p>
<p>Adding definitions for external symbols could be done using the absoluteSymbols
function:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">DataLayout</span> <span class="o">&amp;</span><span class="n">DL</span> <span class="o">=</span> <span class="n">getDataLayout</span><span class="p">();</span>
<span class="n">MangleAndInterner</span> <span class="nf">Mangle</span><span class="p">(</span><span class="n">ES</span><span class="p">,</span> <span class="n">DL</span><span class="p">);</span>

<span class="k">auto</span> <span class="o">&amp;</span><span class="n">JD</span> <span class="o">=</span> <span class="n">ES</span><span class="p">.</span><span class="n">getMainJITDylib</span><span class="p">();</span>

<span class="n">JD</span><span class="p">.</span><span class="n">define</span><span class="p">(</span>
  <span class="n">absoluteSymbols</span><span class="p">({</span>
    <span class="p">{</span> <span class="n">Mangle</span><span class="p">(</span><span class="s">&quot;puts&quot;</span><span class="p">),</span> <span class="n">pointerToJITTargetAddress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">puts</span><span class="p">)},</span>
    <span class="p">{</span> <span class="n">Mangle</span><span class="p">(</span><span class="s">&quot;gets&quot;</span><span class="p">),</span> <span class="n">pointerToJITTargetAddress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">getS</span><span class="p">)}</span>
  <span class="p">}));</span>
</pre></div>
</div>
</div></blockquote>
<p>Manually adding absolute symbols for a large or changing interface is cumbersome
however, so ORC provides an alternative to generate new definitions on demand:
<em>definition generators</em>. If a definition generator is attached to a JITDylib,
then any unsuccessful lookup on that JITDylib will fall back to calling the
definition generator, and the definition generator may choose to generate a new
definition for the missing symbols. Of particular use here is the
<code class="docutils literal notranslate"><span class="pre">DynamicLibrarySearchGenerator</span></code> utility. This can be used to reflect the whole
exported symbol set of the process or a specific dynamic library, or a subset
of either of these determined by a predicate.</p>
<p>For example, to load the whole interface of a runtime library:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">DataLayout</span> <span class="o">&amp;</span><span class="n">DL</span> <span class="o">=</span> <span class="n">getDataLayout</span><span class="p">();</span>
<span class="k">auto</span> <span class="o">&amp;</span><span class="n">JD</span> <span class="o">=</span> <span class="n">ES</span><span class="p">.</span><span class="n">getMainJITDylib</span><span class="p">();</span>

<span class="n">JD</span><span class="p">.</span><span class="n">setGenerator</span><span class="p">(</span><span class="n">DynamicLibrarySearchGenerator</span><span class="o">::</span><span class="n">Load</span><span class="p">(</span><span class="s">&quot;/path/to/lib&quot;</span>
                                                    <span class="n">DL</span><span class="p">.</span><span class="n">getGlobalPrefix</span><span class="p">()));</span>

<span class="c1">// IR added to JD can now link against all symbols exported by the library</span>
<span class="c1">// at &#39;/path/to/lib&#39;.</span>
<span class="n">CompileLayer</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">JD</span><span class="p">,</span> <span class="n">loadModule</span><span class="p">(...));</span>
</pre></div>
</div>
</div></blockquote>
<p>Or, to expose a whitelisted set of symbols from the main process:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">DataLayout</span> <span class="o">&amp;</span><span class="n">DL</span> <span class="o">=</span> <span class="n">getDataLayout</span><span class="p">();</span>
<span class="n">MangleAndInterner</span> <span class="nf">Mangle</span><span class="p">(</span><span class="n">ES</span><span class="p">,</span> <span class="n">DL</span><span class="p">);</span>

<span class="k">auto</span> <span class="o">&amp;</span><span class="n">JD</span> <span class="o">=</span> <span class="n">ES</span><span class="p">.</span><span class="n">getMainJITDylib</span><span class="p">();</span>

<span class="n">DenseSet</span><span class="o">&lt;</span><span class="n">SymbolStringPtr</span><span class="o">&gt;</span> <span class="n">Whitelist</span><span class="p">({</span>
    <span class="n">Mangle</span><span class="p">(</span><span class="s">&quot;puts&quot;</span><span class="p">),</span>
    <span class="n">Mangle</span><span class="p">(</span><span class="s">&quot;gets&quot;</span><span class="p">)</span>
  <span class="p">});</span>

<span class="c1">// Use GetForCurrentProcess with a predicate function that checks the</span>
<span class="c1">// whitelist.</span>
<span class="n">JD</span><span class="p">.</span><span class="n">setGenerator</span><span class="p">(</span>
  <span class="n">DynamicLibrarySearchGenerator</span><span class="o">::</span><span class="n">GetForCurrentProcess</span><span class="p">(</span>
    <span class="n">DL</span><span class="p">.</span><span class="n">getGlobalPrefix</span><span class="p">(),</span>
    <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">SymbolStringPtr</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Whitelist</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">S</span><span class="p">);</span> <span class="p">}));</span>

<span class="c1">// IR added to JD can now link against any symbols exported by the process</span>
<span class="c1">// and contained in the whitelist.</span>
<span class="n">CompileLayer</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">JD</span><span class="p">,</span> <span class="n">loadModule</span><span class="p">(...));</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="future-features">
<h2><a class="toc-backref" href="#id21">Future Features</a><a class="headerlink" href="#future-features" title="Permalink to this headline">¶</a></h2>
<p>TBD: Speculative compilation. Object Caches.</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Formats/architectures vary in terms of supported features. MachO and
ELF tend to have better support than COFF. Patches very welcome!</p>
</dd>
<dt class="label" id="id3"><span class="brackets">2</span></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">LazyEmittingLayer</span></code>, <code class="docutils literal notranslate"><span class="pre">RemoteObjectClientLayer</span></code> and
<code class="docutils literal notranslate"><span class="pre">RemoteObjectServerLayer</span></code> do not have counterparts in the new
system. In the case of <code class="docutils literal notranslate"><span class="pre">LazyEmittingLayer</span></code> it was simply no longer
needed: in ORCv2, deferring compilation until symbols are looked up is
the default. The removal of <code class="docutils literal notranslate"><span class="pre">RemoteObjectClientLayer</span></code> and
<code class="docutils literal notranslate"><span class="pre">RemoteObjectServerLayer</span></code> means that JIT stacks can no longer be split
across processes, however this functionality appears not to have been
used.</p>
</dd>
<dt class="label" id="id4"><span class="brackets">3</span></dt>
<dd><p>Sharing ThreadSafeModules in a concurrent compilation can be dangerous:
if interdependent modules are loaded on the same context, but compiled
on different threads a deadlock may occur (with each compile waiting for
the other(s) to complete, and the other(s) unable to proceed because the
context is locked).</p>
</dd>
<dt class="label" id="id5"><span class="brackets">4</span></dt>
<dd><p>Mostly. Weak definitions are handled correctly within dylibs, but if
multiple dylibs provide a weak definition of a symbol each will end up
with its own definition (similar to how weak symbols in Windows DLLs
behave). This will be fixed in the future.</p>
</dd>
</dl>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="CodeOfConduct.html" title="LLVM Community Code of Conduct"
             >next</a> |</li>
        <li class="right" >
          <a href="MCJITDesignAndImplementation.html" title="MCJIT Design and Implementation"
             >previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2003-2020, LLVM Project.
      Last updated on 2020-01-13.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.3.1.
    </div>
  </body>
</html>