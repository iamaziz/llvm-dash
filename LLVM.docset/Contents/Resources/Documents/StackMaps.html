

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Stack maps and patch points in LLVM &#8212; LLVM 9 documentation</title>
    <link rel="stylesheet" href="_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Design and Usage of the InAlloca Attribute" href="InAlloca.html" />
    <link rel="prev" title="AMDGPU Instructions Notation" href="AMDGPUInstructionNotation.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="InAlloca.html" title="Design and Usage of the InAlloca Attribute"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="AMDGPUInstructionNotation.html" title="AMDGPU Instructions Notation"
             accesskey="P">previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="stack-maps-and-patch-points-in-llvm">
<h1>Stack maps and patch points in LLVM<a class="headerlink" href="#stack-maps-and-patch-points-in-llvm" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#definitions" id="id5">Definitions</a></p></li>
<li><p><a class="reference internal" href="#motivation" id="id6">Motivation</a></p></li>
<li><p><a class="reference internal" href="#intrinsics" id="id7">Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-experimental-stackmap-intrinsic" id="id8">‘<code class="docutils literal notranslate"><span class="pre">llvm.experimental.stackmap</span></code>’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-experimental-patchpoint-intrinsic" id="id9">‘<code class="docutils literal notranslate"><span class="pre">llvm.experimental.patchpoint.*</span></code>’ Intrinsic</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#stack-map-format" id="id10">Stack Map Format</a></p>
<ul>
<li><p><a class="reference internal" href="#stack-map-section" id="id11">Stack Map Section</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#stack-map-usage" id="id12">Stack Map Usage</a></p>
<ul>
<li><p><a class="reference internal" href="#direct-stack-map-entries" id="id13">Direct Stack Map Entries</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#supported-architectures" id="id14">Supported Architectures</a></p></li>
</ul>
</div>
<div class="section" id="definitions">
<h2><a class="toc-backref" href="#id5">Definitions</a><a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h2>
<p>In this document we refer to the “runtime” collectively as all
components that serve as the LLVM client, including the LLVM IR
generator, object code consumer, and code patcher.</p>
<p>A stack map records the location of <code class="docutils literal notranslate"><span class="pre">live</span> <span class="pre">values</span></code> at a particular
instruction address. These <code class="docutils literal notranslate"><span class="pre">live</span> <span class="pre">values</span></code> do not refer to all the
LLVM values live across the stack map. Instead, they are only the
values that the runtime requires to be live at this point. For
example, they may be the values the runtime will need to resume
program execution at that point independent of the compiled function
containing the stack map.</p>
<p>LLVM emits stack map data into the object code within a designated
<a class="reference internal" href="#stackmap-section"><span class="std std-ref">Stack Map Section</span></a>. This stack map data contains a record for
each stack map. The record stores the stack map’s instruction address
and contains a entry for each mapped value. Each entry encodes a
value’s location as a register, stack offset, or constant.</p>
<p>A patch point is an instruction address at which space is reserved for
patching a new instruction sequence at run time. Patch points look
much like calls to LLVM. They take arguments that follow a calling
convention and may return a value. They also imply stack map
generation, which allows the runtime to locate the patchpoint and
find the location of <code class="docutils literal notranslate"><span class="pre">live</span> <span class="pre">values</span></code> at that point.</p>
</div>
<div class="section" id="motivation">
<h2><a class="toc-backref" href="#id6">Motivation</a><a class="headerlink" href="#motivation" title="Permalink to this headline">¶</a></h2>
<p>This functionality is currently experimental but is potentially useful
in a variety of settings, the most obvious being a runtime (JIT)
compiler. Example applications of the patchpoint intrinsics are
implementing an inline call cache for polymorphic method dispatch or
optimizing the retrieval of properties in dynamically typed languages
such as JavaScript.</p>
<p>The intrinsics documented here are currently used by the JavaScript
compiler within the open source WebKit project, see the <a class="reference external" href="https://trac.webkit.org/wiki/FTLJIT">FTL JIT</a>, but they are designed to be
used whenever stack maps or code patching are needed. Because the
intrinsics have experimental status, compatibility across LLVM
releases is not guaranteed.</p>
<p>The stack map functionality described in this document is separate
from the functionality described in
<a class="reference internal" href="GarbageCollection.html#stack-map"><span class="std std-ref">Computing stack maps</span></a>. <cite>GCFunctionMetadata</cite> provides the location of
pointers into a collected heap captured by the <cite>GCRoot</cite> intrinsic,
which can also be considered a “stack map”. Unlike the stack maps
defined above, the <cite>GCFunctionMetadata</cite> stack map interface does not
provide a way to associate live register values of arbitrary type with
an instruction address, nor does it specify a format for the resulting
stack map. The stack maps described here could potentially provide
richer information to a garbage collecting runtime, but that usage
will not be discussed in this document.</p>
</div>
<div class="section" id="intrinsics">
<h2><a class="toc-backref" href="#id7">Intrinsics</a><a class="headerlink" href="#intrinsics" title="Permalink to this headline">¶</a></h2>
<p>The following two kinds of intrinsics can be used to implement stack
maps and patch points: <code class="docutils literal notranslate"><span class="pre">llvm.experimental.stackmap</span></code> and
<code class="docutils literal notranslate"><span class="pre">llvm.experimental.patchpoint</span></code>. Both kinds of intrinsics generate a
stack map record, and they both allow some form of code patching. They
can be used independently (i.e. <code class="docutils literal notranslate"><span class="pre">llvm.experimental.patchpoint</span></code>
implicitly generates a stack map without the need for an additional
call to <code class="docutils literal notranslate"><span class="pre">llvm.experimental.stackmap</span></code>). The choice of which to use
depends on whether it is necessary to reserve space for code patching
and whether any of the intrinsic arguments should be lowered according
to calling conventions. <code class="docutils literal notranslate"><span class="pre">llvm.experimental.stackmap</span></code> does not
reserve any space, nor does it expect any call arguments. If the
runtime patches code at the stack map’s address, it will destructively
overwrite the program text. This is unlike
<code class="docutils literal notranslate"><span class="pre">llvm.experimental.patchpoint</span></code>, which reserves space for in-place
patching without overwriting surrounding code. The
<code class="docutils literal notranslate"><span class="pre">llvm.experimental.patchpoint</span></code> intrinsic also lowers a specified
number of arguments according to its calling convention. This allows
patched code to make in-place function calls without marshaling.</p>
<p>Each instance of one of these intrinsics generates a stack map record
in the <a class="reference internal" href="#stackmap-section"><span class="std std-ref">Stack Map Section</span></a>. The record includes an ID, allowing
the runtime to uniquely identify the stack map, and the offset within
the code from the beginning of the enclosing function.</p>
<div class="section" id="llvm-experimental-stackmap-intrinsic">
<h3><a class="toc-backref" href="#id8">‘<code class="docutils literal notranslate"><span class="pre">llvm.experimental.stackmap</span></code>’ Intrinsic</a><a class="headerlink" href="#llvm-experimental-stackmap-intrinsic" title="Permalink to this headline">¶</a></h3>
<div class="section" id="syntax">
<h4>Syntax:<a class="headerlink" href="#syntax" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span>
  <span class="nd">@llvm</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">stackmap</span><span class="p">(</span><span class="n">i64</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">numShadowBytes</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="overview">
<h4>Overview:<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h4>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.experimental.stackmap</span></code>’ intrinsic records the location of
specified values in the stack map without generating any code.</p>
</div>
<div class="section" id="operands">
<h4>Operands:<a class="headerlink" href="#operands" title="Permalink to this headline">¶</a></h4>
<p>The first operand is an ID to be encoded within the stack map. The
second operand is the number of shadow bytes following the
intrinsic. The variable number of operands that follow are the <code class="docutils literal notranslate"><span class="pre">live</span>
<span class="pre">values</span></code> for which locations will be recorded in the stack map.</p>
<p>To use this intrinsic as a bare-bones stack map, with no code patching
support, the number of shadow bytes can be set to zero.</p>
</div>
<div class="section" id="semantics">
<h4>Semantics:<a class="headerlink" href="#semantics" title="Permalink to this headline">¶</a></h4>
<p>The stack map intrinsic generates no code in place, unless nops are
needed to cover its shadow (see below). However, its offset from
function entry is stored in the stack map. This is the relative
instruction address immediately following the instructions that
precede the stack map.</p>
<p>The stack map ID allows a runtime to locate the desired stack map
record. LLVM passes this ID through directly to the stack map
record without checking uniqueness.</p>
<p>LLVM guarantees a shadow of instructions following the stack map’s
instruction offset during which neither the end of the basic block nor
another call to <code class="docutils literal notranslate"><span class="pre">llvm.experimental.stackmap</span></code> or
<code class="docutils literal notranslate"><span class="pre">llvm.experimental.patchpoint</span></code> may occur. This allows the runtime to
patch the code at this point in response to an event triggered from
outside the code. The code for instructions following the stack map
may be emitted in the stack map’s shadow, and these instructions may
be overwritten by destructive patching. Without shadow bytes, this
destructive patching could overwrite program text or data outside the
current function. We disallow overlapping stack map shadows so that
the runtime does not need to consider this corner case.</p>
<p>For example, a stack map with 8 byte shadow:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">call</span> <span class="k">void</span> <span class="vg">@runtime</span><span class="p">()</span>
<span class="k">call</span> <span class="k">void</span> <span class="p">(</span><span class="k">i64</span><span class="p">,</span> <span class="k">i32</span><span class="p">,</span> <span class="p">...)*</span> <span class="vg">@llvm.experimental.stackmap</span><span class="p">(</span><span class="k">i64</span> <span class="m">77</span><span class="p">,</span> <span class="k">i32</span> <span class="m">8</span><span class="p">,</span>
                                                       <span class="k">i64</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">)</span>
<span class="nv">%val</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%ptr</span>
<span class="nv">%add</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i64</span> <span class="nv">%val</span><span class="p">,</span> <span class="m">3</span>
<span class="k">ret</span> <span class="k">i64</span> <span class="nv">%add</span>
</pre></div>
</div>
<p>May require one byte of nop-padding:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x00 callq _runtime
0x05 nop                &lt;--- stack map address
0x06 movq (%rdi), %rax
0x07 addq $3, %rax
0x0a popq %rdx
0x0b ret                &lt;---- end of 8-byte shadow
</pre></div>
</div>
<p>Now, if the runtime needs to invalidate the compiled code, it may
patch 8 bytes of code at the stack map’s address at follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x00 callq _runtime
0x05 movl  $0xffff, %rax &lt;--- patched code at stack map address
0x0a callq *%rax         &lt;---- end of 8-byte shadow
</pre></div>
</div>
<p>This way, after the normal call to the runtime returns, the code will
execute a patched call to a special entry point that can rebuild a
stack frame from the values located by the stack map.</p>
</div>
</div>
<div class="section" id="llvm-experimental-patchpoint-intrinsic">
<h3><a class="toc-backref" href="#id9">‘<code class="docutils literal notranslate"><span class="pre">llvm.experimental.patchpoint.*</span></code>’ Intrinsic</a><a class="headerlink" href="#llvm-experimental-patchpoint-intrinsic" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id1">
<h4>Syntax:<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span>
  <span class="nd">@llvm</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">patchpoint</span><span class="o">.</span><span class="n">void</span><span class="p">(</span><span class="n">i64</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">numBytes</span><span class="o">&gt;</span><span class="p">,</span>
                                     <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">target</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">numArgs</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="n">declare</span> <span class="n">i64</span>
  <span class="nd">@llvm</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">patchpoint</span><span class="o">.</span><span class="n">i64</span><span class="p">(</span><span class="n">i64</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">numBytes</span><span class="o">&gt;</span><span class="p">,</span>
                                    <span class="n">i8</span><span class="o">*</span> <span class="o">&lt;</span><span class="n">target</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">numArgs</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>Overview:<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.experimental.patchpoint.*</span></code>’ intrinsics creates a function
call to the specified <code class="docutils literal notranslate"><span class="pre">&lt;target&gt;</span></code> and records the location of specified
values in the stack map.</p>
</div>
<div class="section" id="id3">
<h4>Operands:<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>The first operand is an ID, the second operand is the number of bytes
reserved for the patchable region, the third operand is the target
address of a function (optionally null), and the fourth operand
specifies how many of the following variable operands are considered
function call arguments. The remaining variable number of operands are
the <code class="docutils literal notranslate"><span class="pre">live</span> <span class="pre">values</span></code> for which locations will be recorded in the stack
map.</p>
</div>
<div class="section" id="id4">
<h4>Semantics:<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>The patch point intrinsic generates a stack map. It also emits a
function call to the address specified by <code class="docutils literal notranslate"><span class="pre">&lt;target&gt;</span></code> if the address
is not a constant null. The function call and its arguments are
lowered according to the calling convention specified at the
intrinsic’s callsite. Variants of the intrinsic with non-void return
type also return a value according to calling convention.</p>
<p>On PowerPC, note that <code class="docutils literal notranslate"><span class="pre">&lt;target&gt;</span></code> must be the ABI function pointer for the
intended target of the indirect call. Specifically, when compiling for the
ELF V1 ABI, <code class="docutils literal notranslate"><span class="pre">&lt;target&gt;</span></code> is the function-descriptor address normally used as
the C/C++ function-pointer representation.</p>
<p>Requesting zero patch point arguments is valid. In this case, all
variable operands are handled just like
<code class="docutils literal notranslate"><span class="pre">llvm.experimental.stackmap.*</span></code>. The difference is that space will
still be reserved for patching, a call will be emitted, and a return
value is allowed.</p>
<p>The location of the arguments are not normally recorded in the stack
map because they are already fixed by the calling convention. The
remaining <code class="docutils literal notranslate"><span class="pre">live</span> <span class="pre">values</span></code> will have their location recorded, which
could be a register, stack location, or constant. A special calling
convention has been introduced for use with stack maps, anyregcc,
which forces the arguments to be loaded into registers but allows
those register to be dynamically allocated. These argument registers
will have their register locations recorded in the stack map in
addition to the remaining <code class="docutils literal notranslate"><span class="pre">live</span> <span class="pre">values</span></code>.</p>
<p>The patch point also emits nops to cover at least <code class="docutils literal notranslate"><span class="pre">&lt;numBytes&gt;</span></code> of
instruction encoding space. Hence, the client must ensure that
<code class="docutils literal notranslate"><span class="pre">&lt;numBytes&gt;</span></code> is enough to encode a call to the target address on the
supported targets. If the call target is constant null, then there is
no minimum requirement. A zero-byte null target patchpoint is
valid.</p>
<p>The runtime may patch the code emitted for the patch point, including
the call sequence and nops. However, the runtime may not assume
anything about the code LLVM emits within the reserved space. Partial
patching is not allowed. The runtime must patch all reserved bytes,
padding with nops if necessary.</p>
<p>This example shows a patch point reserving 15 bytes, with one argument
in $rdi, and a return value in $rax per native calling convention:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">%target</span> <span class="p">=</span> <span class="k">inttoptr</span> <span class="k">i64</span> <span class="m">-281474976710654</span> <span class="k">to</span> <span class="k">i8</span><span class="p">*</span>
<span class="nv">%val</span> <span class="p">=</span> <span class="k">call</span> <span class="k">i64</span> <span class="p">(</span><span class="k">i64</span><span class="p">,</span> <span class="k">i32</span><span class="p">,</span> <span class="p">...)*</span>
         <span class="vg">@llvm.experimental.patchpoint.i64</span><span class="p">(</span><span class="k">i64</span> <span class="m">78</span><span class="p">,</span> <span class="k">i32</span> <span class="m">15</span><span class="p">,</span>
                                           <span class="k">i8</span><span class="p">*</span> <span class="nv">%target</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i64</span><span class="p">*</span> <span class="nv">%ptr</span><span class="p">)</span>
<span class="nv">%add</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i64</span> <span class="nv">%val</span><span class="p">,</span> <span class="m">3</span>
<span class="k">ret</span> <span class="k">i64</span> <span class="nv">%add</span>
</pre></div>
</div>
<p>May generate:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x00 movabsq $0xffff000000000002, %r11 &lt;--- patch point address
0x0a callq   *%r11
0x0d nop
0x0e nop                               &lt;--- end of reserved 15-bytes
0x0f addq    $0x3, %rax
0x10 movl    %rax, 8(%rsp)
</pre></div>
</div>
<p>Note that no stack map locations will be recorded. If the patched code
sequence does not need arguments fixed to specific calling convention
registers, then the <code class="docutils literal notranslate"><span class="pre">anyregcc</span></code> convention may be used:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%val = call anyregcc @llvm.experimental.patchpoint(i64 78, i32 15,
                                                   i8* %target, i32 1,
                                                   i64* %ptr)
</pre></div>
</div>
<p>The stack map now indicates the location of the %ptr argument and
return value:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Stack Map: ID=78, Loc0=%r9 Loc1=%r8
</pre></div>
</div>
<p>The patch code sequence may now use the argument that happened to be
allocated in %r8 and return a value allocated in %r9:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x00 movslq 4(%r8) %r9              &lt;--- patched code at patch point address
0x03 nop
...
0x0e nop                            &lt;--- end of reserved 15-bytes
0x0f addq    $0x3, %r9
0x10 movl    %r9, 8(%rsp)
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="stack-map-format">
<span id="stackmap-format"></span><h2><a class="toc-backref" href="#id10">Stack Map Format</a><a class="headerlink" href="#stack-map-format" title="Permalink to this headline">¶</a></h2>
<p>The existence of a stack map or patch point intrinsic within an LLVM
Module forces code emission to create a <a class="reference internal" href="#stackmap-section"><span class="std std-ref">Stack Map Section</span></a>. The
format of this section follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Header {
  uint8  : Stack Map Version (current version is 3)
  uint8  : Reserved (expected to be 0)
  uint16 : Reserved (expected to be 0)
}
uint32 : NumFunctions
uint32 : NumConstants
uint32 : NumRecords
StkSizeRecord[NumFunctions] {
  uint64 : Function Address
  uint64 : Stack Size
  uint64 : Record Count
}
Constants[NumConstants] {
  uint64 : LargeConstant
}
StkMapRecord[NumRecords] {
  uint64 : PatchPoint ID
  uint32 : Instruction Offset
  uint16 : Reserved (record flags)
  uint16 : NumLocations
  Location[NumLocations] {
    uint8  : Register | Direct | Indirect | Constant | ConstantIndex
    uint8  : Reserved (expected to be 0)
    uint16 : Location Size
    uint16 : Dwarf RegNum
    uint16 : Reserved (expected to be 0)
    int32  : Offset or SmallConstant
  }
  uint32 : Padding (only if required to align to 8 byte)
  uint16 : Padding
  uint16 : NumLiveOuts
  LiveOuts[NumLiveOuts]
    uint16 : Dwarf RegNum
    uint8  : Reserved
    uint8  : Size in Bytes
  }
  uint32 : Padding (only if required to align to 8 byte)
}
</pre></div>
</div>
<p>The first byte of each location encodes a type that indicates how to
interpret the <code class="docutils literal notranslate"><span class="pre">RegNum</span></code> and <code class="docutils literal notranslate"><span class="pre">Offset</span></code> fields as follows:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 16%" />
<col style="width: 30%" />
<col style="width: 42%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Encoding</p></td>
<td><p>Type</p></td>
<td><p>Value</p></td>
<td><p>Description</p></td>
</tr>
<tr class="row-even"><td><p>0x1</p></td>
<td><p>Register</p></td>
<td><p>Reg</p></td>
<td><p>Value in a register</p></td>
</tr>
<tr class="row-odd"><td><p>0x2</p></td>
<td><p>Direct</p></td>
<td><p>Reg + Offset</p></td>
<td><p>Frame index value</p></td>
</tr>
<tr class="row-even"><td><p>0x3</p></td>
<td><p>Indirect</p></td>
<td><p>[Reg + Offset]</p></td>
<td><p>Spilled value</p></td>
</tr>
<tr class="row-odd"><td><p>0x4</p></td>
<td><p>Constant</p></td>
<td><p>Offset</p></td>
<td><p>Small constant</p></td>
</tr>
<tr class="row-even"><td><p>0x5</p></td>
<td><p>ConstIndex</p></td>
<td><p>Constants[Offset]</p></td>
<td><p>Large constant</p></td>
</tr>
</tbody>
</table>
<p>In the common case, a value is available in a register, and the
<code class="docutils literal notranslate"><span class="pre">Offset</span></code> field will be zero. Values spilled to the stack are encoded
as <code class="docutils literal notranslate"><span class="pre">Indirect</span></code> locations. The runtime must load those values from a
stack address, typically in the form <code class="docutils literal notranslate"><span class="pre">[BP</span> <span class="pre">+</span> <span class="pre">Offset]</span></code>. If an
<code class="docutils literal notranslate"><span class="pre">alloca</span></code> value is passed directly to a stack map intrinsic, then
LLVM may fold the frame index into the stack map as an optimization to
avoid allocating a register or stack slot. These frame indices will be
encoded as <code class="docutils literal notranslate"><span class="pre">Direct</span></code> locations in the form <code class="docutils literal notranslate"><span class="pre">BP</span> <span class="pre">+</span> <span class="pre">Offset</span></code>. LLVM may
also optimize constants by emitting them directly in the stack map,
either in the <code class="docutils literal notranslate"><span class="pre">Offset</span></code> of a <code class="docutils literal notranslate"><span class="pre">Constant</span></code> location or in the constant
pool, referred to by <code class="docutils literal notranslate"><span class="pre">ConstantIndex</span></code> locations.</p>
<p>At each callsite, a “liveout” register list is also recorded. These
are the registers that are live across the stackmap and therefore must
be saved by the runtime. This is an important optimization when the
patchpoint intrinsic is used with a calling convention that by default
preserves most registers as callee-save.</p>
<p>Each entry in the liveout register list contains a DWARF register
number and size in bytes. The stackmap format deliberately omits
specific subregister information. Instead the runtime must interpret
this information conservatively. For example, if the stackmap reports
one byte at <code class="docutils literal notranslate"><span class="pre">%rax</span></code>, then the value may be in either <code class="docutils literal notranslate"><span class="pre">%al</span></code> or
<code class="docutils literal notranslate"><span class="pre">%ah</span></code>. It doesn’t matter in practice, because the runtime will
simply save <code class="docutils literal notranslate"><span class="pre">%rax</span></code>. However, if the stackmap reports 16 bytes at
<code class="docutils literal notranslate"><span class="pre">%ymm0</span></code>, then the runtime can safely optimize by saving only
<code class="docutils literal notranslate"><span class="pre">%xmm0</span></code>.</p>
<p>The stack map format is a contract between an LLVM SVN revision and
the runtime. It is currently experimental and may change in the short
term, but minimizing the need to update the runtime is
important. Consequently, the stack map design is motivated by
simplicity and extensibility. Compactness of the representation is
secondary because the runtime is expected to parse the data
immediately after compiling a module and encode the information in its
own format. Since the runtime controls the allocation of sections, it
can reuse the same stack map space for multiple modules.</p>
<p>Stackmap support is currently only implemented for 64-bit
platforms. However, a 32-bit implementation should be able to use the
same format with an insignificant amount of wasted space.</p>
<div class="section" id="stack-map-section">
<span id="stackmap-section"></span><h3><a class="toc-backref" href="#id11">Stack Map Section</a><a class="headerlink" href="#stack-map-section" title="Permalink to this headline">¶</a></h3>
<p>A JIT compiler can easily access this section by providing its own
memory manager via the LLVM C API
<code class="docutils literal notranslate"><span class="pre">LLVMCreateSimpleMCJITMemoryManager()</span></code>. When creating the memory
manager, the JIT provides a callback:
<code class="docutils literal notranslate"><span class="pre">LLVMMemoryManagerAllocateDataSectionCallback()</span></code>. When LLVM creates
this section, it invokes the callback and passes the section name. The
JIT can record the in-memory address of the section at this time and
later parse it to recover the stack map data.</p>
<p>For MachO (e.g. on Darwin), the stack map section name is
“__llvm_stackmaps”. The segment name is “__LLVM_STACKMAPS”.</p>
<p>For ELF (e.g. on Linux), the stack map section name is
“.llvm_stackmaps”.  The segment name is “__LLVM_STACKMAPS”.</p>
</div>
</div>
<div class="section" id="stack-map-usage">
<h2><a class="toc-backref" href="#id12">Stack Map Usage</a><a class="headerlink" href="#stack-map-usage" title="Permalink to this headline">¶</a></h2>
<p>The stack map support described in this document can be used to
precisely determine the location of values at a specific position in
the code. LLVM does not maintain any mapping between those values and
any higher-level entity. The runtime must be able to interpret the
stack map record given only the ID, offset, and the order of the
locations, records, and functions, which LLVM preserves.</p>
<p>Note that this is quite different from the goal of debug information,
which is a best-effort attempt to track the location of named
variables at every instruction.</p>
<p>An important motivation for this design is to allow a runtime to
commandeer a stack frame when execution reaches an instruction address
associated with a stack map. The runtime must be able to rebuild a
stack frame and resume program execution using the information
provided by the stack map. For example, execution may resume in an
interpreter or a recompiled version of the same function.</p>
<p>This usage restricts LLVM optimization. Clearly, LLVM must not move
stores across a stack map. However, loads must also be handled
conservatively. If the load may trigger an exception, hoisting it
above a stack map could be invalid. For example, the runtime may
determine that a load is safe to execute without a type check given
the current state of the type system. If the type system changes while
some activation of the load’s function exists on the stack, the load
becomes unsafe. The runtime can prevent subsequent execution of that
load by immediately patching any stack map location that lies between
the current call site and the load (typically, the runtime would
simply patch all stack map locations to invalidate the function). If
the compiler had hoisted the load above the stack map, then the
program could crash before the runtime could take back control.</p>
<p>To enforce these semantics, stackmap and patchpoint intrinsics are
considered to potentially read and write all memory. This may limit
optimization more than some clients desire. This limitation may be
avoided by marking the call site as “readonly”. In the future we may
also allow meta-data to be added to the intrinsic call to express
aliasing, thereby allowing optimizations to hoist certain loads above
stack maps.</p>
<div class="section" id="direct-stack-map-entries">
<h3><a class="toc-backref" href="#id13">Direct Stack Map Entries</a><a class="headerlink" href="#direct-stack-map-entries" title="Permalink to this headline">¶</a></h3>
<p>As shown in <a class="reference internal" href="#stackmap-section"><span class="std std-ref">Stack Map Section</span></a>, a Direct stack map location
records the address of frame index. This address is itself the value
that the runtime requested. This differs from Indirect locations,
which refer to a stack locations from which the requested values must
be loaded. Direct locations can communicate the address if an alloca,
while Indirect locations handle register spills.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>entry:
  %a = alloca i64...
  llvm.experimental.stackmap(i64 &lt;ID&gt;, i32 &lt;shadowBytes&gt;, i64* %a)
</pre></div>
</div>
<p>The runtime can determine this alloca’s relative location on the
stack immediately after compilation, or at any time thereafter. This
differs from Register and Indirect locations, because the runtime can
only read the values in those locations when execution reaches the
instruction address of the stack map.</p>
<p>This functionality requires LLVM to treat entry-block allocas
specially when they are directly consumed by an intrinsics. (This is
the same requirement imposed by the llvm.gcroot intrinsic.) LLVM
transformations must not substitute the alloca with any intervening
value. This can be verified by the runtime simply by checking that the
stack map’s location is a Direct location type.</p>
</div>
</div>
<div class="section" id="supported-architectures">
<h2><a class="toc-backref" href="#id14">Supported Architectures</a><a class="headerlink" href="#supported-architectures" title="Permalink to this headline">¶</a></h2>
<p>Support for StackMap generation and the related intrinsics requires
some code for each backend.  Today, only a subset of LLVM’s backends
are supported.  The currently supported architectures are X86_64,
PowerPC, and Aarch64.</p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="InAlloca.html" title="Design and Usage of the InAlloca Attribute"
             >next</a> |</li>
        <li class="right" >
          <a href="AMDGPUInstructionNotation.html" title="AMDGPU Instructions Notation"
             >previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2003-2020, LLVM Project.
      Last updated on 2020-01-13.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.3.1.
    </div>
  </body>
</html>