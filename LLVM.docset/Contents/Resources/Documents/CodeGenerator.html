

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>The LLVM Target-Independent Code Generator &#8212; LLVM 9 documentation</title>
    <link rel="stylesheet" href="_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Exception Handling in LLVM" href="ExceptionHandling.html" />
    <link rel="prev" title="LLVM bugpoint tool: design and usage" href="Bugpoint.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="ExceptionHandling.html" title="Exception Handling in LLVM"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Bugpoint.html" title="LLVM bugpoint tool: design and usage"
             accesskey="P">previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-llvm-target-independent-code-generator">
<h1>The LLVM Target-Independent Code Generator<a class="headerlink" href="#the-llvm-target-independent-code-generator" title="Permalink to this headline">¶</a></h1>
<style>
  .unknown { background-color: #C0C0C0; text-align: center; }
  .unknown:before { content: "?" }
  .no { background-color: #C11B17 }
  .no:before { content: "N" }
  .partial { background-color: #F88017 }
  .yes { background-color: #0F0; }
  .yes:before { content: "Y" }
  .na { background-color: #6666FF; }
  .na:before { content: "N/A" }
</style><div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id8">Introduction</a></p>
<ul>
<li><p><a class="reference internal" href="#required-components-in-the-code-generator" id="id9">Required components in the code generator</a></p></li>
<li><p><a class="reference internal" href="#the-high-level-design-of-the-code-generator" id="id10">The high-level design of the code generator</a></p></li>
<li><p><a class="reference internal" href="#using-tablegen-for-target-description" id="id11">Using TableGen for target description</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#target-description-classes" id="id12">Target description classes</a></p>
<ul>
<li><p><a class="reference internal" href="#the-targetmachine-class" id="id13">The <code class="docutils literal notranslate"><span class="pre">TargetMachine</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#the-datalayout-class" id="id14">The <code class="docutils literal notranslate"><span class="pre">DataLayout</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#the-targetlowering-class" id="id15">The <code class="docutils literal notranslate"><span class="pre">TargetLowering</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#the-targetregisterinfo-class" id="id16">The <code class="docutils literal notranslate"><span class="pre">TargetRegisterInfo</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#the-targetinstrinfo-class" id="id17">The <code class="docutils literal notranslate"><span class="pre">TargetInstrInfo</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#the-targetframelowering-class" id="id18">The <code class="docutils literal notranslate"><span class="pre">TargetFrameLowering</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#the-targetsubtarget-class" id="id19">The <code class="docutils literal notranslate"><span class="pre">TargetSubtarget</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#the-targetjitinfo-class" id="id20">The <code class="docutils literal notranslate"><span class="pre">TargetJITInfo</span></code> class</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#machine-code-description-classes" id="id21">Machine code description classes</a></p>
<ul>
<li><p><a class="reference internal" href="#the-machineinstr-class" id="id22">The <code class="docutils literal notranslate"><span class="pre">MachineInstr</span></code> class</a></p>
<ul>
<li><p><a class="reference internal" href="#using-the-machineinstrbuilder-h-functions" id="id23">Using the <code class="docutils literal notranslate"><span class="pre">MachineInstrBuilder.h</span></code> functions</a></p></li>
<li><p><a class="reference internal" href="#fixed-preassigned-registers" id="id24">Fixed (preassigned) registers</a></p></li>
<li><p><a class="reference internal" href="#call-clobbered-registers" id="id25">Call-clobbered registers</a></p></li>
<li><p><a class="reference internal" href="#machine-code-in-ssa-form" id="id26">Machine code in SSA form</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-machinebasicblock-class" id="id27">The <code class="docutils literal notranslate"><span class="pre">MachineBasicBlock</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#the-machinefunction-class" id="id28">The <code class="docutils literal notranslate"><span class="pre">MachineFunction</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#machineinstr-bundles" id="id29"><code class="docutils literal notranslate"><span class="pre">MachineInstr</span> <span class="pre">Bundles</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-mc-layer" id="id30">The “MC” Layer</a></p>
<ul>
<li><p><a class="reference internal" href="#the-mcstreamer-api" id="id31">The <code class="docutils literal notranslate"><span class="pre">MCStreamer</span></code> API</a></p></li>
<li><p><a class="reference internal" href="#the-mccontext-class" id="id32">The <code class="docutils literal notranslate"><span class="pre">MCContext</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#the-mcsymbol-class" id="id33">The <code class="docutils literal notranslate"><span class="pre">MCSymbol</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#the-mcsection-class" id="id34">The <code class="docutils literal notranslate"><span class="pre">MCSection</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#the-mcinst-class" id="id35">The <code class="docutils literal notranslate"><span class="pre">MCInst</span></code> class</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#target-independent-code-generation-algorithms" id="id36">Target-independent code generation algorithms</a></p>
<ul>
<li><p><a class="reference internal" href="#instruction-selection-section" id="id37">Instruction Selection</a></p>
<ul>
<li><p><a class="reference internal" href="#introduction-to-selectiondags" id="id38">Introduction to SelectionDAGs</a></p></li>
<li><p><a class="reference internal" href="#selectiondag-instruction-selection-process" id="id39">SelectionDAG Instruction Selection Process</a></p></li>
<li><p><a class="reference internal" href="#initial-selectiondag-construction" id="id40">Initial SelectionDAG Construction</a></p></li>
<li><p><a class="reference internal" href="#selectiondag-legalizetypes-phase" id="id41">SelectionDAG LegalizeTypes Phase</a></p></li>
<li><p><a class="reference internal" href="#selectiondag-legalize-phase" id="id42">SelectionDAG Legalize Phase</a></p></li>
<li><p><a class="reference internal" href="#selectiondag-optimization-phase-the-dag-combiner" id="id43">SelectionDAG Optimization Phase: the DAG Combiner</a></p></li>
<li><p><a class="reference internal" href="#selectiondag-select-phase" id="id44">SelectionDAG Select Phase</a></p></li>
<li><p><a class="reference internal" href="#selectiondag-scheduling-and-formation-phase" id="id45">SelectionDAG Scheduling and Formation Phase</a></p></li>
<li><p><a class="reference internal" href="#future-directions-for-the-selectiondag" id="id46">Future directions for the SelectionDAG</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#ssa-based-machine-code-optimizations" id="id47">SSA-based Machine Code Optimizations</a></p></li>
<li><p><a class="reference internal" href="#live-intervals" id="id48">Live Intervals</a></p>
<ul>
<li><p><a class="reference internal" href="#live-variable-analysis" id="id49">Live Variable Analysis</a></p></li>
<li><p><a class="reference internal" href="#live-intervals-analysis" id="id50">Live Intervals Analysis</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#register-allocator" id="id51">Register Allocation</a></p>
<ul>
<li><p><a class="reference internal" href="#how-registers-are-represented-in-llvm" id="id52">How registers are represented in LLVM</a></p></li>
<li><p><a class="reference internal" href="#mapping-virtual-registers-to-physical-registers" id="id53">Mapping virtual registers to physical registers</a></p></li>
<li><p><a class="reference internal" href="#handling-two-address-instructions" id="id54">Handling two address instructions</a></p></li>
<li><p><a class="reference internal" href="#the-ssa-deconstruction-phase" id="id55">The SSA deconstruction phase</a></p></li>
<li><p><a class="reference internal" href="#instruction-folding" id="id56">Instruction folding</a></p></li>
<li><p><a class="reference internal" href="#built-in-register-allocators" id="id57">Built in register allocators</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#prolog-epilog-code-insertion" id="id58">Prolog/Epilog Code Insertion</a></p></li>
<li><p><a class="reference internal" href="#late-machine-code-optimizations" id="id59">Late Machine Code Optimizations</a></p></li>
<li><p><a class="reference internal" href="#code-emission" id="id60">Code Emission</a></p>
<ul>
<li><p><a class="reference internal" href="#emitting-function-stack-size-information" id="id61">Emitting function stack size information</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#vliw-packetizer" id="id62">VLIW Packetizer</a></p>
<ul>
<li><p><a class="reference internal" href="#mapping-from-instructions-to-functional-units" id="id63">Mapping from instructions to functional units</a></p></li>
<li><p><a class="reference internal" href="#how-the-packetization-tables-are-generated-and-used" id="id64">How the packetization tables are generated and used</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#implementing-a-native-assembler" id="id65">Implementing a Native Assembler</a></p>
<ul>
<li><p><a class="reference internal" href="#instruction-parsing" id="id66">Instruction Parsing</a></p></li>
<li><p><a class="reference internal" href="#instruction-alias-processing" id="id67">Instruction Alias Processing</a></p>
<ul>
<li><p><a class="reference internal" href="#mnemonic-aliases" id="id68">Mnemonic Aliases</a></p></li>
<li><p><a class="reference internal" href="#instruction-aliases" id="id69">Instruction Aliases</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#instruction-matching" id="id70">Instruction Matching</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#target-specific-implementation-notes" id="id71">Target-specific Implementation Notes</a></p>
<ul>
<li><p><a class="reference internal" href="#target-feature-matrix" id="id72">Target Feature Matrix</a></p>
<ul>
<li><p><a class="reference internal" href="#is-generally-reliable" id="id73">Is Generally Reliable</a></p></li>
<li><p><a class="reference internal" href="#assembly-parser" id="id74">Assembly Parser</a></p></li>
<li><p><a class="reference internal" href="#disassembler" id="id75">Disassembler</a></p></li>
<li><p><a class="reference internal" href="#inline-asm" id="id76">Inline Asm</a></p></li>
<li><p><a class="reference internal" href="#jit-support" id="id77">JIT Support</a></p></li>
<li><p><a class="reference internal" href="#o-file-writing" id="id78">.o File Writing</a></p></li>
<li><p><a class="reference internal" href="#tail-calls" id="id79">Tail Calls</a></p></li>
<li><p><a class="reference internal" href="#segmented-stacks" id="id80">Segmented Stacks</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#tail-call-optimization" id="id81">Tail call optimization</a></p></li>
<li><p><a class="reference internal" href="#sibling-call-optimization" id="id82">Sibling call optimization</a></p></li>
<li><p><a class="reference internal" href="#the-x86-backend" id="id83">The X86 backend</a></p>
<ul>
<li><p><a class="reference internal" href="#x86-target-triples-supported" id="id84">X86 Target Triples supported</a></p></li>
<li><p><a class="reference internal" href="#x86-calling-conventions-supported" id="id85">X86 Calling Conventions supported</a></p></li>
<li><p><a class="reference internal" href="#representing-x86-addressing-modes-in-machineinstrs" id="id86">Representing X86 addressing modes in MachineInstrs</a></p></li>
<li><p><a class="reference internal" href="#x86-address-spaces-supported" id="id87">X86 address spaces supported</a></p></li>
<li><p><a class="reference internal" href="#instruction-naming" id="id88">Instruction naming</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-powerpc-backend" id="id89">The PowerPC backend</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-powerpc-abi" id="id90">LLVM PowerPC ABI</a></p></li>
<li><p><a class="reference internal" href="#frame-layout" id="id91">Frame Layout</a></p></li>
<li><p><a class="reference internal" href="#prolog-epilog" id="id92">Prolog/Epilog</a></p></li>
<li><p><a class="reference internal" href="#dynamic-allocation" id="id93">Dynamic Allocation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-nvptx-backend" id="id94">The NVPTX backend</a></p></li>
<li><p><a class="reference internal" href="#the-extended-berkeley-packet-filter-ebpf-backend" id="id95">The extended Berkeley Packet Filter (eBPF) backend</a></p>
<ul>
<li><p><a class="reference internal" href="#instruction-encoding-arithmetic-and-jump" id="id96">Instruction encoding (arithmetic and jump)</a></p></li>
<li><p><a class="reference internal" href="#instruction-encoding-load-store" id="id97">Instruction encoding (load, store)</a></p></li>
<li><p><a class="reference internal" href="#packet-data-access-bpf-abs-bpf-ind" id="id98">Packet data access (BPF_ABS, BPF_IND)</a></p></li>
<li><p><a class="reference internal" href="#ebpf-maps" id="id99">eBPF maps</a></p></li>
<li><p><a class="reference internal" href="#function-calls" id="id100">Function calls</a></p></li>
<li><p><a class="reference internal" href="#program-start" id="id101">Program start</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-amdgpu-backend" id="id102">The AMDGPU backend</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is a work in progress.</p>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id8">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The LLVM target-independent code generator is a framework that provides a suite
of reusable components for translating the LLVM internal representation to the
machine code for a specified target—either in assembly form (suitable for a
static compiler) or in binary machine code format (usable for a JIT
compiler). The LLVM target-independent code generator consists of six main
components:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#abstract-target-description">Abstract target description</a> interfaces which capture important properties
about various aspects of the machine, independently of how they will be used.
These interfaces are defined in <code class="docutils literal notranslate"><span class="pre">include/llvm/Target/</span></code>.</p></li>
<li><p>Classes used to represent the <a class="reference internal" href="#code-being-generated">code being generated</a> for a target.  These
classes are intended to be abstract enough to represent the machine code for
<em>any</em> target machine.  These classes are defined in
<code class="docutils literal notranslate"><span class="pre">include/llvm/CodeGen/</span></code>. At this level, concepts like “constant pool
entries” and “jump tables” are explicitly exposed.</p></li>
<li><p>Classes and algorithms used to represent code at the object file level, the
<a class="reference internal" href="#mc-layer">MC Layer</a>.  These classes represent assembly level constructs like labels,
sections, and instructions.  At this level, concepts like “constant pool
entries” and “jump tables” don’t exist.</p></li>
<li><p><a class="reference internal" href="#target-independent-algorithms">Target-independent algorithms</a> used to implement various phases of native
code generation (register allocation, scheduling, stack frame representation,
etc).  This code lives in <code class="docutils literal notranslate"><span class="pre">lib/CodeGen/</span></code>.</p></li>
<li><p><a class="reference internal" href="#implementations-of-the-abstract-target-description-interfaces">Implementations of the abstract target description interfaces</a> for
particular targets.  These machine descriptions make use of the components
provided by LLVM, and can optionally provide custom target-specific passes,
to build complete code generators for a specific target.  Target descriptions
live in <code class="docutils literal notranslate"><span class="pre">lib/Target/</span></code>.</p></li>
<li><p>The target-independent JIT components.  The LLVM JIT is completely target
independent (it uses the <code class="docutils literal notranslate"><span class="pre">TargetJITInfo</span></code> structure to interface for
target-specific issues.  The code for the target-independent JIT lives in
<code class="docutils literal notranslate"><span class="pre">lib/ExecutionEngine/JIT</span></code>.</p></li>
</ol>
<p>Depending on which part of the code generator you are interested in working on,
different pieces of this will be useful to you.  In any case, you should be
familiar with the <a class="reference internal" href="#target-description">target description</a> and <a class="reference internal" href="#machine-code-representation">machine code representation</a>
classes.  If you want to add a backend for a new target, you will need to
<a class="reference internal" href="#implement-the-target-description">implement the target description</a> classes for your new target and understand
the <a class="reference internal" href="LangRef.html"><span class="doc">LLVM code representation</span></a>.  If you are interested in
implementing a new <a class="reference internal" href="#code-generation-algorithm">code generation algorithm</a>, it should only depend on the
target-description and machine code representation classes, ensuring that it is
portable.</p>
<div class="section" id="required-components-in-the-code-generator">
<h3><a class="toc-backref" href="#id9">Required components in the code generator</a><a class="headerlink" href="#required-components-in-the-code-generator" title="Permalink to this headline">¶</a></h3>
<p>The two pieces of the LLVM code generator are the high-level interface to the
code generator and the set of reusable components that can be used to build
target-specific backends.  The two most important interfaces (<span class="raw-html"><tt></span>
<a class="reference internal" href="#targetmachine">TargetMachine</a> <span class="raw-html"></tt></span> and <span class="raw-html"><tt></span> <a class="reference internal" href="#datalayout">DataLayout</a>
<span class="raw-html"></tt></span>) are the only ones that are required to be defined for a
backend to fit into the LLVM system, but the others must be defined if the
reusable code generator components are going to be used.</p>
<p>This design has two important implications.  The first is that LLVM can support
completely non-traditional code generation targets.  For example, the C backend
does not require register allocation, instruction selection, or any of the other
standard components provided by the system.  As such, it only implements these
two interfaces, and does its own thing. Note that C backend was removed from the
trunk since LLVM 3.1 release. Another example of a code generator like this is a
(purely hypothetical) backend that converts LLVM to the GCC RTL form and uses
GCC to emit machine code for a target.</p>
<p>This design also implies that it is possible to design and implement radically
different code generators in the LLVM system that do not make use of any of the
built-in components.  Doing so is not recommended at all, but could be required
for radically different targets that do not fit into the LLVM machine
description model: FPGAs for example.</p>
</div>
<div class="section" id="the-high-level-design-of-the-code-generator">
<span id="high-level-design-of-the-code-generator"></span><h3><a class="toc-backref" href="#id10">The high-level design of the code generator</a><a class="headerlink" href="#the-high-level-design-of-the-code-generator" title="Permalink to this headline">¶</a></h3>
<p>The LLVM target-independent code generator is designed to support efficient and
quality code generation for standard register-based microprocessors.  Code
generation in this model is divided into the following stages:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#instruction-selection">Instruction Selection</a> — This phase determines an efficient way to
express the input LLVM code in the target instruction set.  This stage
produces the initial code for the program in the target instruction set, then
makes use of virtual registers in SSA form and physical registers that
represent any required register assignments due to target constraints or
calling conventions.  This step turns the LLVM code into a DAG of target
instructions.</p></li>
<li><p><a class="reference internal" href="#scheduling-and-formation">Scheduling and Formation</a> — This phase takes the DAG of target
instructions produced by the instruction selection phase, determines an
ordering of the instructions, then emits the instructions as <span class="raw-html"><tt></span>
<a class="reference internal" href="#machineinstr">MachineInstr</a>s <span class="raw-html"></tt></span> with that ordering.  Note that we
describe this in the <a class="reference internal" href="#instruction-selection-section">instruction selection section</a> because it operates on
a <a class="reference internal" href="#selectiondag">SelectionDAG</a>.</p></li>
<li><p><a class="reference internal" href="#ssa-based-machine-code-optimizations">SSA-based Machine Code Optimizations</a> — This optional stage consists of a
series of machine-code optimizations that operate on the SSA-form produced by
the instruction selector.  Optimizations like modulo-scheduling or peephole
optimization work here.</p></li>
<li><p><a class="reference internal" href="#register-allocation">Register Allocation</a> — The target code is transformed from an infinite
virtual register file in SSA form to the concrete register file used by the
target.  This phase introduces spill code and eliminates all virtual register
references from the program.</p></li>
<li><p><a class="reference internal" href="#prolog-epilog-code-insertion">Prolog/Epilog Code Insertion</a> — Once the machine code has been generated
for the function and the amount of stack space required is known (used for
LLVM alloca’s and spill slots), the prolog and epilog code for the function
can be inserted and “abstract stack location references” can be eliminated.
This stage is responsible for implementing optimizations like frame-pointer
elimination and stack packing.</p></li>
<li><p><a class="reference internal" href="#late-machine-code-optimizations">Late Machine Code Optimizations</a> — Optimizations that operate on “final”
machine code can go here, such as spill code scheduling and peephole
optimizations.</p></li>
<li><p><a class="reference internal" href="#code-emission">Code Emission</a> — The final stage actually puts out the code for the
current function, either in the target assembler format or in machine
code.</p></li>
</ol>
<p>The code generator is based on the assumption that the instruction selector will
use an optimal pattern matching selector to create high-quality sequences of
native instructions.  Alternative code generator designs based on pattern
expansion and aggressive iterative peephole optimization are much slower.  This
design permits efficient compilation (important for JIT environments) and
aggressive optimization (used when generating code offline) by allowing
components of varying levels of sophistication to be used for any step of
compilation.</p>
<p>In addition to these stages, target implementations can insert arbitrary
target-specific passes into the flow.  For example, the X86 target uses a
special pass to handle the 80x87 floating point stack architecture.  Other
targets with unusual requirements can be supported with custom passes as needed.</p>
</div>
<div class="section" id="using-tablegen-for-target-description">
<h3><a class="toc-backref" href="#id11">Using TableGen for target description</a><a class="headerlink" href="#using-tablegen-for-target-description" title="Permalink to this headline">¶</a></h3>
<p>The target description classes require a detailed description of the target
architecture.  These target descriptions often have a large amount of common
information (e.g., an <code class="docutils literal notranslate"><span class="pre">add</span></code> instruction is almost identical to a <code class="docutils literal notranslate"><span class="pre">sub</span></code>
instruction).  In order to allow the maximum amount of commonality to be
factored out, the LLVM code generator uses the
<a class="reference internal" href="TableGen/index.html"><span class="doc">TableGen</span></a> tool to describe big chunks of the
target machine, which allows the use of domain-specific and target-specific
abstractions to reduce the amount of repetition.</p>
<p>As LLVM continues to be developed and refined, we plan to move more and more of
the target description to the <code class="docutils literal notranslate"><span class="pre">.td</span></code> form.  Doing so gives us a number of
advantages.  The most important is that it makes it easier to port LLVM because
it reduces the amount of C++ code that has to be written, and the surface area
of the code generator that needs to be understood before someone can get
something working.  Second, it makes it easier to change things. In particular,
if tables and other things are all emitted by <code class="docutils literal notranslate"><span class="pre">tblgen</span></code>, we only need a change
in one place (<code class="docutils literal notranslate"><span class="pre">tblgen</span></code>) to update all of the targets to a new interface.</p>
</div>
</div>
<div class="section" id="target-description-classes">
<span id="target-description"></span><span id="abstract-target-description"></span><h2><a class="toc-backref" href="#id12">Target description classes</a><a class="headerlink" href="#target-description-classes" title="Permalink to this headline">¶</a></h2>
<p>The LLVM target description classes (located in the <code class="docutils literal notranslate"><span class="pre">include/llvm/Target</span></code>
directory) provide an abstract description of the target machine independent of
any particular client.  These classes are designed to capture the <em>abstract</em>
properties of the target (such as the instructions and registers it has), and do
not incorporate any particular pieces of code generation algorithms.</p>
<p>All of the target description classes (except the <span class="raw-html"><tt></span> <a class="reference internal" href="#datalayout">DataLayout</a>
<span class="raw-html"></tt></span> class) are designed to be subclassed by the concrete target
implementation, and have virtual methods implemented.  To get to these
implementations, the <span class="raw-html"><tt></span> <a class="reference internal" href="#targetmachine">TargetMachine</a> <span class="raw-html"></tt></span> class
provides accessors that should be implemented by the target.</p>
<div class="section" id="the-targetmachine-class">
<span id="targetmachine"></span><h3><a class="toc-backref" href="#id13">The <code class="docutils literal notranslate"><span class="pre">TargetMachine</span></code> class</a><a class="headerlink" href="#the-targetmachine-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">TargetMachine</span></code> class provides virtual methods that are used to access the
target-specific implementations of the various target description classes via
the <code class="docutils literal notranslate"><span class="pre">get*Info</span></code> methods (<code class="docutils literal notranslate"><span class="pre">getInstrInfo</span></code>, <code class="docutils literal notranslate"><span class="pre">getRegisterInfo</span></code>,
<code class="docutils literal notranslate"><span class="pre">getFrameInfo</span></code>, etc.).  This class is designed to be specialized by a concrete
target implementation (e.g., <code class="docutils literal notranslate"><span class="pre">X86TargetMachine</span></code>) which implements the various
virtual methods.  The only required target description class is the
<span class="raw-html"><tt></span> <a class="reference internal" href="#datalayout">DataLayout</a> <span class="raw-html"></tt></span> class, but if the code
generator components are to be used, the other interfaces should be implemented
as well.</p>
</div>
<div class="section" id="the-datalayout-class">
<span id="datalayout"></span><h3><a class="toc-backref" href="#id14">The <code class="docutils literal notranslate"><span class="pre">DataLayout</span></code> class</a><a class="headerlink" href="#the-datalayout-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">DataLayout</span></code> class is the only required target description class, and it
is the only class that is not extensible (you cannot derive a new class from
it).  <code class="docutils literal notranslate"><span class="pre">DataLayout</span></code> specifies information about how the target lays out memory
for structures, the alignment requirements for various data types, the size of
pointers in the target, and whether the target is little-endian or
big-endian.</p>
</div>
<div class="section" id="the-targetlowering-class">
<span id="targetlowering"></span><h3><a class="toc-backref" href="#id15">The <code class="docutils literal notranslate"><span class="pre">TargetLowering</span></code> class</a><a class="headerlink" href="#the-targetlowering-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">TargetLowering</span></code> class is used by SelectionDAG based instruction selectors
primarily to describe how LLVM code should be lowered to SelectionDAG
operations.  Among other things, this class indicates:</p>
<ul class="simple">
<li><p>an initial register class to use for various <code class="docutils literal notranslate"><span class="pre">ValueType</span></code>s,</p></li>
<li><p>which operations are natively supported by the target machine,</p></li>
<li><p>the return type of <code class="docutils literal notranslate"><span class="pre">setcc</span></code> operations,</p></li>
<li><p>the type to use for shift amounts, and</p></li>
<li><p>various high-level characteristics, like whether it is profitable to turn
division by a constant into a multiplication sequence.</p></li>
</ul>
</div>
<div class="section" id="the-targetregisterinfo-class">
<span id="targetregisterinfo"></span><h3><a class="toc-backref" href="#id16">The <code class="docutils literal notranslate"><span class="pre">TargetRegisterInfo</span></code> class</a><a class="headerlink" href="#the-targetregisterinfo-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">TargetRegisterInfo</span></code> class is used to describe the register file of the
target and any interactions between the registers.</p>
<p>Registers are represented in the code generator by unsigned integers.  Physical
registers (those that actually exist in the target description) are unique
small numbers, and virtual registers are generally large.  Note that
register <code class="docutils literal notranslate"><span class="pre">#0</span></code> is reserved as a flag value.</p>
<p>Each register in the processor description has an associated
<code class="docutils literal notranslate"><span class="pre">TargetRegisterDesc</span></code> entry, which provides a textual name for the register
(used for assembly output and debugging dumps) and a set of aliases (used to
indicate whether one register overlaps with another).</p>
<p>In addition to the per-register description, the <code class="docutils literal notranslate"><span class="pre">TargetRegisterInfo</span></code> class
exposes a set of processor specific register classes (instances of the
<code class="docutils literal notranslate"><span class="pre">TargetRegisterClass</span></code> class).  Each register class contains sets of registers
that have the same properties (for example, they are all 32-bit integer
registers).  Each SSA virtual register created by the instruction selector has
an associated register class.  When the register allocator runs, it replaces
virtual registers with a physical register in the set.</p>
<p>The target-specific implementations of these classes is auto-generated from a
<a class="reference internal" href="TableGen/index.html"><span class="doc">TableGen</span></a> description of the register file.</p>
</div>
<div class="section" id="the-targetinstrinfo-class">
<span id="targetinstrinfo"></span><h3><a class="toc-backref" href="#id17">The <code class="docutils literal notranslate"><span class="pre">TargetInstrInfo</span></code> class</a><a class="headerlink" href="#the-targetinstrinfo-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">TargetInstrInfo</span></code> class is used to describe the machine instructions
supported by the target.  Descriptions define things like the mnemonic for
the opcode, the number of operands, the list of implicit register uses and defs,
whether the instruction has certain target-independent properties (accesses
memory, is commutable, etc), and holds any target-specific flags.</p>
</div>
<div class="section" id="the-targetframelowering-class">
<h3><a class="toc-backref" href="#id18">The <code class="docutils literal notranslate"><span class="pre">TargetFrameLowering</span></code> class</a><a class="headerlink" href="#the-targetframelowering-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">TargetFrameLowering</span></code> class is used to provide information about the stack
frame layout of the target. It holds the direction of stack growth, the known
stack alignment on entry to each function, and the offset to the local area.
The offset to the local area is the offset from the stack pointer on function
entry to the first location where function data (local variables, spill
locations) can be stored.</p>
</div>
<div class="section" id="the-targetsubtarget-class">
<h3><a class="toc-backref" href="#id19">The <code class="docutils literal notranslate"><span class="pre">TargetSubtarget</span></code> class</a><a class="headerlink" href="#the-targetsubtarget-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">TargetSubtarget</span></code> class is used to provide information about the specific
chip set being targeted.  A sub-target informs code generation of which
instructions are supported, instruction latencies and instruction execution
itinerary; i.e., which processing units are used, in what order, and for how
long.</p>
</div>
<div class="section" id="the-targetjitinfo-class">
<h3><a class="toc-backref" href="#id20">The <code class="docutils literal notranslate"><span class="pre">TargetJITInfo</span></code> class</a><a class="headerlink" href="#the-targetjitinfo-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">TargetJITInfo</span></code> class exposes an abstract interface used by the
Just-In-Time code generator to perform target-specific activities, such as
emitting stubs.  If a <code class="docutils literal notranslate"><span class="pre">TargetMachine</span></code> supports JIT code generation, it should
provide one of these objects through the <code class="docutils literal notranslate"><span class="pre">getJITInfo</span></code> method.</p>
</div>
</div>
<div class="section" id="machine-code-description-classes">
<span id="machine-code-representation"></span><span id="code-being-generated"></span><h2><a class="toc-backref" href="#id21">Machine code description classes</a><a class="headerlink" href="#machine-code-description-classes" title="Permalink to this headline">¶</a></h2>
<p>At the high-level, LLVM code is translated to a machine specific representation
formed out of <span class="raw-html"><tt></span> <a class="reference internal" href="#machinefunction">MachineFunction</a> <span class="raw-html"></tt></span>,
<span class="raw-html"><tt></span> <a class="reference internal" href="#machinebasicblock">MachineBasicBlock</a> <span class="raw-html"></tt></span>, and <span class="raw-html"><tt></span>
<a class="reference internal" href="#machineinstr">MachineInstr</a> <span class="raw-html"></tt></span> instances (defined in
<code class="docutils literal notranslate"><span class="pre">include/llvm/CodeGen</span></code>).  This representation is completely target agnostic,
representing instructions in their most abstract form: an opcode and a series of
operands.  This representation is designed to support both an SSA representation
for machine code, as well as a register allocated, non-SSA form.</p>
<div class="section" id="the-machineinstr-class">
<span id="machineinstr"></span><h3><a class="toc-backref" href="#id22">The <code class="docutils literal notranslate"><span class="pre">MachineInstr</span></code> class</a><a class="headerlink" href="#the-machineinstr-class" title="Permalink to this headline">¶</a></h3>
<p>Target machine instructions are represented as instances of the <code class="docutils literal notranslate"><span class="pre">MachineInstr</span></code>
class.  This class is an extremely abstract way of representing machine
instructions.  In particular, it only keeps track of an opcode number and a set
of operands.</p>
<p>The opcode number is a simple unsigned integer that only has meaning to a
specific backend.  All of the instructions for a target should be defined in the
<code class="docutils literal notranslate"><span class="pre">*InstrInfo.td</span></code> file for the target. The opcode enum values are auto-generated
from this description.  The <code class="docutils literal notranslate"><span class="pre">MachineInstr</span></code> class does not have any information
about how to interpret the instruction (i.e., what the semantics of the
instruction are); for that you must refer to the <span class="raw-html"><tt></span>
<a class="reference internal" href="#targetinstrinfo">TargetInstrInfo</a> <span class="raw-html"></tt></span> class.</p>
<p>The operands of a machine instruction can be of several different types: a
register reference, a constant integer, a basic block reference, etc.  In
addition, a machine operand should be marked as a def or a use of the value
(though only registers are allowed to be defs).</p>
<p>By convention, the LLVM code generator orders instruction operands so that all
register definitions come before the register uses, even on architectures that
are normally printed in other orders.  For example, the SPARC add instruction:
“<code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">%i1,</span> <span class="pre">%i2,</span> <span class="pre">%i3</span></code>” adds the “%i1”, and “%i2” registers and stores the
result into the “%i3” register.  In the LLVM code generator, the operands should
be stored as “<code class="docutils literal notranslate"><span class="pre">%i3,</span> <span class="pre">%i1,</span> <span class="pre">%i2</span></code>”: with the destination first.</p>
<p>Keeping destination (definition) operands at the beginning of the operand list
has several advantages.  In particular, the debugging printer will print the
instruction like this:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">%r3</span> <span class="p">=</span> <span class="k">add</span> <span class="nv">%i1</span><span class="p">,</span> <span class="nv">%i2</span>
</pre></div>
</div>
<p>Also if the first operand is a def, it is easier to <a class="reference internal" href="#create-instructions">create instructions</a> whose
only def is the first operand.</p>
<div class="section" id="using-the-machineinstrbuilder-h-functions">
<span id="create-instructions"></span><h4><a class="toc-backref" href="#id23">Using the <code class="docutils literal notranslate"><span class="pre">MachineInstrBuilder.h</span></code> functions</a><a class="headerlink" href="#using-the-machineinstrbuilder-h-functions" title="Permalink to this headline">¶</a></h4>
<p>Machine instructions are created by using the <code class="docutils literal notranslate"><span class="pre">BuildMI</span></code> functions, located in
the <code class="docutils literal notranslate"><span class="pre">include/llvm/CodeGen/MachineInstrBuilder.h</span></code> file.  The <code class="docutils literal notranslate"><span class="pre">BuildMI</span></code>
functions make it easy to build arbitrary machine instructions.  Usage of the
<code class="docutils literal notranslate"><span class="pre">BuildMI</span></code> functions look like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create a &#39;DestReg = mov 42&#39; (rendered in X86 assembly as &#39;mov DestReg, 42&#39;)</span>
<span class="c1">// instruction and insert it at the end of the given MachineBasicBlock.</span>
<span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">&amp;</span><span class="n">TII</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">DebugLoc</span> <span class="n">DL</span><span class="p">;</span>
<span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span> <span class="o">=</span> <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">X86</span><span class="o">::</span><span class="n">MOV32ri</span><span class="p">),</span> <span class="n">DestReg</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>

<span class="c1">// Create the same instr, but insert it before a specified iterator point.</span>
<span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MBBI</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">X86</span><span class="o">::</span><span class="n">MOV32ri</span><span class="p">),</span> <span class="n">DestReg</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>

<span class="c1">// Create a &#39;cmp Reg, 0&#39; instruction, no destination reg.</span>
<span class="n">MI</span> <span class="o">=</span> <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">X86</span><span class="o">::</span><span class="n">CMP32ri8</span><span class="p">)).</span><span class="n">addReg</span><span class="p">(</span><span class="n">Reg</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>

<span class="c1">// Create an &#39;sahf&#39; instruction which takes no operands and stores nothing.</span>
<span class="n">MI</span> <span class="o">=</span> <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">X86</span><span class="o">::</span><span class="n">SAHF</span><span class="p">));</span>

<span class="c1">// Create a self looping branch instruction.</span>
<span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">X86</span><span class="o">::</span><span class="n">JNE</span><span class="p">)).</span><span class="n">addMBB</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MBB</span><span class="p">);</span>
</pre></div>
</div>
<p>If you need to add a definition operand (other than the optional destination
register), you must explicitly mark it as such:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MI</span><span class="p">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">Reg</span><span class="p">,</span> <span class="n">RegState</span><span class="o">::</span><span class="n">Define</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="fixed-preassigned-registers">
<h4><a class="toc-backref" href="#id24">Fixed (preassigned) registers</a><a class="headerlink" href="#fixed-preassigned-registers" title="Permalink to this headline">¶</a></h4>
<p>One important issue that the code generator needs to be aware of is the presence
of fixed registers.  In particular, there are often places in the instruction
stream where the register allocator <em>must</em> arrange for a particular value to be
in a particular register.  This can occur due to limitations of the instruction
set (e.g., the X86 can only do a 32-bit divide with the <code class="docutils literal notranslate"><span class="pre">EAX</span></code>/<code class="docutils literal notranslate"><span class="pre">EDX</span></code>
registers), or external factors like calling conventions.  In any case, the
instruction selector should emit code that copies a virtual register into or out
of a physical register when needed.</p>
<p>For example, consider this simple LLVM example:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="k">i32</span> <span class="vg">@test</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%X</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%Y</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%Z</span> <span class="p">=</span> <span class="k">sdiv</span> <span class="k">i32</span> <span class="nv">%X</span><span class="p">,</span> <span class="nv">%Y</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="nv">%Z</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The X86 instruction selector might produce this machine code for the <code class="docutils literal notranslate"><span class="pre">div</span></code> and
<code class="docutils literal notranslate"><span class="pre">ret</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>;; Start of div
%EAX = mov %reg1024           ;; Copy X (in reg1024) into EAX
%reg1027 = sar %reg1024, 31
%EDX = mov %reg1027           ;; Sign extend X into EDX
idiv %reg1025                 ;; Divide by Y (in reg1025)
%reg1026 = mov %EAX           ;; Read the result (Z) out of EAX

;; Start of ret
%EAX = mov %reg1026           ;; 32-bit return value goes in EAX
ret
</pre></div>
</div>
<p>By the end of code generation, the register allocator would coalesce the
registers and delete the resultant identity moves producing the following
code:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>;; X is in EAX, Y is in ECX
mov %EAX, %EDX
sar %EDX, 31
idiv %ECX
ret
</pre></div>
</div>
<p>This approach is extremely general (if it can handle the X86 architecture, it
can handle anything!) and allows all of the target specific knowledge about the
instruction stream to be isolated in the instruction selector.  Note that
physical registers should have a short lifetime for good code generation, and
all physical registers are assumed dead on entry to and exit from basic blocks
(before register allocation).  Thus, if you need a value to be live across basic
block boundaries, it <em>must</em> live in a virtual register.</p>
</div>
<div class="section" id="call-clobbered-registers">
<h4><a class="toc-backref" href="#id25">Call-clobbered registers</a><a class="headerlink" href="#call-clobbered-registers" title="Permalink to this headline">¶</a></h4>
<p>Some machine instructions, like calls, clobber a large number of physical
registers.  Rather than adding <code class="docutils literal notranslate"><span class="pre">&lt;def,dead&gt;</span></code> operands for all of them, it is
possible to use an <code class="docutils literal notranslate"><span class="pre">MO_RegisterMask</span></code> operand instead.  The register mask
operand holds a bit mask of preserved registers, and everything else is
considered to be clobbered by the instruction.</p>
</div>
<div class="section" id="machine-code-in-ssa-form">
<h4><a class="toc-backref" href="#id26">Machine code in SSA form</a><a class="headerlink" href="#machine-code-in-ssa-form" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">MachineInstr</span></code>’s are initially selected in SSA-form, and are maintained in
SSA-form until register allocation happens.  For the most part, this is
trivially simple since LLVM is already in SSA form; LLVM PHI nodes become
machine code PHI nodes, and virtual registers are only allowed to have a single
definition.</p>
<p>After register allocation, machine code is no longer in SSA-form because there
are no virtual registers left in the code.</p>
</div>
</div>
<div class="section" id="the-machinebasicblock-class">
<span id="machinebasicblock"></span><h3><a class="toc-backref" href="#id27">The <code class="docutils literal notranslate"><span class="pre">MachineBasicBlock</span></code> class</a><a class="headerlink" href="#the-machinebasicblock-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">MachineBasicBlock</span></code> class contains a list of machine instructions
(<span class="raw-html"><tt></span> <a class="reference internal" href="#machineinstr">MachineInstr</a> <span class="raw-html"></tt></span> instances).  It roughly
corresponds to the LLVM code input to the instruction selector, but there can be
a one-to-many mapping (i.e. one LLVM basic block can map to multiple machine
basic blocks). The <code class="docutils literal notranslate"><span class="pre">MachineBasicBlock</span></code> class has a “<code class="docutils literal notranslate"><span class="pre">getBasicBlock</span></code>” method,
which returns the LLVM basic block that it comes from.</p>
</div>
<div class="section" id="the-machinefunction-class">
<span id="machinefunction"></span><h3><a class="toc-backref" href="#id28">The <code class="docutils literal notranslate"><span class="pre">MachineFunction</span></code> class</a><a class="headerlink" href="#the-machinefunction-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">MachineFunction</span></code> class contains a list of machine basic blocks
(<span class="raw-html"><tt></span> <a class="reference internal" href="#machinebasicblock">MachineBasicBlock</a> <span class="raw-html"></tt></span> instances).  It
corresponds one-to-one with the LLVM function input to the instruction selector.
In addition to a list of basic blocks, the <code class="docutils literal notranslate"><span class="pre">MachineFunction</span></code> contains a a
<code class="docutils literal notranslate"><span class="pre">MachineConstantPool</span></code>, a <code class="docutils literal notranslate"><span class="pre">MachineFrameInfo</span></code>, a <code class="docutils literal notranslate"><span class="pre">MachineFunctionInfo</span></code>, and
a <code class="docutils literal notranslate"><span class="pre">MachineRegisterInfo</span></code>.  See <code class="docutils literal notranslate"><span class="pre">include/llvm/CodeGen/MachineFunction.h</span></code> for
more information.</p>
</div>
<div class="section" id="machineinstr-bundles">
<h3><a class="toc-backref" href="#id29"><code class="docutils literal notranslate"><span class="pre">MachineInstr</span> <span class="pre">Bundles</span></code></a><a class="headerlink" href="#machineinstr-bundles" title="Permalink to this headline">¶</a></h3>
<p>LLVM code generator can model sequences of instructions as MachineInstr
bundles. A MI bundle can model a VLIW group / pack which contains an arbitrary
number of parallel instructions. It can also be used to model a sequential list
of instructions (potentially with data dependencies) that cannot be legally
separated (e.g. ARM Thumb2 IT blocks).</p>
<p>Conceptually a MI bundle is a MI with a number of other MIs nested within:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">--------------</span>
<span class="o">|</span>   <span class="n">Bundle</span>   <span class="o">|</span> <span class="o">---------</span>
<span class="o">--------------</span>          \
       <span class="o">|</span>           <span class="o">----------------</span>
       <span class="o">|</span>           <span class="o">|</span>      <span class="n">MI</span>      <span class="o">|</span>
       <span class="o">|</span>           <span class="o">----------------</span>
       <span class="o">|</span>                   <span class="o">|</span>
       <span class="o">|</span>           <span class="o">----------------</span>
       <span class="o">|</span>           <span class="o">|</span>      <span class="n">MI</span>      <span class="o">|</span>
       <span class="o">|</span>           <span class="o">----------------</span>
       <span class="o">|</span>                   <span class="o">|</span>
       <span class="o">|</span>           <span class="o">----------------</span>
       <span class="o">|</span>           <span class="o">|</span>      <span class="n">MI</span>      <span class="o">|</span>
       <span class="o">|</span>           <span class="o">----------------</span>
       <span class="o">|</span>
<span class="o">--------------</span>
<span class="o">|</span>   <span class="n">Bundle</span>   <span class="o">|</span> <span class="o">--------</span>
<span class="o">--------------</span>         \
       <span class="o">|</span>           <span class="o">----------------</span>
       <span class="o">|</span>           <span class="o">|</span>      <span class="n">MI</span>      <span class="o">|</span>
       <span class="o">|</span>           <span class="o">----------------</span>
       <span class="o">|</span>                   <span class="o">|</span>
       <span class="o">|</span>           <span class="o">----------------</span>
       <span class="o">|</span>           <span class="o">|</span>      <span class="n">MI</span>      <span class="o">|</span>
       <span class="o">|</span>           <span class="o">----------------</span>
       <span class="o">|</span>                   <span class="o">|</span>
       <span class="o">|</span>                  <span class="o">...</span>
       <span class="o">|</span>
<span class="o">--------------</span>
<span class="o">|</span>   <span class="n">Bundle</span>   <span class="o">|</span> <span class="o">--------</span>
<span class="o">--------------</span>         \
       <span class="o">|</span>
      <span class="o">...</span>
</pre></div>
</div>
<p>MI bundle support does not change the physical representations of
MachineBasicBlock and MachineInstr. All the MIs (including top level and nested
ones) are stored as sequential list of MIs. The “bundled” MIs are marked with
the ‘InsideBundle’ flag. A top level MI with the special BUNDLE opcode is used
to represent the start of a bundle. It’s legal to mix BUNDLE MIs with individual
MIs that are not inside bundles nor represent bundles.</p>
<p>MachineInstr passes should operate on a MI bundle as a single unit. Member
methods have been taught to correctly handle bundles and MIs inside bundles.
The MachineBasicBlock iterator has been modified to skip over bundled MIs to
enforce the bundle-as-a-single-unit concept. An alternative iterator
instr_iterator has been added to MachineBasicBlock to allow passes to iterate
over all of the MIs in a MachineBasicBlock, including those which are nested
inside bundles. The top level BUNDLE instruction must have the correct set of
register MachineOperand’s that represent the cumulative inputs and outputs of
the bundled MIs.</p>
<p>Packing / bundling of MachineInstr’s should be done as part of the register
allocation super-pass. More specifically, the pass which determines what MIs
should be bundled together must be done after code generator exits SSA form
(i.e. after two-address pass, PHI elimination, and copy coalescing).  Bundles
should only be finalized (i.e. adding BUNDLE MIs and input and output register
MachineOperands) after virtual registers have been rewritten into physical
registers. This requirement eliminates the need to add virtual register operands
to BUNDLE instructions which would effectively double the virtual register def
and use lists.</p>
</div>
</div>
<div class="section" id="the-mc-layer">
<span id="mc-layer"></span><h2><a class="toc-backref" href="#id30">The “MC” Layer</a><a class="headerlink" href="#the-mc-layer" title="Permalink to this headline">¶</a></h2>
<p>The MC Layer is used to represent and process code at the raw machine code
level, devoid of “high level” information like “constant pools”, “jump tables”,
“global variables” or anything like that.  At this level, LLVM handles things
like label names, machine instructions, and sections in the object file.  The
code in this layer is used for a number of important purposes: the tail end of
the code generator uses it to write a .s or .o file, and it is also used by the
llvm-mc tool to implement standalone machine code assemblers and disassemblers.</p>
<p>This section describes some of the important classes.  There are also a number
of important subsystems that interact at this layer, they are described later in
this manual.</p>
<div class="section" id="the-mcstreamer-api">
<span id="mcstreamer"></span><h3><a class="toc-backref" href="#id31">The <code class="docutils literal notranslate"><span class="pre">MCStreamer</span></code> API</a><a class="headerlink" href="#the-mcstreamer-api" title="Permalink to this headline">¶</a></h3>
<p>MCStreamer is best thought of as an assembler API.  It is an abstract API which
is <em>implemented</em> in different ways (e.g. to output a .s file, output an ELF .o
file, etc) but whose API correspond directly to what you see in a .s file.
MCStreamer has one method per directive, such as EmitLabel, EmitSymbolAttribute,
SwitchSection, EmitValue (for .byte, .word), etc, which directly correspond to
assembly level directives.  It also has an EmitInstruction method, which is used
to output an MCInst to the streamer.</p>
<p>This API is most important for two clients: the llvm-mc stand-alone assembler is
effectively a parser that parses a line, then invokes a method on MCStreamer. In
the code generator, the <a class="reference internal" href="#code-emission">Code Emission</a> phase of the code generator lowers
higher level LLVM IR and Machine* constructs down to the MC layer, emitting
directives through MCStreamer.</p>
<p>On the implementation side of MCStreamer, there are two major implementations:
one for writing out a .s file (MCAsmStreamer), and one for writing out a .o
file (MCObjectStreamer).  MCAsmStreamer is a straightforward implementation
that prints out a directive for each method (e.g. <code class="docutils literal notranslate"><span class="pre">EmitValue</span> <span class="pre">-&gt;</span> <span class="pre">.byte</span></code>), but
MCObjectStreamer implements a full assembler.</p>
<p>For target specific directives, the MCStreamer has a MCTargetStreamer instance.
Each target that needs it defines a class that inherits from it and is a lot
like MCStreamer itself: It has one method per directive and two classes that
inherit from it, a target object streamer and a target asm streamer. The target
asm streamer just prints it (<code class="docutils literal notranslate"><span class="pre">emitFnStart</span> <span class="pre">-&gt;</span> <span class="pre">.fnstart</span></code>), and the object
streamer implement the assembler logic for it.</p>
<p>To make llvm use these classes, the target initialization must call
TargetRegistry::RegisterAsmStreamer and TargetRegistry::RegisterMCObjectStreamer
passing callbacks that allocate the corresponding target streamer and pass it
to createAsmStreamer or to the appropriate object streamer constructor.</p>
</div>
<div class="section" id="the-mccontext-class">
<h3><a class="toc-backref" href="#id32">The <code class="docutils literal notranslate"><span class="pre">MCContext</span></code> class</a><a class="headerlink" href="#the-mccontext-class" title="Permalink to this headline">¶</a></h3>
<p>The MCContext class is the owner of a variety of uniqued data structures at the
MC layer, including symbols, sections, etc.  As such, this is the class that you
interact with to create symbols and sections.  This class can not be subclassed.</p>
</div>
<div class="section" id="the-mcsymbol-class">
<h3><a class="toc-backref" href="#id33">The <code class="docutils literal notranslate"><span class="pre">MCSymbol</span></code> class</a><a class="headerlink" href="#the-mcsymbol-class" title="Permalink to this headline">¶</a></h3>
<p>The MCSymbol class represents a symbol (aka label) in the assembly file.  There
are two interesting kinds of symbols: assembler temporary symbols, and normal
symbols.  Assembler temporary symbols are used and processed by the assembler
but are discarded when the object file is produced.  The distinction is usually
represented by adding a prefix to the label, for example “L” labels are
assembler temporary labels in MachO.</p>
<p>MCSymbols are created by MCContext and uniqued there.  This means that MCSymbols
can be compared for pointer equivalence to find out if they are the same symbol.
Note that pointer inequality does not guarantee the labels will end up at
different addresses though.  It’s perfectly legal to output something like this
to the .s file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span><span class="p">:</span>
<span class="n">bar</span><span class="p">:</span>
  <span class="o">.</span><span class="n">byte</span> <span class="mi">4</span>
</pre></div>
</div>
<p>In this case, both the foo and bar symbols will have the same address.</p>
</div>
<div class="section" id="the-mcsection-class">
<h3><a class="toc-backref" href="#id34">The <code class="docutils literal notranslate"><span class="pre">MCSection</span></code> class</a><a class="headerlink" href="#the-mcsection-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">MCSection</span></code> class represents an object-file specific section. It is
subclassed by object file specific implementations (e.g. <code class="docutils literal notranslate"><span class="pre">MCSectionMachO</span></code>,
<code class="docutils literal notranslate"><span class="pre">MCSectionCOFF</span></code>, <code class="docutils literal notranslate"><span class="pre">MCSectionELF</span></code>) and these are created and uniqued by
MCContext.  The MCStreamer has a notion of the current section, which can be
changed with the SwitchToSection method (which corresponds to a “.section”
directive in a .s file).</p>
</div>
<div class="section" id="the-mcinst-class">
<span id="mcinst"></span><h3><a class="toc-backref" href="#id35">The <code class="docutils literal notranslate"><span class="pre">MCInst</span></code> class</a><a class="headerlink" href="#the-mcinst-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">MCInst</span></code> class is a target-independent representation of an instruction.
It is a simple class (much more so than <a class="reference internal" href="#machineinstr">MachineInstr</a>) that holds a
target-specific opcode and a vector of MCOperands.  MCOperand, in turn, is a
simple discriminated union of three cases: 1) a simple immediate, 2) a target
register ID, 3) a symbolic expression (e.g. “<code class="docutils literal notranslate"><span class="pre">Lfoo-Lbar+42</span></code>”) as an MCExpr.</p>
<p>MCInst is the common currency used to represent machine instructions at the MC
layer.  It is the type used by the instruction encoder, the instruction printer,
and the type generated by the assembly parser and disassembler.</p>
</div>
</div>
<div class="section" id="target-independent-code-generation-algorithms">
<span id="code-generation-algorithm"></span><span id="target-independent-algorithms"></span><h2><a class="toc-backref" href="#id36">Target-independent code generation algorithms</a><a class="headerlink" href="#target-independent-code-generation-algorithms" title="Permalink to this headline">¶</a></h2>
<p>This section documents the phases described in the <a class="reference internal" href="#high-level-design-of-the-code-generator">high-level design of the
code generator</a>.  It explains how they work and some of the rationale behind
their design.</p>
<div class="section" id="instruction-selection-section">
<span id="instruction-selection"></span><span id="id1"></span><h3><a class="toc-backref" href="#id37">Instruction Selection</a><a class="headerlink" href="#instruction-selection-section" title="Permalink to this headline">¶</a></h3>
<p>Instruction Selection is the process of translating LLVM code presented to the
code generator into target-specific machine instructions.  There are several
well-known ways to do this in the literature.  LLVM uses a SelectionDAG based
instruction selector.</p>
<p>Portions of the DAG instruction selector are generated from the target
description (<code class="docutils literal notranslate"><span class="pre">*.td</span></code>) files.  Our goal is for the entire instruction selector
to be generated from these <code class="docutils literal notranslate"><span class="pre">.td</span></code> files, though currently there are still
things that require custom C++ code.</p>
<div class="section" id="introduction-to-selectiondags">
<span id="selectiondag"></span><h4><a class="toc-backref" href="#id38">Introduction to SelectionDAGs</a><a class="headerlink" href="#introduction-to-selectiondags" title="Permalink to this headline">¶</a></h4>
<p>The SelectionDAG provides an abstraction for code representation in a way that
is amenable to instruction selection using automatic techniques
(e.g. dynamic-programming based optimal pattern matching selectors). It is also
well-suited to other phases of code generation; in particular, instruction
scheduling (SelectionDAG’s are very close to scheduling DAGs post-selection).
Additionally, the SelectionDAG provides a host representation where a large
variety of very-low-level (but target-independent) <a class="reference internal" href="#optimizations">optimizations</a> may be
performed; ones which require extensive information about the instructions
efficiently supported by the target.</p>
<p>The SelectionDAG is a Directed-Acyclic-Graph whose nodes are instances of the
<code class="docutils literal notranslate"><span class="pre">SDNode</span></code> class.  The primary payload of the <code class="docutils literal notranslate"><span class="pre">SDNode</span></code> is its operation code
(Opcode) that indicates what operation the node performs and the operands to the
operation.  The various operation node types are described at the top of the
<code class="docutils literal notranslate"><span class="pre">include/llvm/CodeGen/ISDOpcodes.h</span></code> file.</p>
<p>Although most operations define a single value, each node in the graph may
define multiple values.  For example, a combined div/rem operation will define
both the dividend and the remainder. Many other situations require multiple
values as well.  Each node also has some number of operands, which are edges to
the node defining the used value.  Because nodes may define multiple values,
edges are represented by instances of the <code class="docutils literal notranslate"><span class="pre">SDValue</span></code> class, which is a
<code class="docutils literal notranslate"><span class="pre">&lt;SDNode,</span> <span class="pre">unsigned&gt;</span></code> pair, indicating the node and result value being used,
respectively.  Each value produced by an <code class="docutils literal notranslate"><span class="pre">SDNode</span></code> has an associated <code class="docutils literal notranslate"><span class="pre">MVT</span></code>
(Machine Value Type) indicating what the type of the value is.</p>
<p>SelectionDAGs contain two different kinds of values: those that represent data
flow and those that represent control flow dependencies.  Data values are simple
edges with an integer or floating point value type.  Control edges are
represented as “chain” edges which are of type <code class="docutils literal notranslate"><span class="pre">MVT::Other</span></code>.  These edges
provide an ordering between nodes that have side effects (such as loads, stores,
calls, returns, etc).  All nodes that have side effects should take a token
chain as input and produce a new one as output.  By convention, token chain
inputs are always operand #0, and chain results are always the last value
produced by an operation. However, after instruction selection, the
machine nodes have their chain after the instruction’s operands, and
may be followed by glue nodes.</p>
<p>A SelectionDAG has designated “Entry” and “Root” nodes.  The Entry node is
always a marker node with an Opcode of <code class="docutils literal notranslate"><span class="pre">ISD::EntryToken</span></code>.  The Root node is
the final side-effecting node in the token chain. For example, in a single basic
block function it would be the return node.</p>
<p>One important concept for SelectionDAGs is the notion of a “legal” vs.
“illegal” DAG.  A legal DAG for a target is one that only uses supported
operations and supported types.  On a 32-bit PowerPC, for example, a DAG with a
value of type i1, i8, i16, or i64 would be illegal, as would a DAG that uses a
SREM or UREM operation.  The <a class="reference internal" href="#legalize-types">legalize types</a> and <a class="reference internal" href="#legalize-operations">legalize operations</a> phases
are responsible for turning an illegal DAG into a legal DAG.</p>
</div>
<div class="section" id="selectiondag-instruction-selection-process">
<span id="selectiondag-process"></span><h4><a class="toc-backref" href="#id39">SelectionDAG Instruction Selection Process</a><a class="headerlink" href="#selectiondag-instruction-selection-process" title="Permalink to this headline">¶</a></h4>
<p>SelectionDAG-based instruction selection consists of the following steps:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#build-initial-dag">Build initial DAG</a> — This stage performs a simple translation from the
input LLVM code to an illegal SelectionDAG.</p></li>
<li><p><a class="reference internal" href="#optimize-selectiondag">Optimize SelectionDAG</a> — This stage performs simple optimizations on the
SelectionDAG to simplify it, and recognize meta instructions (like rotates
and <code class="docutils literal notranslate"><span class="pre">div</span></code>/<code class="docutils literal notranslate"><span class="pre">rem</span></code> pairs) for targets that support these meta operations.
This makes the resultant code more efficient and the <a class="reference internal" href="#select-instructions-from-dag">select instructions
from DAG</a> phase (below) simpler.</p></li>
<li><p><a class="reference internal" href="#legalize-selectiondag-types">Legalize SelectionDAG Types</a> — This stage transforms SelectionDAG nodes
to eliminate any types that are unsupported on the target.</p></li>
<li><p><a class="reference internal" href="#optimize-selectiondag">Optimize SelectionDAG</a> — The SelectionDAG optimizer is run to clean up
redundancies exposed by type legalization.</p></li>
<li><p><a class="reference internal" href="#legalize-selectiondag-ops">Legalize SelectionDAG Ops</a> — This stage transforms SelectionDAG nodes to
eliminate any operations that are unsupported on the target.</p></li>
<li><p><a class="reference internal" href="#optimize-selectiondag">Optimize SelectionDAG</a> — The SelectionDAG optimizer is run to eliminate
inefficiencies introduced by operation legalization.</p></li>
<li><p><a class="reference internal" href="#select-instructions-from-dag">Select instructions from DAG</a> — Finally, the target instruction selector
matches the DAG operations to target instructions.  This process translates
the target-independent input DAG into another DAG of target instructions.</p></li>
<li><p><a class="reference internal" href="#selectiondag-scheduling-and-formation">SelectionDAG Scheduling and Formation</a> — The last phase assigns a linear
order to the instructions in the target-instruction DAG and emits them into
the MachineFunction being compiled.  This step uses traditional prepass
scheduling techniques.</p></li>
</ol>
<p>After all of these steps are complete, the SelectionDAG is destroyed and the
rest of the code generation passes are run.</p>
<p>One great way to visualize what is going on here is to take advantage of a few
LLC command line options.  The following options pop up a window displaying the
SelectionDAG at specific times (if you only get errors printed to the console
while using this, you probably <a class="reference external" href="ProgrammersManual.html#viewing-graphs-while-debugging-code">need to configure your
system</a> to add support for it).</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-view-dag-combine1-dags</span></code> displays the DAG after being built, before the
first optimization pass.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-view-legalize-dags</span></code> displays the DAG before Legalization.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-view-dag-combine2-dags</span></code> displays the DAG before the second optimization
pass.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-view-isel-dags</span></code> displays the DAG before the Select phase.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-view-sched-dags</span></code> displays the DAG before Scheduling.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">-view-sunit-dags</span></code> displays the Scheduler’s dependency graph.  This graph
is based on the final SelectionDAG, with nodes that must be scheduled together
bundled into a single scheduling-unit node, and with immediate operands and
other nodes that aren’t relevant for scheduling omitted.</p>
<p>The option <code class="docutils literal notranslate"><span class="pre">-filter-view-dags</span></code> allows to select the name of the basic block
that you are interested to visualize and filters all the previous
<code class="docutils literal notranslate"><span class="pre">view-*-dags</span></code> options.</p>
</div>
<div class="section" id="initial-selectiondag-construction">
<span id="build-initial-dag"></span><h4><a class="toc-backref" href="#id40">Initial SelectionDAG Construction</a><a class="headerlink" href="#initial-selectiondag-construction" title="Permalink to this headline">¶</a></h4>
<p>The initial SelectionDAG is na<span class="raw-html">&iuml;</span>vely peephole expanded from
the LLVM input by the <code class="docutils literal notranslate"><span class="pre">SelectionDAGBuilder</span></code> class.  The intent of this pass
is to expose as much low-level, target-specific details to the SelectionDAG as
possible.  This pass is mostly hard-coded (e.g. an LLVM <code class="docutils literal notranslate"><span class="pre">add</span></code> turns into an
<code class="docutils literal notranslate"><span class="pre">SDNode</span> <span class="pre">add</span></code> while a <code class="docutils literal notranslate"><span class="pre">getelementptr</span></code> is expanded into the obvious
arithmetic). This pass requires target-specific hooks to lower calls, returns,
varargs, etc.  For these features, the <span class="raw-html"><tt></span> <a class="reference internal" href="#targetlowering">TargetLowering</a>
<span class="raw-html"></tt></span> interface is used.</p>
</div>
<div class="section" id="selectiondag-legalizetypes-phase">
<span id="legalize-selectiondag-ops"></span><span id="legalize-selectiondag-types"></span><span id="legalize-types"></span><h4><a class="toc-backref" href="#id41">SelectionDAG LegalizeTypes Phase</a><a class="headerlink" href="#selectiondag-legalizetypes-phase" title="Permalink to this headline">¶</a></h4>
<p>The Legalize phase is in charge of converting a DAG to only use the types that
are natively supported by the target.</p>
<p>There are two main ways of converting values of unsupported scalar types to
values of supported types: converting small types to larger types (“promoting”),
and breaking up large integer types into smaller ones (“expanding”).  For
example, a target might require that all f32 values are promoted to f64 and that
all i1/i8/i16 values are promoted to i32.  The same target might require that
all i64 values be expanded into pairs of i32 values.  These changes can insert
sign and zero extensions as needed to make sure that the final code has the same
behavior as the input.</p>
<p>There are two main ways of converting values of unsupported vector types to
value of supported types: splitting vector types, multiple times if necessary,
until a legal type is found, and extending vector types by adding elements to
the end to round them out to legal types (“widening”).  If a vector gets split
all the way down to single-element parts with no supported vector type being
found, the elements are converted to scalars (“scalarizing”).</p>
<p>A target implementation tells the legalizer which types are supported (and which
register class to use for them) by calling the <code class="docutils literal notranslate"><span class="pre">addRegisterClass</span></code> method in
its <code class="docutils literal notranslate"><span class="pre">TargetLowering</span></code> constructor.</p>
</div>
<div class="section" id="selectiondag-legalize-phase">
<span id="legalizer"></span><span id="legalize-operations"></span><h4><a class="toc-backref" href="#id42">SelectionDAG Legalize Phase</a><a class="headerlink" href="#selectiondag-legalize-phase" title="Permalink to this headline">¶</a></h4>
<p>The Legalize phase is in charge of converting a DAG to only use the operations
that are natively supported by the target.</p>
<p>Targets often have weird constraints, such as not supporting every operation on
every supported datatype (e.g. X86 does not support byte conditional moves and
PowerPC does not support sign-extending loads from a 16-bit memory location).
Legalize takes care of this by open-coding another sequence of operations to
emulate the operation (“expansion”), by promoting one type to a larger type that
supports the operation (“promotion”), or by using a target-specific hook to
implement the legalization (“custom”).</p>
<p>A target implementation tells the legalizer which operations are not supported
(and which of the above three actions to take) by calling the
<code class="docutils literal notranslate"><span class="pre">setOperationAction</span></code> method in its <code class="docutils literal notranslate"><span class="pre">TargetLowering</span></code> constructor.</p>
<p>If a target has legal vector types, it is expected to produce efficient machine
code for common forms of the shufflevector IR instruction using those types.
This may require custom legalization for SelectionDAG vector operations that
are created from the shufflevector IR. The shufflevector forms that should be
handled include:</p>
<ul class="simple">
<li><p>Vector select — Each element of the vector is chosen from either of the
corresponding elements of the 2 input vectors. This operation may also be
known as a “blend” or “bitwise select” in target assembly. This type of shuffle
maps directly to the <code class="docutils literal notranslate"><span class="pre">shuffle_vector</span></code> SelectionDAG node.</p></li>
<li><p>Insert subvector — A vector is placed into a longer vector type starting
at index 0. This type of shuffle maps directly to the <code class="docutils literal notranslate"><span class="pre">insert_subvector</span></code>
SelectionDAG node with the <code class="docutils literal notranslate"><span class="pre">index</span></code> operand set to 0.</p></li>
<li><p>Extract subvector — A vector is pulled from a longer vector type starting
at index 0. This type of shuffle maps directly to the <code class="docutils literal notranslate"><span class="pre">extract_subvector</span></code>
SelectionDAG node with the <code class="docutils literal notranslate"><span class="pre">index</span></code> operand set to 0.</p></li>
<li><p>Splat — All elements of the vector have identical scalar elements. This
operation may also be known as a “broadcast” or “duplicate” in target assembly.
The shufflevector IR instruction may change the vector length, so this operation
may map to multiple SelectionDAG nodes including <code class="docutils literal notranslate"><span class="pre">shuffle_vector</span></code>,
<code class="docutils literal notranslate"><span class="pre">concat_vectors</span></code>, <code class="docutils literal notranslate"><span class="pre">insert_subvector</span></code>, and <code class="docutils literal notranslate"><span class="pre">extract_subvector</span></code>.</p></li>
</ul>
<p>Prior to the existence of the Legalize passes, we required that every target
<a class="reference internal" href="#selector">selector</a> supported and handled every operator and type even if they are not
natively supported.  The introduction of the Legalize phases allows all of the
canonicalization patterns to be shared across targets, and makes it very easy to
optimize the canonicalized code because it is still in the form of a DAG.</p>
</div>
<div class="section" id="selectiondag-optimization-phase-the-dag-combiner">
<span id="selector"></span><span id="optimize-selectiondag"></span><span id="optimizations"></span><h4><a class="toc-backref" href="#id43">SelectionDAG Optimization Phase: the DAG Combiner</a><a class="headerlink" href="#selectiondag-optimization-phase-the-dag-combiner" title="Permalink to this headline">¶</a></h4>
<p>The SelectionDAG optimization phase is run multiple times for code generation,
immediately after the DAG is built and once after each legalization.  The first
run of the pass allows the initial code to be cleaned up (e.g. performing
optimizations that depend on knowing that the operators have restricted type
inputs).  Subsequent runs of the pass clean up the messy code generated by the
Legalize passes, which allows Legalize to be very simple (it can focus on making
code legal instead of focusing on generating <em>good</em> and legal code).</p>
<p>One important class of optimizations performed is optimizing inserted sign and
zero extension instructions.  We currently use ad-hoc techniques, but could move
to more rigorous techniques in the future.  Here are some good papers on the
subject:</p>
<p>“<a class="reference external" href="http://www.eecs.harvard.edu/~nr/pubs/widen-abstract.html">Widening integer arithmetic</a>” <span class="raw-html"><br></span>
Kevin Redwine and Norman Ramsey <span class="raw-html"><br></span>
International Conference on Compiler Construction (CC) 2004</p>
<p>“<a class="reference external" href="http://portal.acm.org/citation.cfm?doid=512529.512552">Effective sign extension elimination</a>”  <span class="raw-html"><br></span>
Motohiro Kawahito, Hideaki Komatsu, and Toshio Nakatani <span class="raw-html"><br></span>
Proceedings of the ACM SIGPLAN 2002 Conference on Programming Language Design
and Implementation.</p>
</div>
<div class="section" id="selectiondag-select-phase">
<span id="select-instructions-from-dag"></span><h4><a class="toc-backref" href="#id44">SelectionDAG Select Phase</a><a class="headerlink" href="#selectiondag-select-phase" title="Permalink to this headline">¶</a></h4>
<p>The Select phase is the bulk of the target-specific code for instruction
selection.  This phase takes a legal SelectionDAG as input, pattern matches the
instructions supported by the target to this DAG, and produces a new DAG of
target code.  For example, consider the following LLVM fragment:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">%t1</span> <span class="p">=</span> <span class="k">fadd</span> <span class="k">float</span> <span class="nv">%W</span><span class="p">,</span> <span class="nv">%X</span>
<span class="nv">%t2</span> <span class="p">=</span> <span class="k">fmul</span> <span class="k">float</span> <span class="nv">%t1</span><span class="p">,</span> <span class="nv">%Y</span>
<span class="nv">%t3</span> <span class="p">=</span> <span class="k">fadd</span> <span class="k">float</span> <span class="nv">%t2</span><span class="p">,</span> <span class="nv">%Z</span>
</pre></div>
</div>
<p>This LLVM code corresponds to a SelectionDAG that looks basically like this:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(fadd:f32 (fmul:f32 (fadd:f32 W, X), Y), Z)
</pre></div>
</div>
<p>If a target supports floating point multiply-and-add (FMA) operations, one of
the adds can be merged with the multiply.  On the PowerPC, for example, the
output of the instruction selector might look like this DAG:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">FMADDS</span> <span class="p">(</span><span class="n">FADDS</span> <span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">FMADDS</span></code> instruction is a ternary instruction that multiplies its first
two operands and adds the third (as single-precision floating-point numbers).
The <code class="docutils literal notranslate"><span class="pre">FADDS</span></code> instruction is a simple binary single-precision add instruction.
To perform this pattern match, the PowerPC backend includes the following
instruction definitions:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def FMADDS : AForm_1&lt;59, 29,
                    (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRC, F4RC:$FRB),
                    &quot;fmadds $FRT, $FRA, $FRC, $FRB&quot;,
<span class="hll">                    [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),
</span><span class="hll">                                           F4RC:$FRB))]&gt;;
</span>def FADDS : AForm_2&lt;59, 21,
                    (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRB),
                    &quot;fadds $FRT, $FRA, $FRB&quot;,
<span class="hll">                    [(set F4RC:$FRT, (fadd F4RC:$FRA, F4RC:$FRB))]&gt;;
</span></pre></div>
</div>
<p>The highlighted portion of the instruction definitions indicates the pattern
used to match the instructions. The DAG operators (like <code class="docutils literal notranslate"><span class="pre">fmul</span></code>/<code class="docutils literal notranslate"><span class="pre">fadd</span></code>)
are defined in the <code class="docutils literal notranslate"><span class="pre">include/llvm/Target/TargetSelectionDAG.td</span></code> file.
“<code class="docutils literal notranslate"><span class="pre">F4RC</span></code>” is the register class of the input and result values.</p>
<p>The TableGen DAG instruction selector generator reads the instruction patterns
in the <code class="docutils literal notranslate"><span class="pre">.td</span></code> file and automatically builds parts of the pattern matching code
for your target.  It has the following strengths:</p>
<ul>
<li><p>At compiler-compile time, it analyzes your instruction patterns and tells you
if your patterns make sense or not.</p></li>
<li><p>It can handle arbitrary constraints on operands for the pattern match.  In
particular, it is straight-forward to say things like “match any immediate
that is a 13-bit sign-extended value”.  For examples, see the <code class="docutils literal notranslate"><span class="pre">immSExt16</span></code>
and related <code class="docutils literal notranslate"><span class="pre">tblgen</span></code> classes in the PowerPC backend.</p></li>
<li><p>It knows several important identities for the patterns defined.  For example,
it knows that addition is commutative, so it allows the <code class="docutils literal notranslate"><span class="pre">FMADDS</span></code> pattern
above to match “<code class="docutils literal notranslate"><span class="pre">(fadd</span> <span class="pre">X,</span> <span class="pre">(fmul</span> <span class="pre">Y,</span> <span class="pre">Z))</span></code>” as well as “<code class="docutils literal notranslate"><span class="pre">(fadd</span> <span class="pre">(fmul</span> <span class="pre">X,</span> <span class="pre">Y),</span>
<span class="pre">Z)</span></code>”, without the target author having to specially handle this case.</p></li>
<li><p>It has a full-featured type-inferencing system.  In particular, you should
rarely have to explicitly tell the system what type parts of your patterns
are.  In the <code class="docutils literal notranslate"><span class="pre">FMADDS</span></code> case above, we didn’t have to tell <code class="docutils literal notranslate"><span class="pre">tblgen</span></code> that all
of the nodes in the pattern are of type ‘f32’.  It was able to infer and
propagate this knowledge from the fact that <code class="docutils literal notranslate"><span class="pre">F4RC</span></code> has type ‘f32’.</p></li>
<li><p>Targets can define their own (and rely on built-in) “pattern fragments”.
Pattern fragments are chunks of reusable patterns that get inlined into your
patterns during compiler-compile time.  For example, the integer “<code class="docutils literal notranslate"><span class="pre">(not</span>
<span class="pre">x)</span></code>” operation is actually defined as a pattern fragment that expands as
“<code class="docutils literal notranslate"><span class="pre">(xor</span> <span class="pre">x,</span> <span class="pre">-1)</span></code>”, since the SelectionDAG does not have a native ‘<code class="docutils literal notranslate"><span class="pre">not</span></code>’
operation.  Targets can define their own short-hand fragments as they see fit.
See the definition of ‘<code class="docutils literal notranslate"><span class="pre">not</span></code>’ and ‘<code class="docutils literal notranslate"><span class="pre">ineg</span></code>’ for examples.</p></li>
<li><p>In addition to instructions, targets can specify arbitrary patterns that map
to one or more instructions using the ‘Pat’ class.  For example, the PowerPC
has no way to load an arbitrary integer immediate into a register in one
instruction. To tell tblgen how to do this, it defines:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Arbitrary immediate support.  Implement in terms of LIS/ORI.
def : Pat&lt;(i32 imm:$imm),
          (ORI (LIS (HI16 imm:$imm)), (LO16 imm:$imm))&gt;;
</pre></div>
</div>
<p>If none of the single-instruction patterns for loading an immediate into a
register match, this will be used.  This rule says “match an arbitrary i32
immediate, turning it into an <code class="docutils literal notranslate"><span class="pre">ORI</span></code> (‘or a 16-bit immediate’) and an <code class="docutils literal notranslate"><span class="pre">LIS</span></code>
(‘load 16-bit immediate, where the immediate is shifted to the left 16 bits’)
instruction”.  To make this work, the <code class="docutils literal notranslate"><span class="pre">LO16</span></code>/<code class="docutils literal notranslate"><span class="pre">HI16</span></code> node transformations
are used to manipulate the input immediate (in this case, take the high or low
16-bits of the immediate).</p>
</li>
<li><p>When using the ‘Pat’ class to map a pattern to an instruction that has one
or more complex operands (like e.g. <a class="reference internal" href="#x86-addressing-mode">X86 addressing mode</a>), the pattern may
either specify the operand as a whole using a <code class="docutils literal notranslate"><span class="pre">ComplexPattern</span></code>, or else it
may specify the components of the complex operand separately.  The latter is
done e.g. for pre-increment instructions by the PowerPC back end:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>def STWU  : DForm_1&lt;37, (outs ptr_rc:$ea_res), (ins GPRC:$rS, memri:$dst),
                &quot;stwu $rS, $dst&quot;, LdStStoreUpd, []&gt;,
                RegConstraint&lt;&quot;$dst.reg = $ea_res&quot;&gt;, NoEncode&lt;&quot;$ea_res&quot;&gt;;

def : Pat&lt;(pre_store GPRC:$rS, ptr_rc:$ptrreg, iaddroff:$ptroff),
          (STWU GPRC:$rS, iaddroff:$ptroff, ptr_rc:$ptrreg)&gt;;
</pre></div>
</div>
<p>Here, the pair of <code class="docutils literal notranslate"><span class="pre">ptroff</span></code> and <code class="docutils literal notranslate"><span class="pre">ptrreg</span></code> operands is matched onto the
complex operand <code class="docutils literal notranslate"><span class="pre">dst</span></code> of class <code class="docutils literal notranslate"><span class="pre">memri</span></code> in the <code class="docutils literal notranslate"><span class="pre">STWU</span></code> instruction.</p>
</li>
<li><p>While the system does automate a lot, it still allows you to write custom C++
code to match special cases if there is something that is hard to
express.</p></li>
</ul>
<p>While it has many strengths, the system currently has some limitations,
primarily because it is a work in progress and is not yet finished:</p>
<ul class="simple">
<li><p>Overall, there is no way to define or match SelectionDAG nodes that define
multiple values (e.g. <code class="docutils literal notranslate"><span class="pre">SMUL_LOHI</span></code>, <code class="docutils literal notranslate"><span class="pre">LOAD</span></code>, <code class="docutils literal notranslate"><span class="pre">CALL</span></code>, etc).  This is the
biggest reason that you currently still <em>have to</em> write custom C++ code
for your instruction selector.</p></li>
<li><p>There is no great way to support matching complex addressing modes yet.  In
the future, we will extend pattern fragments to allow them to define multiple
values (e.g. the four operands of the <a class="reference internal" href="#x86-addressing-mode">X86 addressing mode</a>, which are
currently matched with custom C++ code).  In addition, we’ll extend fragments
so that a fragment can match multiple different patterns.</p></li>
<li><p>We don’t automatically infer flags like <code class="docutils literal notranslate"><span class="pre">isStore</span></code>/<code class="docutils literal notranslate"><span class="pre">isLoad</span></code> yet.</p></li>
<li><p>We don’t automatically generate the set of supported registers and operations
for the <a class="reference internal" href="#legalizer">Legalizer</a> yet.</p></li>
<li><p>We don’t have a way of tying in custom legalized nodes yet.</p></li>
</ul>
<p>Despite these limitations, the instruction selector generator is still quite
useful for most of the binary and logical operations in typical instruction
sets.  If you run into any problems or can’t figure out how to do something,
please let Chris know!</p>
</div>
<div class="section" id="selectiondag-scheduling-and-formation-phase">
<span id="selectiondag-scheduling-and-formation"></span><span id="scheduling-and-formation"></span><h4><a class="toc-backref" href="#id45">SelectionDAG Scheduling and Formation Phase</a><a class="headerlink" href="#selectiondag-scheduling-and-formation-phase" title="Permalink to this headline">¶</a></h4>
<p>The scheduling phase takes the DAG of target instructions from the selection
phase and assigns an order.  The scheduler can pick an order depending on
various constraints of the machines (i.e. order for minimal register pressure or
try to cover instruction latencies).  Once an order is established, the DAG is
converted to a list of <span class="raw-html"><tt></span> <a class="reference internal" href="#machineinstr">MachineInstr</a>s <span class="raw-html"></tt></span> and
the SelectionDAG is destroyed.</p>
<p>Note that this phase is logically separate from the instruction selection phase,
but is tied to it closely in the code because it operates on SelectionDAGs.</p>
</div>
<div class="section" id="future-directions-for-the-selectiondag">
<h4><a class="toc-backref" href="#id46">Future directions for the SelectionDAG</a><a class="headerlink" href="#future-directions-for-the-selectiondag" title="Permalink to this headline">¶</a></h4>
<ol class="arabic simple">
<li><p>Optional function-at-a-time selection.</p></li>
<li><p>Auto-generate entire selector from <code class="docutils literal notranslate"><span class="pre">.td</span></code> file.</p></li>
</ol>
</div>
</div>
<div class="section" id="ssa-based-machine-code-optimizations">
<span id="id2"></span><h3><a class="toc-backref" href="#id47">SSA-based Machine Code Optimizations</a><a class="headerlink" href="#ssa-based-machine-code-optimizations" title="Permalink to this headline">¶</a></h3>
<p>To Be Written</p>
</div>
<div class="section" id="live-intervals">
<h3><a class="toc-backref" href="#id48">Live Intervals</a><a class="headerlink" href="#live-intervals" title="Permalink to this headline">¶</a></h3>
<p>Live Intervals are the ranges (intervals) where a variable is <em>live</em>.  They are
used by some <a class="reference internal" href="#register-allocator">register allocator</a> passes to determine if two or more virtual
registers which require the same physical register are live at the same point in
the program (i.e., they conflict).  When this situation occurs, one virtual
register must be <em>spilled</em>.</p>
<div class="section" id="live-variable-analysis">
<h4><a class="toc-backref" href="#id49">Live Variable Analysis</a><a class="headerlink" href="#live-variable-analysis" title="Permalink to this headline">¶</a></h4>
<p>The first step in determining the live intervals of variables is to calculate
the set of registers that are immediately dead after the instruction (i.e., the
instruction calculates the value, but it is never used) and the set of registers
that are used by the instruction, but are never used after the instruction
(i.e., they are killed). Live variable information is computed for
each <em>virtual</em> register and <em>register allocatable</em> physical register
in the function.  This is done in a very efficient manner because it uses SSA to
sparsely compute lifetime information for virtual registers (which are in SSA
form) and only has to track physical registers within a block.  Before register
allocation, LLVM can assume that physical registers are only live within a
single basic block.  This allows it to do a single, local analysis to resolve
physical register lifetimes within each basic block. If a physical register is
not register allocatable (e.g., a stack pointer or condition codes), it is not
tracked.</p>
<p>Physical registers may be live in to or out of a function. Live in values are
typically arguments in registers. Live out values are typically return values in
registers. Live in values are marked as such, and are given a dummy “defining”
instruction during live intervals analysis. If the last basic block of a
function is a <code class="docutils literal notranslate"><span class="pre">return</span></code>, then it’s marked as using all live out values in the
function.</p>
<p><code class="docutils literal notranslate"><span class="pre">PHI</span></code> nodes need to be handled specially, because the calculation of the live
variable information from a depth first traversal of the CFG of the function
won’t guarantee that a virtual register used by the <code class="docutils literal notranslate"><span class="pre">PHI</span></code> node is defined
before it’s used. When a <code class="docutils literal notranslate"><span class="pre">PHI</span></code> node is encountered, only the definition is
handled, because the uses will be handled in other basic blocks.</p>
<p>For each <code class="docutils literal notranslate"><span class="pre">PHI</span></code> node of the current basic block, we simulate an assignment at
the end of the current basic block and traverse the successor basic blocks. If a
successor basic block has a <code class="docutils literal notranslate"><span class="pre">PHI</span></code> node and one of the <code class="docutils literal notranslate"><span class="pre">PHI</span></code> node’s operands
is coming from the current basic block, then the variable is marked as <em>alive</em>
within the current basic block and all of its predecessor basic blocks, until
the basic block with the defining instruction is encountered.</p>
</div>
<div class="section" id="live-intervals-analysis">
<h4><a class="toc-backref" href="#id50">Live Intervals Analysis</a><a class="headerlink" href="#live-intervals-analysis" title="Permalink to this headline">¶</a></h4>
<p>We now have the information available to perform the live intervals analysis and
build the live intervals themselves.  We start off by numbering the basic blocks
and machine instructions.  We then handle the “live-in” values.  These are in
physical registers, so the physical register is assumed to be killed by the end
of the basic block.  Live intervals for virtual registers are computed for some
ordering of the machine instructions <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">N]</span></code>.  A live interval is an interval
<code class="docutils literal notranslate"><span class="pre">[i,</span> <span class="pre">j)</span></code>, where <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&gt;=</span> <span class="pre">i</span> <span class="pre">&gt;=</span> <span class="pre">j</span> <span class="pre">&gt;</span> <span class="pre">N</span></code>, for which a variable is live.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>More to come…</p>
</div>
</div>
</div>
<div class="section" id="register-allocator">
<span id="register-allocation"></span><span id="id3"></span><h3><a class="toc-backref" href="#id51">Register Allocation</a><a class="headerlink" href="#register-allocator" title="Permalink to this headline">¶</a></h3>
<p>The <em>Register Allocation problem</em> consists in mapping a program
<span class="raw-html"><b><tt></span> P<sub>v</sub><span class="raw-html"></tt></b></span>, that can use an unbounded
number of virtual registers, to a program <span class="raw-html"><b><tt></span> P<sub>p</sub><span class="raw-html"></tt></b></span> that contains a finite (possibly small) number of physical
registers. Each target architecture has a different number of physical
registers. If the number of physical registers is not enough to accommodate all
the virtual registers, some of them will have to be mapped into memory. These
virtuals are called <em>spilled virtuals</em>.</p>
<div class="section" id="how-registers-are-represented-in-llvm">
<h4><a class="toc-backref" href="#id52">How registers are represented in LLVM</a><a class="headerlink" href="#how-registers-are-represented-in-llvm" title="Permalink to this headline">¶</a></h4>
<p>In LLVM, physical registers are denoted by integer numbers that normally range
from 1 to 1023. To see how this numbering is defined for a particular
architecture, you can read the <code class="docutils literal notranslate"><span class="pre">GenRegisterNames.inc</span></code> file for that
architecture. For instance, by inspecting
<code class="docutils literal notranslate"><span class="pre">lib/Target/X86/X86GenRegisterInfo.inc</span></code> we see that the 32-bit register
<code class="docutils literal notranslate"><span class="pre">EAX</span></code> is denoted by 43, and the MMX register <code class="docutils literal notranslate"><span class="pre">MM0</span></code> is mapped to 65.</p>
<p>Some architectures contain registers that share the same physical location. A
notable example is the X86 platform. For instance, in the X86 architecture, the
registers <code class="docutils literal notranslate"><span class="pre">EAX</span></code>, <code class="docutils literal notranslate"><span class="pre">AX</span></code> and <code class="docutils literal notranslate"><span class="pre">AL</span></code> share the first eight bits. These physical
registers are marked as <em>aliased</em> in LLVM. Given a particular architecture, you
can check which registers are aliased by inspecting its <code class="docutils literal notranslate"><span class="pre">RegisterInfo.td</span></code>
file. Moreover, the class <code class="docutils literal notranslate"><span class="pre">MCRegAliasIterator</span></code> enumerates all the physical
registers aliased to a register.</p>
<p>Physical registers, in LLVM, are grouped in <em>Register Classes</em>.  Elements in the
same register class are functionally equivalent, and can be interchangeably
used. Each virtual register can only be mapped to physical registers of a
particular class. For instance, in the X86 architecture, some virtuals can only
be allocated to 8 bit registers.  A register class is described by
<code class="docutils literal notranslate"><span class="pre">TargetRegisterClass</span></code> objects.  To discover if a virtual register is
compatible with a given physical, this code can be used:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">RegMapping_Fer</span><span class="o">::</span><span class="n">compatible_class</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">mf</span><span class="p">,</span>
                                      <span class="kt">unsigned</span> <span class="n">v_reg</span><span class="p">,</span>
                                      <span class="kt">unsigned</span> <span class="n">p_reg</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">TargetRegisterInfo</span><span class="o">::</span><span class="n">isPhysicalRegister</span><span class="p">(</span><span class="n">p_reg</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
         <span class="s">&quot;Target register must be physical&quot;</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">trc</span> <span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">getRegInfo</span><span class="p">().</span><span class="n">getRegClass</span><span class="p">(</span><span class="n">v_reg</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">trc</span><span class="o">-&gt;</span><span class="n">contains</span><span class="p">(</span><span class="n">p_reg</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Sometimes, mostly for debugging purposes, it is useful to change the number of
physical registers available in the target architecture. This must be done
statically, inside the <code class="docutils literal notranslate"><span class="pre">TargetRegsterInfo.td</span></code> file. Just <code class="docutils literal notranslate"><span class="pre">grep</span></code> for
<code class="docutils literal notranslate"><span class="pre">RegisterClass</span></code>, the last parameter of which is a list of registers. Just
commenting some out is one simple way to avoid them being used. A more polite
way is to explicitly exclude some registers from the <em>allocation order</em>. See the
definition of the <code class="docutils literal notranslate"><span class="pre">GR8</span></code> register class in
<code class="docutils literal notranslate"><span class="pre">lib/Target/X86/X86RegisterInfo.td</span></code> for an example of this.</p>
<p>Virtual registers are also denoted by integer numbers. Contrary to physical
registers, different virtual registers never share the same number. Whereas
physical registers are statically defined in a <code class="docutils literal notranslate"><span class="pre">TargetRegisterInfo.td</span></code> file
and cannot be created by the application developer, that is not the case with
virtual registers. In order to create new virtual registers, use the method
<code class="docutils literal notranslate"><span class="pre">MachineRegisterInfo::createVirtualRegister()</span></code>. This method will return a new
virtual register. Use an <code class="docutils literal notranslate"><span class="pre">IndexedMap&lt;Foo,</span> <span class="pre">VirtReg2IndexFunctor&gt;</span></code> to hold
information per virtual register. If you need to enumerate all virtual
registers, use the function <code class="docutils literal notranslate"><span class="pre">TargetRegisterInfo::index2VirtReg()</span></code> to find the
virtual register numbers:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">MRI</span><span class="o">-&gt;</span><span class="n">getNumVirtRegs</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">VirtReg</span> <span class="o">=</span> <span class="n">TargetRegisterInfo</span><span class="o">::</span><span class="n">index2VirtReg</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="n">stuff</span><span class="p">(</span><span class="n">VirtReg</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Before register allocation, the operands of an instruction are mostly virtual
registers, although physical registers may also be used. In order to check if a
given machine operand is a register, use the boolean function
<code class="docutils literal notranslate"><span class="pre">MachineOperand::isRegister()</span></code>. To obtain the integer code of a register, use
<code class="docutils literal notranslate"><span class="pre">MachineOperand::getReg()</span></code>. An instruction may define or use a register. For
instance, <code class="docutils literal notranslate"><span class="pre">ADD</span> <span class="pre">reg:1026</span> <span class="pre">:=</span> <span class="pre">reg:1025</span> <span class="pre">reg:1024</span></code> defines the registers 1024, and
uses registers 1025 and 1026. Given a register operand, the method
<code class="docutils literal notranslate"><span class="pre">MachineOperand::isUse()</span></code> informs if that register is being used by the
instruction. The method <code class="docutils literal notranslate"><span class="pre">MachineOperand::isDef()</span></code> informs if that registers is
being defined.</p>
<p>We will call physical registers present in the LLVM bitcode before register
allocation <em>pre-colored registers</em>. Pre-colored registers are used in many
different situations, for instance, to pass parameters of functions calls, and
to store results of particular instructions. There are two types of pre-colored
registers: the ones <em>implicitly</em> defined, and those <em>explicitly</em>
defined. Explicitly defined registers are normal operands, and can be accessed
with <code class="docutils literal notranslate"><span class="pre">MachineInstr::getOperand(int)::getReg()</span></code>.  In order to check which
registers are implicitly defined by an instruction, use the
<code class="docutils literal notranslate"><span class="pre">TargetInstrInfo::get(opcode)::ImplicitDefs</span></code>, where <code class="docutils literal notranslate"><span class="pre">opcode</span></code> is the opcode
of the target instruction. One important difference between explicit and
implicit physical registers is that the latter are defined statically for each
instruction, whereas the former may vary depending on the program being
compiled. For example, an instruction that represents a function call will
always implicitly define or use the same set of physical registers. To read the
registers implicitly used by an instruction, use
<code class="docutils literal notranslate"><span class="pre">TargetInstrInfo::get(opcode)::ImplicitUses</span></code>. Pre-colored registers impose
constraints on any register allocation algorithm. The register allocator must
make sure that none of them are overwritten by the values of virtual registers
while still alive.</p>
</div>
<div class="section" id="mapping-virtual-registers-to-physical-registers">
<h4><a class="toc-backref" href="#id53">Mapping virtual registers to physical registers</a><a class="headerlink" href="#mapping-virtual-registers-to-physical-registers" title="Permalink to this headline">¶</a></h4>
<p>There are two ways to map virtual registers to physical registers (or to memory
slots). The first way, that we will call <em>direct mapping</em>, is based on the use
of methods of the classes <code class="docutils literal notranslate"><span class="pre">TargetRegisterInfo</span></code>, and <code class="docutils literal notranslate"><span class="pre">MachineOperand</span></code>. The
second way, that we will call <em>indirect mapping</em>, relies on the <code class="docutils literal notranslate"><span class="pre">VirtRegMap</span></code>
class in order to insert loads and stores sending and getting values to and from
memory.</p>
<p>The direct mapping provides more flexibility to the developer of the register
allocator; however, it is more error prone, and demands more implementation
work.  Basically, the programmer will have to specify where load and store
instructions should be inserted in the target function being compiled in order
to get and store values in memory. To assign a physical register to a virtual
register present in a given operand, use <code class="docutils literal notranslate"><span class="pre">MachineOperand::setReg(p_reg)</span></code>. To
insert a store instruction, use <code class="docutils literal notranslate"><span class="pre">TargetInstrInfo::storeRegToStackSlot(...)</span></code>,
and to insert a load instruction, use <code class="docutils literal notranslate"><span class="pre">TargetInstrInfo::loadRegFromStackSlot</span></code>.</p>
<p>The indirect mapping shields the application developer from the complexities of
inserting load and store instructions. In order to map a virtual register to a
physical one, use <code class="docutils literal notranslate"><span class="pre">VirtRegMap::assignVirt2Phys(vreg,</span> <span class="pre">preg)</span></code>.  In order to map
a certain virtual register to memory, use
<code class="docutils literal notranslate"><span class="pre">VirtRegMap::assignVirt2StackSlot(vreg)</span></code>. This method will return the stack
slot where <code class="docutils literal notranslate"><span class="pre">vreg</span></code>’s value will be located.  If it is necessary to map another
virtual register to the same stack slot, use
<code class="docutils literal notranslate"><span class="pre">VirtRegMap::assignVirt2StackSlot(vreg,</span> <span class="pre">stack_location)</span></code>. One important point
to consider when using the indirect mapping, is that even if a virtual register
is mapped to memory, it still needs to be mapped to a physical register. This
physical register is the location where the virtual register is supposed to be
found before being stored or after being reloaded.</p>
<p>If the indirect strategy is used, after all the virtual registers have been
mapped to physical registers or stack slots, it is necessary to use a spiller
object to place load and store instructions in the code. Every virtual that has
been mapped to a stack slot will be stored to memory after being defined and will
be loaded before being used. The implementation of the spiller tries to recycle
load/store instructions, avoiding unnecessary instructions. For an example of
how to invoke the spiller, see <code class="docutils literal notranslate"><span class="pre">RegAllocLinearScan::runOnMachineFunction</span></code> in
<code class="docutils literal notranslate"><span class="pre">lib/CodeGen/RegAllocLinearScan.cpp</span></code>.</p>
</div>
<div class="section" id="handling-two-address-instructions">
<h4><a class="toc-backref" href="#id54">Handling two address instructions</a><a class="headerlink" href="#handling-two-address-instructions" title="Permalink to this headline">¶</a></h4>
<p>With very rare exceptions (e.g., function calls), the LLVM machine code
instructions are three address instructions. That is, each instruction is
expected to define at most one register, and to use at most two registers.
However, some architectures use two address instructions. In this case, the
defined register is also one of the used registers. For instance, an instruction
such as <code class="docutils literal notranslate"><span class="pre">ADD</span> <span class="pre">%EAX,</span> <span class="pre">%EBX</span></code>, in X86 is actually equivalent to <code class="docutils literal notranslate"><span class="pre">%EAX</span> <span class="pre">=</span> <span class="pre">%EAX</span> <span class="pre">+</span>
<span class="pre">%EBX</span></code>.</p>
<p>In order to produce correct code, LLVM must convert three address instructions
that represent two address instructions into true two address instructions. LLVM
provides the pass <code class="docutils literal notranslate"><span class="pre">TwoAddressInstructionPass</span></code> for this specific purpose. It
must be run before register allocation takes place. After its execution, the
resulting code may no longer be in SSA form. This happens, for instance, in
situations where an instruction such as <code class="docutils literal notranslate"><span class="pre">%a</span> <span class="pre">=</span> <span class="pre">ADD</span> <span class="pre">%b</span> <span class="pre">%c</span></code> is converted to two
instructions such as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">a</span> <span class="o">=</span> <span class="n">MOVE</span> <span class="o">%</span><span class="n">b</span>
<span class="o">%</span><span class="n">a</span> <span class="o">=</span> <span class="n">ADD</span> <span class="o">%</span><span class="n">a</span> <span class="o">%</span><span class="n">c</span>
</pre></div>
</div>
<p>Notice that, internally, the second instruction is represented as <code class="docutils literal notranslate"><span class="pre">ADD</span>
<span class="pre">%a[def/use]</span> <span class="pre">%c</span></code>. I.e., the register operand <code class="docutils literal notranslate"><span class="pre">%a</span></code> is both used and defined by
the instruction.</p>
</div>
<div class="section" id="the-ssa-deconstruction-phase">
<h4><a class="toc-backref" href="#id55">The SSA deconstruction phase</a><a class="headerlink" href="#the-ssa-deconstruction-phase" title="Permalink to this headline">¶</a></h4>
<p>An important transformation that happens during register allocation is called
the <em>SSA Deconstruction Phase</em>. The SSA form simplifies many analyses that are
performed on the control flow graph of programs. However, traditional
instruction sets do not implement PHI instructions. Thus, in order to generate
executable code, compilers must replace PHI instructions with other instructions
that preserve their semantics.</p>
<p>There are many ways in which PHI instructions can safely be removed from the
target code. The most traditional PHI deconstruction algorithm replaces PHI
instructions with copy instructions. That is the strategy adopted by LLVM. The
SSA deconstruction algorithm is implemented in
<code class="docutils literal notranslate"><span class="pre">lib/CodeGen/PHIElimination.cpp</span></code>. In order to invoke this pass, the identifier
<code class="docutils literal notranslate"><span class="pre">PHIEliminationID</span></code> must be marked as required in the code of the register
allocator.</p>
</div>
<div class="section" id="instruction-folding">
<h4><a class="toc-backref" href="#id56">Instruction folding</a><a class="headerlink" href="#instruction-folding" title="Permalink to this headline">¶</a></h4>
<p><em>Instruction folding</em> is an optimization performed during register allocation
that removes unnecessary copy instructions. For instance, a sequence of
instructions such as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">EBX</span> <span class="o">=</span> <span class="n">LOAD</span> <span class="o">%</span><span class="n">mem_address</span>
<span class="o">%</span><span class="n">EAX</span> <span class="o">=</span> <span class="n">COPY</span> <span class="o">%</span><span class="n">EBX</span>
</pre></div>
</div>
<p>can be safely substituted by the single instruction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">EAX</span> <span class="o">=</span> <span class="n">LOAD</span> <span class="o">%</span><span class="n">mem_address</span>
</pre></div>
</div>
<p>Instructions can be folded with the
<code class="docutils literal notranslate"><span class="pre">TargetRegisterInfo::foldMemoryOperand(...)</span></code> method. Care must be taken when
folding instructions; a folded instruction can be quite different from the
original instruction. See <code class="docutils literal notranslate"><span class="pre">LiveIntervals::addIntervalsForSpills</span></code> in
<code class="docutils literal notranslate"><span class="pre">lib/CodeGen/LiveIntervalAnalysis.cpp</span></code> for an example of its use.</p>
</div>
<div class="section" id="built-in-register-allocators">
<h4><a class="toc-backref" href="#id57">Built in register allocators</a><a class="headerlink" href="#built-in-register-allocators" title="Permalink to this headline">¶</a></h4>
<p>The LLVM infrastructure provides the application developer with three different
register allocators:</p>
<ul class="simple">
<li><p><em>Fast</em> — This register allocator is the default for debug builds. It
allocates registers on a basic block level, attempting to keep values in
registers and reusing registers as appropriate.</p></li>
<li><p><em>Basic</em> — This is an incremental approach to register allocation. Live
ranges are assigned to registers one at a time in an order that is driven by
heuristics. Since code can be rewritten on-the-fly during allocation, this
framework allows interesting allocators to be developed as extensions. It is
not itself a production register allocator but is a potentially useful
stand-alone mode for triaging bugs and as a performance baseline.</p></li>
<li><p><em>Greedy</em> — <em>The default allocator</em>. This is a highly tuned implementation of
the <em>Basic</em> allocator that incorporates global live range splitting. This
allocator works hard to minimize the cost of spill code.</p></li>
<li><p><em>PBQP</em> — A Partitioned Boolean Quadratic Programming (PBQP) based register
allocator. This allocator works by constructing a PBQP problem representing
the register allocation problem under consideration, solving this using a PBQP
solver, and mapping the solution back to a register assignment.</p></li>
</ul>
<p>The type of register allocator used in <code class="docutils literal notranslate"><span class="pre">llc</span></code> can be chosen with the command
line option <code class="docutils literal notranslate"><span class="pre">-regalloc=...</span></code>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ llc -regalloc<span class="o">=</span>linearscan file.bc -o ln.s
$ llc -regalloc<span class="o">=</span>fast file.bc -o fa.s
$ llc -regalloc<span class="o">=</span>pbqp file.bc -o pbqp.s
</pre></div>
</div>
</div>
</div>
<div class="section" id="prolog-epilog-code-insertion">
<span id="id4"></span><h3><a class="toc-backref" href="#id58">Prolog/Epilog Code Insertion</a><a class="headerlink" href="#prolog-epilog-code-insertion" title="Permalink to this headline">¶</a></h3>
<p>Compact Unwind</p>
<p>Throwing an exception requires <em>unwinding</em> out of a function. The information on
how to unwind a given function is traditionally expressed in DWARF unwind
(a.k.a. frame) info. But that format was originally developed for debuggers to
backtrace, and each Frame Description Entry (FDE) requires ~20-30 bytes per
function. There is also the cost of mapping from an address in a function to the
corresponding FDE at runtime. An alternative unwind encoding is called <em>compact
unwind</em> and requires just 4-bytes per function.</p>
<p>The compact unwind encoding is a 32-bit value, which is encoded in an
architecture-specific way. It specifies which registers to restore and from
where, and how to unwind out of the function. When the linker creates a final
linked image, it will create a <code class="docutils literal notranslate"><span class="pre">__TEXT,__unwind_info</span></code> section. This section is
a small and fast way for the runtime to access unwind info for any given
function. If we emit compact unwind info for the function, that compact unwind
info will be encoded in the <code class="docutils literal notranslate"><span class="pre">__TEXT,__unwind_info</span></code> section. If we emit DWARF
unwind info, the <code class="docutils literal notranslate"><span class="pre">__TEXT,__unwind_info</span></code> section will contain the offset of the
FDE in the <code class="docutils literal notranslate"><span class="pre">__TEXT,__eh_frame</span></code> section in the final linked image.</p>
<p>For X86, there are three modes for the compact unwind encoding:</p>
<dl>
<dt><em>Function with a Frame Pointer (``EBP`` or ``RBP``)</em></dt><dd><p><code class="docutils literal notranslate"><span class="pre">EBP/RBP</span></code>-based frame, where <code class="docutils literal notranslate"><span class="pre">EBP/RBP</span></code> is pushed onto the stack
immediately after the return address, then <code class="docutils literal notranslate"><span class="pre">ESP/RSP</span></code> is moved to
<code class="docutils literal notranslate"><span class="pre">EBP/RBP</span></code>. Thus to unwind, <code class="docutils literal notranslate"><span class="pre">ESP/RSP</span></code> is restored with the current
<code class="docutils literal notranslate"><span class="pre">EBP/RBP</span></code> value, then <code class="docutils literal notranslate"><span class="pre">EBP/RBP</span></code> is restored by popping the stack, and the
return is done by popping the stack once more into the PC. All non-volatile
registers that need to be restored must have been saved in a small range on
the stack that starts <code class="docutils literal notranslate"><span class="pre">EBP-4</span></code> to <code class="docutils literal notranslate"><span class="pre">EBP-1020</span></code> (<code class="docutils literal notranslate"><span class="pre">RBP-8</span></code> to
<code class="docutils literal notranslate"><span class="pre">RBP-1020</span></code>). The offset (divided by 4 in 32-bit mode and 8 in 64-bit mode)
is encoded in bits 16-23 (mask: <code class="docutils literal notranslate"><span class="pre">0x00FF0000</span></code>).  The registers saved are
encoded in bits 0-14 (mask: <code class="docutils literal notranslate"><span class="pre">0x00007FFF</span></code>) as five 3-bit entries from the
following table:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 31%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Compact Number</p></th>
<th class="head"><p>i386 Register</p></th>
<th class="head"><p>x86-64 Register</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">EBX</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">RBX</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ECX</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">R12</span></code></p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">EDX</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">R13</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">EDI</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">R14</span></code></p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ESI</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">R15</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">EBP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">RBP</span></code></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd>
<dt><em>Frameless with a Small Constant Stack Size (``EBP`` or ``RBP`` is not used as a frame pointer)</em></dt><dd><p>To return, a constant (encoded in the compact unwind encoding) is added to the
<code class="docutils literal notranslate"><span class="pre">ESP/RSP</span></code>.  Then the return is done by popping the stack into the PC. All
non-volatile registers that need to be restored must have been saved on the
stack immediately after the return address. The stack size (divided by 4 in
32-bit mode and 8 in 64-bit mode) is encoded in bits 16-23 (mask:
<code class="docutils literal notranslate"><span class="pre">0x00FF0000</span></code>). There is a maximum stack size of 1024 bytes in 32-bit mode
and 2048 in 64-bit mode. The number of registers saved is encoded in bits 9-12
(mask: <code class="docutils literal notranslate"><span class="pre">0x00001C00</span></code>). Bits 0-9 (mask: <code class="docutils literal notranslate"><span class="pre">0x000003FF</span></code>) contain which
registers were saved and their order. (See the
<code class="docutils literal notranslate"><span class="pre">encodeCompactUnwindRegistersWithoutFrame()</span></code> function in
<code class="docutils literal notranslate"><span class="pre">lib/Target/X86FrameLowering.cpp</span></code> for the encoding algorithm.)</p>
</dd>
<dt><em>Frameless with a Large Constant Stack Size (``EBP`` or ``RBP`` is not used as a frame pointer)</em></dt><dd><p>This case is like the “Frameless with a Small Constant Stack Size” case, but
the stack size is too large to encode in the compact unwind encoding. Instead
it requires that the function contains “<code class="docutils literal notranslate"><span class="pre">subl</span> <span class="pre">$nnnnnn,</span> <span class="pre">%esp</span></code>” in its
prolog. The compact encoding contains the offset to the <code class="docutils literal notranslate"><span class="pre">$nnnnnn</span></code> value in
the function in bits 9-12 (mask: <code class="docutils literal notranslate"><span class="pre">0x00001C00</span></code>).</p>
</dd>
</dl>
</div>
<div class="section" id="late-machine-code-optimizations">
<span id="id5"></span><h3><a class="toc-backref" href="#id59">Late Machine Code Optimizations</a><a class="headerlink" href="#late-machine-code-optimizations" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To Be Written</p>
</div>
</div>
<div class="section" id="code-emission">
<span id="id6"></span><h3><a class="toc-backref" href="#id60">Code Emission</a><a class="headerlink" href="#code-emission" title="Permalink to this headline">¶</a></h3>
<p>The code emission step of code generation is responsible for lowering from the
code generator abstractions (like <a class="reference internal" href="#machinefunction">MachineFunction</a>, <a class="reference internal" href="#machineinstr">MachineInstr</a>, etc) down
to the abstractions used by the MC layer (<a class="reference internal" href="#mcinst">MCInst</a>, <a class="reference internal" href="#mcstreamer">MCStreamer</a>, etc).  This
is done with a combination of several different classes: the (misnamed)
target-independent AsmPrinter class, target-specific subclasses of AsmPrinter
(such as SparcAsmPrinter), and the TargetLoweringObjectFile class.</p>
<p>Since the MC layer works at the level of abstraction of object files, it doesn’t
have a notion of functions, global variables etc.  Instead, it thinks about
labels, directives, and instructions.  A key class used at this time is the
MCStreamer class.  This is an abstract API that is implemented in different ways
(e.g. to output a .s file, output an ELF .o file, etc) that is effectively an
“assembler API”.  MCStreamer has one method per directive, such as EmitLabel,
EmitSymbolAttribute, SwitchSection, etc, which directly correspond to assembly
level directives.</p>
<p>If you are interested in implementing a code generator for a target, there are
three important things that you have to implement for your target:</p>
<ol class="arabic simple">
<li><p>First, you need a subclass of AsmPrinter for your target.  This class
implements the general lowering process converting MachineFunction’s into MC
label constructs.  The AsmPrinter base class provides a number of useful
methods and routines, and also allows you to override the lowering process in
some important ways.  You should get much of the lowering for free if you are
implementing an ELF, COFF, or MachO target, because the
TargetLoweringObjectFile class implements much of the common logic.</p></li>
<li><p>Second, you need to implement an instruction printer for your target.  The
instruction printer takes an <a class="reference internal" href="#mcinst">MCInst</a> and renders it to a raw_ostream as
text.  Most of this is automatically generated from the .td file (when you
specify something like “<code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">$dst,</span> <span class="pre">$src1,</span> <span class="pre">$src2</span></code>” in the instructions), but
you need to implement routines to print operands.</p></li>
<li><p>Third, you need to implement code that lowers a <a class="reference internal" href="#machineinstr">MachineInstr</a> to an MCInst,
usually implemented in “&lt;target&gt;MCInstLower.cpp”.  This lowering process is
often target specific, and is responsible for turning jump table entries,
constant pool indices, global variable addresses, etc into MCLabels as
appropriate.  This translation layer is also responsible for expanding pseudo
ops used by the code generator into the actual machine instructions they
correspond to. The MCInsts that are generated by this are fed into the
instruction printer or the encoder.</p></li>
</ol>
<p>Finally, at your choosing, you can also implement a subclass of MCCodeEmitter
which lowers MCInst’s into machine code bytes and relocations.  This is
important if you want to support direct .o file emission, or would like to
implement an assembler for your target.</p>
<div class="section" id="emitting-function-stack-size-information">
<h4><a class="toc-backref" href="#id61">Emitting function stack size information</a><a class="headerlink" href="#emitting-function-stack-size-information" title="Permalink to this headline">¶</a></h4>
<p>A section containing metadata on function stack sizes will be emitted when
<code class="docutils literal notranslate"><span class="pre">TargetLoweringObjectFile::StackSizesSection</span></code> is not null, and
<code class="docutils literal notranslate"><span class="pre">TargetOptions::EmitStackSizeSection</span></code> is set (-stack-size-section). The
section will contain an array of pairs of function symbol values (pointer size)
and stack sizes (unsigned LEB128). The stack size values only include the space
allocated in the function prologue. Functions with dynamic stack allocations are
not included.</p>
</div>
</div>
<div class="section" id="vliw-packetizer">
<h3><a class="toc-backref" href="#id62">VLIW Packetizer</a><a class="headerlink" href="#vliw-packetizer" title="Permalink to this headline">¶</a></h3>
<p>In a Very Long Instruction Word (VLIW) architecture, the compiler is responsible
for mapping instructions to functional-units available on the architecture. To
that end, the compiler creates groups of instructions called <em>packets</em> or
<em>bundles</em>. The VLIW packetizer in LLVM is a target-independent mechanism to
enable the packetization of machine instructions.</p>
<div class="section" id="mapping-from-instructions-to-functional-units">
<h4><a class="toc-backref" href="#id63">Mapping from instructions to functional units</a><a class="headerlink" href="#mapping-from-instructions-to-functional-units" title="Permalink to this headline">¶</a></h4>
<p>Instructions in a VLIW target can typically be mapped to multiple functional
units. During the process of packetizing, the compiler must be able to reason
about whether an instruction can be added to a packet. This decision can be
complex since the compiler has to examine all possible mappings of instructions
to functional units. Therefore to alleviate compilation-time complexity, the
VLIW packetizer parses the instruction classes of a target and generates tables
at compiler build time. These tables can then be queried by the provided
machine-independent API to determine if an instruction can be accommodated in a
packet.</p>
</div>
<div class="section" id="how-the-packetization-tables-are-generated-and-used">
<h4><a class="toc-backref" href="#id64">How the packetization tables are generated and used</a><a class="headerlink" href="#how-the-packetization-tables-are-generated-and-used" title="Permalink to this headline">¶</a></h4>
<p>The packetizer reads instruction classes from a target’s itineraries and creates
a deterministic finite automaton (DFA) to represent the state of a packet. A DFA
consists of three major elements: inputs, states, and transitions. The set of
inputs for the generated DFA represents the instruction being added to a
packet. The states represent the possible consumption of functional units by
instructions in a packet. In the DFA, transitions from one state to another
occur on the addition of an instruction to an existing packet. If there is a
legal mapping of functional units to instructions, then the DFA contains a
corresponding transition. The absence of a transition indicates that a legal
mapping does not exist and that the instruction cannot be added to the packet.</p>
<p>To generate tables for a VLIW target, add <em>Target</em>GenDFAPacketizer.inc as a
target to the Makefile in the target directory. The exported API provides three
functions: <code class="docutils literal notranslate"><span class="pre">DFAPacketizer::clearResources()</span></code>,
<code class="docutils literal notranslate"><span class="pre">DFAPacketizer::reserveResources(MachineInstr</span> <span class="pre">*MI)</span></code>, and
<code class="docutils literal notranslate"><span class="pre">DFAPacketizer::canReserveResources(MachineInstr</span> <span class="pre">*MI)</span></code>. These functions allow
a target packetizer to add an instruction to an existing packet and to check
whether an instruction can be added to a packet. See
<code class="docutils literal notranslate"><span class="pre">llvm/CodeGen/DFAPacketizer.h</span></code> for more information.</p>
</div>
</div>
</div>
<div class="section" id="implementing-a-native-assembler">
<h2><a class="toc-backref" href="#id65">Implementing a Native Assembler</a><a class="headerlink" href="#implementing-a-native-assembler" title="Permalink to this headline">¶</a></h2>
<p>Though you’re probably reading this because you want to write or maintain a
compiler backend, LLVM also fully supports building a native assembler.
We’ve tried hard to automate the generation of the assembler from the .td files
(in particular the instruction syntax and encodings), which means that a large
part of the manual and repetitive data entry can be factored and shared with the
compiler.</p>
<div class="section" id="instruction-parsing">
<h3><a class="toc-backref" href="#id66">Instruction Parsing</a><a class="headerlink" href="#instruction-parsing" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To Be Written</p>
</div>
</div>
<div class="section" id="instruction-alias-processing">
<h3><a class="toc-backref" href="#id67">Instruction Alias Processing</a><a class="headerlink" href="#instruction-alias-processing" title="Permalink to this headline">¶</a></h3>
<p>Once the instruction is parsed, it enters the MatchInstructionImpl function.
The MatchInstructionImpl function performs alias processing and then does actual
matching.</p>
<p>Alias processing is the phase that canonicalizes different lexical forms of the
same instructions down to one representation.  There are several different kinds
of alias that are possible to implement and they are listed below in the order
that they are processed (which is in order from simplest/weakest to most
complex/powerful).  Generally you want to use the first alias mechanism that
meets the needs of your instruction, because it will allow a more concise
description.</p>
<div class="section" id="mnemonic-aliases">
<h4><a class="toc-backref" href="#id68">Mnemonic Aliases</a><a class="headerlink" href="#mnemonic-aliases" title="Permalink to this headline">¶</a></h4>
<p>The first phase of alias processing is simple instruction mnemonic remapping for
classes of instructions which are allowed with two different mnemonics.  This
phase is a simple and unconditionally remapping from one input mnemonic to one
output mnemonic.  It isn’t possible for this form of alias to look at the
operands at all, so the remapping must apply for all forms of a given mnemonic.
Mnemonic aliases are defined simply, for example X86 has:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>def : MnemonicAlias&lt;&quot;cbw&quot;,     &quot;cbtw&quot;&gt;;
def : MnemonicAlias&lt;&quot;smovq&quot;,   &quot;movsq&quot;&gt;;
def : MnemonicAlias&lt;&quot;fldcww&quot;,  &quot;fldcw&quot;&gt;;
def : MnemonicAlias&lt;&quot;fucompi&quot;, &quot;fucomip&quot;&gt;;
def : MnemonicAlias&lt;&quot;ud2a&quot;,    &quot;ud2&quot;&gt;;
</pre></div>
</div>
<p>… and many others.  With a MnemonicAlias definition, the mnemonic is remapped
simply and directly.  Though MnemonicAlias’s can’t look at any aspect of the
instruction (such as the operands) they can depend on global modes (the same
ones supported by the matcher), through a Requires clause:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>def : MnemonicAlias&lt;&quot;pushf&quot;, &quot;pushfq&quot;&gt;, Requires&lt;[In64BitMode]&gt;;
def : MnemonicAlias&lt;&quot;pushf&quot;, &quot;pushfl&quot;&gt;, Requires&lt;[In32BitMode]&gt;;
</pre></div>
</div>
<p>In this example, the mnemonic gets mapped into a different one depending on
the current instruction set.</p>
</div>
<div class="section" id="instruction-aliases">
<h4><a class="toc-backref" href="#id69">Instruction Aliases</a><a class="headerlink" href="#instruction-aliases" title="Permalink to this headline">¶</a></h4>
<p>The most general phase of alias processing occurs while matching is happening:
it provides new forms for the matcher to match along with a specific instruction
to generate.  An instruction alias has two parts: the string to match and the
instruction to generate.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>def : InstAlias&lt;&quot;movsx $src, $dst&quot;, (MOVSX16rr8W GR16:$dst, GR8  :$src)&gt;;
def : InstAlias&lt;&quot;movsx $src, $dst&quot;, (MOVSX16rm8W GR16:$dst, i8mem:$src)&gt;;
def : InstAlias&lt;&quot;movsx $src, $dst&quot;, (MOVSX32rr8  GR32:$dst, GR8  :$src)&gt;;
def : InstAlias&lt;&quot;movsx $src, $dst&quot;, (MOVSX32rr16 GR32:$dst, GR16 :$src)&gt;;
def : InstAlias&lt;&quot;movsx $src, $dst&quot;, (MOVSX64rr8  GR64:$dst, GR8  :$src)&gt;;
def : InstAlias&lt;&quot;movsx $src, $dst&quot;, (MOVSX64rr16 GR64:$dst, GR16 :$src)&gt;;
def : InstAlias&lt;&quot;movsx $src, $dst&quot;, (MOVSX64rr32 GR64:$dst, GR32 :$src)&gt;;
</pre></div>
</div>
<p>This shows a powerful example of the instruction aliases, matching the same
mnemonic in multiple different ways depending on what operands are present in
the assembly.  The result of instruction aliases can include operands in a
different order than the destination instruction, and can use an input multiple
times, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>def : InstAlias&lt;&quot;clrb $reg&quot;, (XOR8rr  GR8 :$reg, GR8 :$reg)&gt;;
def : InstAlias&lt;&quot;clrw $reg&quot;, (XOR16rr GR16:$reg, GR16:$reg)&gt;;
def : InstAlias&lt;&quot;clrl $reg&quot;, (XOR32rr GR32:$reg, GR32:$reg)&gt;;
def : InstAlias&lt;&quot;clrq $reg&quot;, (XOR64rr GR64:$reg, GR64:$reg)&gt;;
</pre></div>
</div>
<p>This example also shows that tied operands are only listed once.  In the X86
backend, XOR8rr has two input GR8’s and one output GR8 (where an input is tied
to the output).  InstAliases take a flattened operand list without duplicates
for tied operands.  The result of an instruction alias can also use immediates
and fixed physical registers which are added as simple immediate operands in the
result, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Fixed Immediate operand.
def : InstAlias&lt;&quot;aad&quot;, (AAD8i8 10)&gt;;

// Fixed register operand.
def : InstAlias&lt;&quot;fcomi&quot;, (COM_FIr ST1)&gt;;

// Simple alias.
def : InstAlias&lt;&quot;fcomi $reg&quot;, (COM_FIr RST:$reg)&gt;;
</pre></div>
</div>
<p>Instruction aliases can also have a Requires clause to make them subtarget
specific.</p>
<p>If the back-end supports it, the instruction printer can automatically emit the
alias rather than what’s being aliased. It typically leads to better, more
readable code. If it’s better to print out what’s being aliased, then pass a ‘0’
as the third parameter to the InstAlias definition.</p>
</div>
</div>
<div class="section" id="instruction-matching">
<h3><a class="toc-backref" href="#id70">Instruction Matching</a><a class="headerlink" href="#instruction-matching" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To Be Written</p>
</div>
</div>
</div>
<div class="section" id="target-specific-implementation-notes">
<span id="implement-the-target-description"></span><span id="implementations-of-the-abstract-target-description-interfaces"></span><h2><a class="toc-backref" href="#id71">Target-specific Implementation Notes</a><a class="headerlink" href="#target-specific-implementation-notes" title="Permalink to this headline">¶</a></h2>
<p>This section of the document explains features or design decisions that are
specific to the code generator for a particular target.  First we start with a
table that summarizes what features are supported by each target.</p>
<div class="section" id="target-feature-matrix">
<span id="id7"></span><h3><a class="toc-backref" href="#id72">Target Feature Matrix</a><a class="headerlink" href="#target-feature-matrix" title="Permalink to this headline">¶</a></h3>
<p>Note that this table does not list features that are not supported fully by any
target yet.  It considers a feature to be supported if at least one subtarget
supports it.  A feature being supported means that it is useful and works for
most cases, it does not indicate that there are zero known bugs in the
implementation.  Here is the key:</p>
<p><span class="raw-html"><table border="1" cellspacing="0"></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><th>Unknown</th></span>
<span class="raw-html"><th>Not Applicable</th></span>
<span class="raw-html"><th>No support</th></span>
<span class="raw-html"><th>Partial Support</th></span>
<span class="raw-html"><th>Complete Support</th></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td class="unknown"></td></span>
<span class="raw-html"><td class="na"></td></span>
<span class="raw-html"><td class="no"></td></span>
<span class="raw-html"><td class="partial"></td></span>
<span class="raw-html"><td class="yes"></td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"></table></span></p>
<p>Here is the table:</p>
<p><span class="raw-html"><table width="689" border="1" cellspacing="0"></span>
<span class="raw-html"><tr><td></td></span>
<span class="raw-html"><td colspan="13" align="center" style="background-color:#ffc">Target</td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><th>Feature</th></span>
<span class="raw-html"><th>ARM</th></span>
<span class="raw-html"><th>Hexagon</th></span>
<span class="raw-html"><th>MSP430</th></span>
<span class="raw-html"><th>Mips</th></span>
<span class="raw-html"><th>NVPTX</th></span>
<span class="raw-html"><th>PowerPC</th></span>
<span class="raw-html"><th>Sparc</th></span>
<span class="raw-html"><th>SystemZ</th></span>
<span class="raw-html"><th>X86</th></span>
<span class="raw-html"><th>XCore</th></span>
<span class="raw-html"><th>eBPF</th></span>
<span class="raw-html"></tr></span></p>
<p><span class="raw-html"><tr></span>
<span class="raw-html"><td><a href="#feat_reliable">is generally reliable</a></td></span>
<span class="raw-html"><td class="yes"></td> <!-- ARM --></span>
<span class="raw-html"><td class="yes"></td> <!-- Hexagon --></span>
<span class="raw-html"><td class="unknown"></td> <!-- MSP430 --></span>
<span class="raw-html"><td class="yes"></td> <!-- Mips --></span>
<span class="raw-html"><td class="yes"></td> <!-- NVPTX --></span>
<span class="raw-html"><td class="yes"></td> <!-- PowerPC --></span>
<span class="raw-html"><td class="yes"></td> <!-- Sparc --></span>
<span class="raw-html"><td class="yes"></td> <!-- SystemZ --></span>
<span class="raw-html"><td class="yes"></td> <!-- X86 --></span>
<span class="raw-html"><td class="yes"></td> <!-- XCore --></span>
<span class="raw-html"><td class="yes"></td> <!-- eBPF --></span>
<span class="raw-html"></tr></span></p>
<p><span class="raw-html"><tr></span>
<span class="raw-html"><td><a href="#feat_asmparser">assembly parser</a></td></span>
<span class="raw-html"><td class="no"></td> <!-- ARM --></span>
<span class="raw-html"><td class="no"></td> <!-- Hexagon --></span>
<span class="raw-html"><td class="no"></td> <!-- MSP430 --></span>
<span class="raw-html"><td class="no"></td> <!-- Mips --></span>
<span class="raw-html"><td class="no"></td> <!-- NVPTX --></span>
<span class="raw-html"><td class="no"></td> <!-- PowerPC --></span>
<span class="raw-html"><td class="no"></td> <!-- Sparc --></span>
<span class="raw-html"><td class="yes"></td> <!-- SystemZ --></span>
<span class="raw-html"><td class="yes"></td> <!-- X86 --></span>
<span class="raw-html"><td class="no"></td> <!-- XCore --></span>
<span class="raw-html"><td class="no"></td> <!-- eBPF --></span>
<span class="raw-html"></tr></span></p>
<p><span class="raw-html"><tr></span>
<span class="raw-html"><td><a href="#feat_disassembler">disassembler</a></td></span>
<span class="raw-html"><td class="yes"></td> <!-- ARM --></span>
<span class="raw-html"><td class="no"></td> <!-- Hexagon --></span>
<span class="raw-html"><td class="no"></td> <!-- MSP430 --></span>
<span class="raw-html"><td class="no"></td> <!-- Mips --></span>
<span class="raw-html"><td class="na"></td> <!-- NVPTX --></span>
<span class="raw-html"><td class="no"></td> <!-- PowerPC --></span>
<span class="raw-html"><td class="yes"></td> <!-- SystemZ --></span>
<span class="raw-html"><td class="no"></td> <!-- Sparc --></span>
<span class="raw-html"><td class="yes"></td> <!-- X86 --></span>
<span class="raw-html"><td class="yes"></td> <!-- XCore --></span>
<span class="raw-html"><td class="yes"></td> <!-- eBPF --></span>
<span class="raw-html"></tr></span></p>
<p><span class="raw-html"><tr></span>
<span class="raw-html"><td><a href="#feat_inlineasm">inline asm</a></td></span>
<span class="raw-html"><td class="yes"></td> <!-- ARM --></span>
<span class="raw-html"><td class="yes"></td> <!-- Hexagon --></span>
<span class="raw-html"><td class="unknown"></td> <!-- MSP430 --></span>
<span class="raw-html"><td class="no"></td> <!-- Mips --></span>
<span class="raw-html"><td class="yes"></td> <!-- NVPTX --></span>
<span class="raw-html"><td class="yes"></td> <!-- PowerPC --></span>
<span class="raw-html"><td class="unknown"></td> <!-- Sparc --></span>
<span class="raw-html"><td class="yes"></td> <!-- SystemZ --></span>
<span class="raw-html"><td class="yes"></td> <!-- X86 --></span>
<span class="raw-html"><td class="yes"></td> <!-- XCore --></span>
<span class="raw-html"><td class="no"></td> <!-- eBPF --></span>
<span class="raw-html"></tr></span></p>
<p><span class="raw-html"><tr></span>
<span class="raw-html"><td><a href="#feat_jit">jit</a></td></span>
<span class="raw-html"><td class="partial"><a href="#feat_jit_arm">*</a></td> <!-- ARM --></span>
<span class="raw-html"><td class="no"></td> <!-- Hexagon --></span>
<span class="raw-html"><td class="unknown"></td> <!-- MSP430 --></span>
<span class="raw-html"><td class="yes"></td> <!-- Mips --></span>
<span class="raw-html"><td class="na"></td> <!-- NVPTX --></span>
<span class="raw-html"><td class="yes"></td> <!-- PowerPC --></span>
<span class="raw-html"><td class="unknown"></td> <!-- Sparc --></span>
<span class="raw-html"><td class="yes"></td> <!-- SystemZ --></span>
<span class="raw-html"><td class="yes"></td> <!-- X86 --></span>
<span class="raw-html"><td class="no"></td> <!-- XCore --></span>
<span class="raw-html"><td class="yes"></td> <!-- eBPF --></span>
<span class="raw-html"></tr></span></p>
<p><span class="raw-html"><tr></span>
<span class="raw-html"><td><a href="#feat_objectwrite">.o&nbsp;file writing</a></td></span>
<span class="raw-html"><td class="no"></td> <!-- ARM --></span>
<span class="raw-html"><td class="no"></td> <!-- Hexagon --></span>
<span class="raw-html"><td class="no"></td> <!-- MSP430 --></span>
<span class="raw-html"><td class="no"></td> <!-- Mips --></span>
<span class="raw-html"><td class="na"></td> <!-- NVPTX --></span>
<span class="raw-html"><td class="no"></td> <!-- PowerPC --></span>
<span class="raw-html"><td class="no"></td> <!-- Sparc --></span>
<span class="raw-html"><td class="yes"></td> <!-- SystemZ --></span>
<span class="raw-html"><td class="yes"></td> <!-- X86 --></span>
<span class="raw-html"><td class="no"></td> <!-- XCore --></span>
<span class="raw-html"><td class="yes"></td> <!-- eBPF --></span>
<span class="raw-html"></tr></span></p>
<p><span class="raw-html"><tr></span>
<span class="raw-html"><td><a hr:raw-html:`ef="#feat_tailcall">tail calls</a></td></span>
<span class="raw-html"><td class="yes"></td> <!-- ARM --></span>
<span class="raw-html"><td class="yes"></td> <!-- Hexagon --></span>
<span class="raw-html"><td class="unknown"></td> <!-- MSP430 --></span>
<span class="raw-html"><td class="no"></td> <!-- Mips --></span>
<span class="raw-html"><td class="no"></td> <!-- NVPTX --></span>
<span class="raw-html"><td class="yes"></td> <!-- PowerPC --></span>
<span class="raw-html"><td class="unknown"></td> <!-- Sparc --></span>
<span class="raw-html"><td class="no"></td> <!-- SystemZ --></span>
<span class="raw-html"><td class="yes"></td> <!-- X86 --></span>
<span class="raw-html"><td class="no"></td> <!-- XCore --></span>
<span class="raw-html"><td class="no"></td> <!-- eBPF --></span>
<span class="raw-html"></tr></span></p>
<p><span class="raw-html"><tr></span>
<span class="raw-html"><td><a href="#feat_segstacks">segmented stacks</a></td></span>
<span class="raw-html"><td class="no"></td> <!-- ARM --></span>
<span class="raw-html"><td class="no"></td> <!-- Hexagon --></span>
<span class="raw-html"><td class="no"></td> <!-- MSP430 --></span>
<span class="raw-html"><td class="no"></td> <!-- Mips --></span>
<span class="raw-html"><td class="no"></td> <!-- NVPTX --></span>
<span class="raw-html"><td class="no"></td> <!-- PowerPC --></span>
<span class="raw-html"><td class="no"></td> <!-- Sparc --></span>
<span class="raw-html"><td class="no"></td> <!-- SystemZ --></span>
<span class="raw-html"><td class="partial"><a href="#feat_segstacks_x86">*</a></td> <!-- X86 --></span>
<span class="raw-html"><td class="no"></td> <!-- XCore --></span>
<span class="raw-html"><td class="no"></td> <!-- eBPF --></span>
<span class="raw-html"></tr></span></p>
<p><span class="raw-html"></table></span></p>
<div class="section" id="is-generally-reliable">
<span id="feat-reliable"></span><h4><a class="toc-backref" href="#id73">Is Generally Reliable</a><a class="headerlink" href="#is-generally-reliable" title="Permalink to this headline">¶</a></h4>
<p>This box indicates whether the target is considered to be production quality.
This indicates that the target has been used as a static compiler to compile
large amounts of code by a variety of different people and is in continuous use.</p>
</div>
<div class="section" id="assembly-parser">
<span id="feat-asmparser"></span><h4><a class="toc-backref" href="#id74">Assembly Parser</a><a class="headerlink" href="#assembly-parser" title="Permalink to this headline">¶</a></h4>
<p>This box indicates whether the target supports parsing target specific .s files
by implementing the MCAsmParser interface.  This is required for llvm-mc to be
able to act as a native assembler and is required for inline assembly support in
the native .o file writer.</p>
</div>
<div class="section" id="disassembler">
<span id="feat-disassembler"></span><h4><a class="toc-backref" href="#id75">Disassembler</a><a class="headerlink" href="#disassembler" title="Permalink to this headline">¶</a></h4>
<p>This box indicates whether the target supports the MCDisassembler API for
disassembling machine opcode bytes into MCInst’s.</p>
</div>
<div class="section" id="inline-asm">
<span id="feat-inlineasm"></span><h4><a class="toc-backref" href="#id76">Inline Asm</a><a class="headerlink" href="#inline-asm" title="Permalink to this headline">¶</a></h4>
<p>This box indicates whether the target supports most popular inline assembly
constraints and modifiers.</p>
</div>
<div class="section" id="jit-support">
<span id="feat-jit"></span><h4><a class="toc-backref" href="#id77">JIT Support</a><a class="headerlink" href="#jit-support" title="Permalink to this headline">¶</a></h4>
<p>This box indicates whether the target supports the JIT compiler through the
ExecutionEngine interface.</p>
<p id="feat-jit-arm">The ARM backend has basic support for integer code in ARM codegen mode, but
lacks NEON and full Thumb support.</p>
</div>
<div class="section" id="o-file-writing">
<span id="feat-objectwrite"></span><h4><a class="toc-backref" href="#id78">.o File Writing</a><a class="headerlink" href="#o-file-writing" title="Permalink to this headline">¶</a></h4>
<p>This box indicates whether the target supports writing .o files (e.g. MachO,
ELF, and/or COFF) files directly from the target.  Note that the target also
must include an assembly parser and general inline assembly support for full
inline assembly support in the .o writer.</p>
<p>Targets that don’t support this feature can obviously still write out .o files,
they just rely on having an external assembler to translate from a .s file to a
.o file (as is the case for many C compilers).</p>
</div>
<div class="section" id="tail-calls">
<span id="feat-tailcall"></span><h4><a class="toc-backref" href="#id79">Tail Calls</a><a class="headerlink" href="#tail-calls" title="Permalink to this headline">¶</a></h4>
<p>This box indicates whether the target supports guaranteed tail calls.  These are
calls marked “<a class="reference external" href="LangRef.html#i_call">tail</a>” and use the fastcc calling
convention.  Please see the <a class="reference internal" href="#tail-call-section">tail call section</a> for more details.</p>
</div>
<div class="section" id="segmented-stacks">
<span id="feat-segstacks"></span><h4><a class="toc-backref" href="#id80">Segmented Stacks</a><a class="headerlink" href="#segmented-stacks" title="Permalink to this headline">¶</a></h4>
<p>This box indicates whether the target supports segmented stacks. This replaces
the traditional large C stack with many linked segments. It is compatible with
the <a class="reference external" href="http://gcc.gnu.org/wiki/SplitStacks">gcc implementation</a> used by the Go
front end.</p>
<p id="feat-segstacks-x86">Basic support exists on the X86 backend. Currently vararg doesn’t work and the
object files are not marked the way the gold linker expects, but simple Go
programs can be built by dragonegg.</p>
</div>
</div>
<div class="section" id="tail-call-optimization">
<span id="tail-call-section"></span><h3><a class="toc-backref" href="#id81">Tail call optimization</a><a class="headerlink" href="#tail-call-optimization" title="Permalink to this headline">¶</a></h3>
<p>Tail call optimization, callee reusing the stack of the caller, is currently
supported on x86/x86-64, PowerPC, and WebAssembly. It is performed on x86/x86-64
and PowerPC if:</p>
<ul class="simple">
<li><p>Caller and callee have the calling convention <code class="docutils literal notranslate"><span class="pre">fastcc</span></code>, <code class="docutils literal notranslate"><span class="pre">cc</span> <span class="pre">10</span></code> (GHC
calling convention) or <code class="docutils literal notranslate"><span class="pre">cc</span> <span class="pre">11</span></code> (HiPE calling convention).</p></li>
<li><p>The call is a tail call - in tail position (ret immediately follows call and
ret uses value of call or is void).</p></li>
<li><p>Option <code class="docutils literal notranslate"><span class="pre">-tailcallopt</span></code> is enabled.</p></li>
<li><p>Platform-specific constraints are met.</p></li>
</ul>
<p>x86/x86-64 constraints:</p>
<ul class="simple">
<li><p>No variable argument lists are used.</p></li>
<li><p>On x86-64 when generating GOT/PIC code only module-local calls (visibility =
hidden or protected) are supported.</p></li>
</ul>
<p>PowerPC constraints:</p>
<ul class="simple">
<li><p>No variable argument lists are used.</p></li>
<li><p>No byval parameters are used.</p></li>
<li><p>On ppc32/64 GOT/PIC only module-local calls (visibility = hidden or protected)
are supported.</p></li>
</ul>
<p>On WebAssembly, tail calls are lowered to <code class="docutils literal notranslate"><span class="pre">return_call</span></code> and
<code class="docutils literal notranslate"><span class="pre">return_call_indirect</span></code> instructions whenever the ‘tail-call’ target attribute
is enabled.</p>
<p>Example:</p>
<p>Call as <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-tailcallopt</span> <span class="pre">test.ll</span></code>.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span> <span class="k">fastcc</span> <span class="k">i32</span> <span class="vg">@tailcallee</span><span class="p">(</span><span class="k">i32</span> <span class="k">inreg</span> <span class="nv">%a1</span><span class="p">,</span> <span class="k">i32</span> <span class="k">inreg</span> <span class="nv">%a2</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%a3</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%a4</span><span class="p">)</span>

<span class="k">define</span> <span class="k">fastcc</span> <span class="k">i32</span> <span class="vg">@tailcaller</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%in1</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%in2</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">%l1</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="nv">%in1</span><span class="p">,</span> <span class="nv">%in2</span>
  <span class="nv">%tmp</span> <span class="p">=</span> <span class="k">tail</span> <span class="k">call</span> <span class="k">fastcc</span> <span class="k">i32</span> <span class="vg">@tailcallee</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%in1</span> <span class="k">inreg</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%in2</span> <span class="k">inreg</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%in1</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%l1</span><span class="p">)</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="nv">%tmp</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Implications of <code class="docutils literal notranslate"><span class="pre">-tailcallopt</span></code>:</p>
<p>To support tail call optimization in situations where the callee has more
arguments than the caller a ‘callee pops arguments’ convention is used. This
currently causes each <code class="docutils literal notranslate"><span class="pre">fastcc</span></code> call that is not tail call optimized (because
one or more of above constraints are not met) to be followed by a readjustment
of the stack. So performance might be worse in such cases.</p>
</div>
<div class="section" id="sibling-call-optimization">
<h3><a class="toc-backref" href="#id82">Sibling call optimization</a><a class="headerlink" href="#sibling-call-optimization" title="Permalink to this headline">¶</a></h3>
<p>Sibling call optimization is a restricted form of tail call optimization.
Unlike tail call optimization described in the previous section, it can be
performed automatically on any tail calls when <code class="docutils literal notranslate"><span class="pre">-tailcallopt</span></code> option is not
specified.</p>
<p>Sibling call optimization is currently performed on x86/x86-64 when the
following constraints are met:</p>
<ul class="simple">
<li><p>Caller and callee have the same calling convention. It can be either <code class="docutils literal notranslate"><span class="pre">c</span></code> or
<code class="docutils literal notranslate"><span class="pre">fastcc</span></code>.</p></li>
<li><p>The call is a tail call - in tail position (ret immediately follows call and
ret uses value of call or is void).</p></li>
<li><p>Caller and callee have matching return type or the callee result is not used.</p></li>
<li><p>If any of the callee arguments are being passed in stack, they must be
available in caller’s own incoming argument stack and the frame offsets must
be the same.</p></li>
</ul>
<p>Example:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span> <span class="k">i32</span> <span class="vg">@bar</span><span class="p">(</span><span class="k">i32</span><span class="p">,</span> <span class="k">i32</span><span class="p">)</span>

<span class="k">define</span> <span class="k">i32</span> <span class="vg">@foo</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%a</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%b</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%c</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="nv nv-Anonymous">%0</span> <span class="p">=</span> <span class="k">tail</span> <span class="k">call</span> <span class="k">i32</span> <span class="vg">@bar</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%a</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%b</span><span class="p">)</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="nv nv-Anonymous">%0</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="the-x86-backend">
<h3><a class="toc-backref" href="#id83">The X86 backend</a><a class="headerlink" href="#the-x86-backend" title="Permalink to this headline">¶</a></h3>
<p>The X86 code generator lives in the <code class="docutils literal notranslate"><span class="pre">lib/Target/X86</span></code> directory.  This code
generator is capable of targeting a variety of x86-32 and x86-64 processors, and
includes support for ISA extensions such as MMX and SSE.</p>
<div class="section" id="x86-target-triples-supported">
<h4><a class="toc-backref" href="#id84">X86 Target Triples supported</a><a class="headerlink" href="#x86-target-triples-supported" title="Permalink to this headline">¶</a></h4>
<p>The following are the known target triples that are supported by the X86
backend.  This is not an exhaustive list, and it would be useful to add those
that people test.</p>
<ul class="simple">
<li><p><strong>i686-pc-linux-gnu</strong> — Linux</p></li>
<li><p><strong>i386-unknown-freebsd5.3</strong> — FreeBSD 5.3</p></li>
<li><p><strong>i686-pc-cygwin</strong> — Cygwin on Win32</p></li>
<li><p><strong>i686-pc-mingw32</strong> — MingW on Win32</p></li>
<li><p><strong>i386-pc-mingw32msvc</strong> — MingW crosscompiler on Linux</p></li>
<li><p><strong>i686-apple-darwin*</strong> — Apple Darwin on X86</p></li>
<li><p><strong>x86_64-unknown-linux-gnu</strong> — Linux</p></li>
</ul>
</div>
<div class="section" id="x86-calling-conventions-supported">
<h4><a class="toc-backref" href="#id85">X86 Calling Conventions supported</a><a class="headerlink" href="#x86-calling-conventions-supported" title="Permalink to this headline">¶</a></h4>
<p>The following target-specific calling conventions are known to backend:</p>
<ul class="simple">
<li><p><strong>x86_StdCall</strong> — stdcall calling convention seen on Microsoft Windows
platform (CC ID = 64).</p></li>
<li><p><strong>x86_FastCall</strong> — fastcall calling convention seen on Microsoft Windows
platform (CC ID = 65).</p></li>
<li><p><strong>x86_ThisCall</strong> — Similar to X86_StdCall. Passes first argument in ECX,
others via stack. Callee is responsible for stack cleaning. This convention is
used by MSVC by default for methods in its ABI (CC ID = 70).</p></li>
</ul>
</div>
<div class="section" id="representing-x86-addressing-modes-in-machineinstrs">
<span id="x86-addressing-mode"></span><h4><a class="toc-backref" href="#id86">Representing X86 addressing modes in MachineInstrs</a><a class="headerlink" href="#representing-x86-addressing-modes-in-machineinstrs" title="Permalink to this headline">¶</a></h4>
<p>The x86 has a very flexible way of accessing memory.  It is capable of forming
memory addresses of the following expression directly in integer instructions
(which use ModR/M addressing):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SegmentReg</span><span class="p">:</span> <span class="n">Base</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span> <span class="o">*</span> <span class="n">IndexReg</span> <span class="o">+</span> <span class="n">Disp32</span>
</pre></div>
</div>
<p>In order to represent this, LLVM tracks no less than 5 operands for each memory
operand of this form.  This means that the “load” form of ‘<code class="docutils literal notranslate"><span class="pre">mov</span></code>’ has the
following <code class="docutils literal notranslate"><span class="pre">MachineOperand</span></code>s in this order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Index</span><span class="p">:</span>        <span class="mi">0</span>     <span class="o">|</span>    <span class="mi">1</span>        <span class="mi">2</span>       <span class="mi">3</span>           <span class="mi">4</span>          <span class="mi">5</span>
<span class="n">Meaning</span><span class="p">:</span>   <span class="n">DestReg</span><span class="p">,</span> <span class="o">|</span> <span class="n">BaseReg</span><span class="p">,</span>  <span class="n">Scale</span><span class="p">,</span> <span class="n">IndexReg</span><span class="p">,</span> <span class="n">Displacement</span> <span class="n">Segment</span>
<span class="n">OperandTy</span><span class="p">:</span> <span class="n">VirtReg</span><span class="p">,</span> <span class="o">|</span> <span class="n">VirtReg</span><span class="p">,</span> <span class="n">UnsImm</span><span class="p">,</span> <span class="n">VirtReg</span><span class="p">,</span>   <span class="n">SignExtImm</span>  <span class="n">PhysReg</span>
</pre></div>
</div>
<p>Stores, and all other instructions, treat the four memory operands in the same
way and in the same order.  If the segment register is unspecified (regno = 0),
then no segment override is generated.  “Lea” operations do not have a segment
register specified, so they only have 4 operands for their memory reference.</p>
</div>
<div class="section" id="x86-address-spaces-supported">
<h4><a class="toc-backref" href="#id87">X86 address spaces supported</a><a class="headerlink" href="#x86-address-spaces-supported" title="Permalink to this headline">¶</a></h4>
<p>x86 has a feature which provides the ability to perform loads and stores to
different address spaces via the x86 segment registers.  A segment override
prefix byte on an instruction causes the instruction’s memory access to go to
the specified segment.  LLVM address space 0 is the default address space, which
includes the stack, and any unqualified memory accesses in a program.  Address
spaces 1-255 are currently reserved for user-defined code.  The GS-segment is
represented by address space 256, the FS-segment is represented by address space
257, and the SS-segment is represented by address space 258. Other x86 segments
have yet to be allocated address space numbers.</p>
<p>While these address spaces may seem similar to TLS via the <code class="docutils literal notranslate"><span class="pre">thread_local</span></code>
keyword, and often use the same underlying hardware, there are some fundamental
differences.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> keyword applies to global variables and specifies that they
are to be allocated in thread-local memory. There are no type qualifiers
involved, and these variables can be pointed to with normal pointers and
accessed with normal loads and stores.  The <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> keyword is
target-independent at the LLVM IR level (though LLVM doesn’t yet have
implementations of it for some configurations)</p>
<p>Special address spaces, in contrast, apply to static types. Every load and store
has a particular address space in its address operand type, and this is what
determines which address space is accessed.  LLVM ignores these special address
space qualifiers on global variables, and does not provide a way to directly
allocate storage in them.  At the LLVM IR level, the behavior of these special
address spaces depends in part on the underlying OS or runtime environment, and
they are specific to x86 (and LLVM doesn’t yet handle them correctly in some
cases).</p>
<p>Some operating systems and runtime environments use (or may in the future use)
the FS/GS-segment registers for various low-level purposes, so care should be
taken when considering them.</p>
</div>
<div class="section" id="instruction-naming">
<h4><a class="toc-backref" href="#id88">Instruction naming</a><a class="headerlink" href="#instruction-naming" title="Permalink to this headline">¶</a></h4>
<p>An instruction name consists of the base name, a default operand size, and a a
character per operand with an optional special size. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ADD8rr</span>      <span class="o">-&gt;</span> <span class="n">add</span><span class="p">,</span> <span class="mi">8</span><span class="o">-</span><span class="n">bit</span> <span class="n">register</span><span class="p">,</span> <span class="mi">8</span><span class="o">-</span><span class="n">bit</span> <span class="n">register</span>
<span class="n">IMUL16rmi</span>   <span class="o">-&gt;</span> <span class="n">imul</span><span class="p">,</span> <span class="mi">16</span><span class="o">-</span><span class="n">bit</span> <span class="n">register</span><span class="p">,</span> <span class="mi">16</span><span class="o">-</span><span class="n">bit</span> <span class="n">memory</span><span class="p">,</span> <span class="mi">16</span><span class="o">-</span><span class="n">bit</span> <span class="n">immediate</span>
<span class="n">IMUL16rmi8</span>  <span class="o">-&gt;</span> <span class="n">imul</span><span class="p">,</span> <span class="mi">16</span><span class="o">-</span><span class="n">bit</span> <span class="n">register</span><span class="p">,</span> <span class="mi">16</span><span class="o">-</span><span class="n">bit</span> <span class="n">memory</span><span class="p">,</span> <span class="mi">8</span><span class="o">-</span><span class="n">bit</span> <span class="n">immediate</span>
<span class="n">MOVSX32rm16</span> <span class="o">-&gt;</span> <span class="n">movsx</span><span class="p">,</span> <span class="mi">32</span><span class="o">-</span><span class="n">bit</span> <span class="n">register</span><span class="p">,</span> <span class="mi">16</span><span class="o">-</span><span class="n">bit</span> <span class="n">memory</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="the-powerpc-backend">
<h3><a class="toc-backref" href="#id89">The PowerPC backend</a><a class="headerlink" href="#the-powerpc-backend" title="Permalink to this headline">¶</a></h3>
<p>The PowerPC code generator lives in the lib/Target/PowerPC directory.  The code
generation is retargetable to several variations or <em>subtargets</em> of the PowerPC
ISA; including ppc32, ppc64 and altivec.</p>
<div class="section" id="llvm-powerpc-abi">
<h4><a class="toc-backref" href="#id90">LLVM PowerPC ABI</a><a class="headerlink" href="#llvm-powerpc-abi" title="Permalink to this headline">¶</a></h4>
<p>LLVM follows the AIX PowerPC ABI, with two deviations. LLVM uses a PC relative
(PIC) or static addressing for accessing global values, so no TOC (r2) is
used. Second, r31 is used as a frame pointer to allow dynamic growth of a stack
frame.  LLVM takes advantage of having no TOC to provide space to save the frame
pointer in the PowerPC linkage area of the caller frame.  Other details of
PowerPC ABI can be found at <a class="reference external" href="http://developer.apple.com/documentation/DeveloperTools/Conceptual/LowLevelABI/Articles/32bitPowerPC.html">PowerPC ABI</a>. Note: This link describes the 32 bit ABI.  The 64 bit ABI is similar except
space for GPRs are 8 bytes wide (not 4) and r13 is reserved for system use.</p>
</div>
<div class="section" id="frame-layout">
<h4><a class="toc-backref" href="#id91">Frame Layout</a><a class="headerlink" href="#frame-layout" title="Permalink to this headline">¶</a></h4>
<p>The size of a PowerPC frame is usually fixed for the duration of a function’s
invocation.  Since the frame is fixed size, all references into the frame can be
accessed via fixed offsets from the stack pointer.  The exception to this is
when dynamic alloca or variable sized arrays are present, then a base pointer
(r31) is used as a proxy for the stack pointer and stack pointer is free to grow
or shrink.  A base pointer is also used if llvm-gcc is not passed the
-fomit-frame-pointer flag. The stack pointer is always aligned to 16 bytes, so
that space allocated for altivec vectors will be properly aligned.</p>
<p>An invocation frame is laid out as follows (low memory at top):</p>
<p><span class="raw-html"><table border="1" cellspacing="0"></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>Linkage<br><br></td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>Parameter area<br><br></td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>Dynamic area<br><br></td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>Locals area<br><br></td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>Saved registers area<br><br></td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr style="border-style: none hidden none hidden;"></span>
<span class="raw-html"><td><br></td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>Previous Frame<br><br></td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"></table></span></p>
<p>The <em>linkage</em> area is used by a callee to save special registers prior to
allocating its own frame.  Only three entries are relevant to LLVM. The first
entry is the previous stack pointer (sp), aka link.  This allows probing tools
like gdb or exception handlers to quickly scan the frames in the stack.  A
function epilog can also use the link to pop the frame from the stack.  The
third entry in the linkage area is used to save the return address from the lr
register. Finally, as mentioned above, the last entry is used to save the
previous frame pointer (r31.)  The entries in the linkage area are the size of a
GPR, thus the linkage area is 24 bytes long in 32 bit mode and 48 bytes in 64
bit mode.</p>
<p>32 bit linkage area:</p>
<p><span class="raw-html"><table  border="1" cellspacing="0"></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>0</td></span>
<span class="raw-html"><td>Saved SP (r1)</td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>4</td></span>
<span class="raw-html"><td>Saved CR</td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>8</td></span>
<span class="raw-html"><td>Saved LR</td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>12</td></span>
<span class="raw-html"><td>Reserved</td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>16</td></span>
<span class="raw-html"><td>Reserved</td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>20</td></span>
<span class="raw-html"><td>Saved FP (r31)</td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"></table></span></p>
<p>64 bit linkage area:</p>
<p><span class="raw-html"><table border="1" cellspacing="0"></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>0</td></span>
<span class="raw-html"><td>Saved SP (r1)</td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>8</td></span>
<span class="raw-html"><td>Saved CR</td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>16</td></span>
<span class="raw-html"><td>Saved LR</td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>24</td></span>
<span class="raw-html"><td>Reserved</td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>32</td></span>
<span class="raw-html"><td>Reserved</td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>40</td></span>
<span class="raw-html"><td>Saved FP (r31)</td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"></table></span></p>
<p>The <em>parameter area</em> is used to store arguments being passed to a callee
function.  Following the PowerPC ABI, the first few arguments are actually
passed in registers, with the space in the parameter area unused.  However, if
there are not enough registers or the callee is a thunk or vararg function,
these register arguments can be spilled into the parameter area.  Thus, the
parameter area must be large enough to store all the parameters for the largest
call sequence made by the caller.  The size must also be minimally large enough
to spill registers r3-r10.  This allows callees blind to the call signature,
such as thunks and vararg functions, enough space to cache the argument
registers.  Therefore, the parameter area is minimally 32 bytes (64 bytes in 64
bit mode.)  Also note that since the parameter area is a fixed offset from the
top of the frame, that a callee can access its spilt arguments using fixed
offsets from the stack pointer (or base pointer.)</p>
<p>Combining the information about the linkage, parameter areas and alignment. A
stack frame is minimally 64 bytes in 32 bit mode and 128 bytes in 64 bit mode.</p>
<p>The <em>dynamic area</em> starts out as size zero.  If a function uses dynamic alloca
then space is added to the stack, the linkage and parameter areas are shifted to
top of stack, and the new space is available immediately below the linkage and
parameter areas.  The cost of shifting the linkage and parameter areas is minor
since only the link value needs to be copied.  The link value can be easily
fetched by adding the original frame size to the base pointer.  Note that
allocations in the dynamic space need to observe 16 byte alignment.</p>
<p>The <em>locals area</em> is where the llvm compiler reserves space for local variables.</p>
<p>The <em>saved registers area</em> is where the llvm compiler spills callee saved
registers on entry to the callee.</p>
</div>
<div class="section" id="prolog-epilog">
<h4><a class="toc-backref" href="#id92">Prolog/Epilog</a><a class="headerlink" href="#prolog-epilog" title="Permalink to this headline">¶</a></h4>
<p>The llvm prolog and epilog are the same as described in the PowerPC ABI, with
the following exceptions.  Callee saved registers are spilled after the frame is
created.  This allows the llvm epilog/prolog support to be common with other
targets.  The base pointer callee saved register r31 is saved in the TOC slot of
linkage area.  This simplifies allocation of space for the base pointer and
makes it convenient to locate programmatically and during debugging.</p>
</div>
<div class="section" id="dynamic-allocation">
<h4><a class="toc-backref" href="#id93">Dynamic Allocation</a><a class="headerlink" href="#dynamic-allocation" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>TODO - More to come.</p>
</div>
</div>
</div>
<div class="section" id="the-nvptx-backend">
<h3><a class="toc-backref" href="#id94">The NVPTX backend</a><a class="headerlink" href="#the-nvptx-backend" title="Permalink to this headline">¶</a></h3>
<p>The NVPTX code generator under lib/Target/NVPTX is an open-source version of
the NVIDIA NVPTX code generator for LLVM.  It is contributed by NVIDIA and is
a port of the code generator used in the CUDA compiler (nvcc).  It targets the
PTX 3.0/3.1 ISA and can target any compute capability greater than or equal to
2.0 (Fermi).</p>
<p>This target is of production quality and should be completely compatible with
the official NVIDIA toolchain.</p>
<p>Code Generator Options:</p>
<p><span class="raw-html"><table border="1" cellspacing="0"></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><th>Option</th></span>
<span class="raw-html"><th>Description</th></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>sm_20</td></span>
<span class="raw-html"><td align="left">Set shader model/compute capability to 2.0</td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>sm_21</td></span>
<span class="raw-html"><td align="left">Set shader model/compute capability to 2.1</td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>sm_30</td></span>
<span class="raw-html"><td align="left">Set shader model/compute capability to 3.0</td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>sm_35</td></span>
<span class="raw-html"><td align="left">Set shader model/compute capability to 3.5</td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>ptx30</td></span>
<span class="raw-html"><td align="left">Target PTX 3.0</td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"><tr></span>
<span class="raw-html"><td>ptx31</td></span>
<span class="raw-html"><td align="left">Target PTX 3.1</td></span>
<span class="raw-html"></tr></span>
<span class="raw-html"></table></span></p>
</div>
<div class="section" id="the-extended-berkeley-packet-filter-ebpf-backend">
<h3><a class="toc-backref" href="#id95">The extended Berkeley Packet Filter (eBPF) backend</a><a class="headerlink" href="#the-extended-berkeley-packet-filter-ebpf-backend" title="Permalink to this headline">¶</a></h3>
<p>Extended BPF (or eBPF) is similar to the original (“classic”) BPF (cBPF) used
to filter network packets.  The
<a class="reference external" href="http://man7.org/linux/man-pages/man2/bpf.2.html">bpf() system call</a>
performs a range of operations related to eBPF.  For both cBPF and eBPF
programs, the Linux kernel statically analyzes the programs before loading
them, in order to ensure that they cannot harm the running system.  eBPF is
a 64-bit RISC instruction set designed for one to one mapping to 64-bit CPUs.
Opcodes are 8-bit encoded, and 87 instructions are defined.  There are 10
registers, grouped by function as outlined below.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R0</span>        <span class="k">return</span> <span class="n">value</span> <span class="kn">from</span> <span class="nn">in</span><span class="o">-</span><span class="n">kernel</span> <span class="n">functions</span><span class="p">;</span> <span class="n">exit</span> <span class="n">value</span> <span class="k">for</span> <span class="n">eBPF</span> <span class="n">program</span>
<span class="n">R1</span> <span class="o">-</span> <span class="n">R5</span>   <span class="n">function</span> <span class="n">call</span> <span class="n">arguments</span> <span class="n">to</span> <span class="ow">in</span><span class="o">-</span><span class="n">kernel</span> <span class="n">functions</span>
<span class="n">R6</span> <span class="o">-</span> <span class="n">R9</span>   <span class="n">callee</span><span class="o">-</span><span class="n">saved</span> <span class="n">registers</span> <span class="n">preserved</span> <span class="n">by</span> <span class="ow">in</span><span class="o">-</span><span class="n">kernel</span> <span class="n">functions</span>
<span class="n">R10</span>       <span class="n">stack</span> <span class="n">frame</span> <span class="n">pointer</span> <span class="p">(</span><span class="n">read</span> <span class="n">only</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="instruction-encoding-arithmetic-and-jump">
<h4><a class="toc-backref" href="#id96">Instruction encoding (arithmetic and jump)</a><a class="headerlink" href="#instruction-encoding-arithmetic-and-jump" title="Permalink to this headline">¶</a></h4>
<p>eBPF is reusing most of the opcode encoding from classic to simplify conversion
of classic BPF to eBPF.  For arithmetic and jump instructions the 8-bit ‘code’
field is divided into three parts:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>+----------------+--------+--------------------+
|   4 bits       |  1 bit |   3 bits           |
| operation code | source | instruction class  |
+----------------+--------+--------------------+
(MSB)                                      (LSB)
</pre></div>
</div>
<p>Three LSB bits store instruction class which is one of:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BPF_LD</span>     <span class="mh">0x0</span>
<span class="n">BPF_LDX</span>    <span class="mh">0x1</span>
<span class="n">BPF_ST</span>     <span class="mh">0x2</span>
<span class="n">BPF_STX</span>    <span class="mh">0x3</span>
<span class="n">BPF_ALU</span>    <span class="mh">0x4</span>
<span class="n">BPF_JMP</span>    <span class="mh">0x5</span>
<span class="p">(</span><span class="n">unused</span><span class="p">)</span>   <span class="mh">0x6</span>
<span class="n">BPF_ALU64</span>  <span class="mh">0x7</span>
</pre></div>
</div>
<p>When BPF_CLASS(code) == BPF_ALU or BPF_ALU64 or BPF_JMP,
4th bit encodes source operand</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BPF_X</span>     <span class="mh">0x1</span>  <span class="n">use</span> <span class="n">src_reg</span> <span class="n">register</span> <span class="k">as</span> <span class="n">source</span> <span class="n">operand</span>
<span class="n">BPF_K</span>     <span class="mh">0x0</span>  <span class="n">use</span> <span class="mi">32</span> <span class="n">bit</span> <span class="n">immediate</span> <span class="k">as</span> <span class="n">source</span> <span class="n">operand</span>
</pre></div>
</div>
<p>and four MSB bits store operation code</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BPF_ADD</span>   <span class="mh">0x0</span>  <span class="n">add</span>
<span class="n">BPF_SUB</span>   <span class="mh">0x1</span>  <span class="n">subtract</span>
<span class="n">BPF_MUL</span>   <span class="mh">0x2</span>  <span class="n">multiply</span>
<span class="n">BPF_DIV</span>   <span class="mh">0x3</span>  <span class="n">divide</span>
<span class="n">BPF_OR</span>    <span class="mh">0x4</span>  <span class="n">bitwise</span> <span class="n">logical</span> <span class="n">OR</span>
<span class="n">BPF_AND</span>   <span class="mh">0x5</span>  <span class="n">bitwise</span> <span class="n">logical</span> <span class="n">AND</span>
<span class="n">BPF_LSH</span>   <span class="mh">0x6</span>  <span class="n">left</span> <span class="n">shift</span>
<span class="n">BPF_RSH</span>   <span class="mh">0x7</span>  <span class="n">right</span> <span class="n">shift</span> <span class="p">(</span><span class="n">zero</span> <span class="n">extended</span><span class="p">)</span>
<span class="n">BPF_NEG</span>   <span class="mh">0x8</span>  <span class="n">arithmetic</span> <span class="n">negation</span>
<span class="n">BPF_MOD</span>   <span class="mh">0x9</span>  <span class="n">modulo</span>
<span class="n">BPF_XOR</span>   <span class="mh">0xa</span>  <span class="n">bitwise</span> <span class="n">logical</span> <span class="n">XOR</span>
<span class="n">BPF_MOV</span>   <span class="mh">0xb</span>  <span class="n">move</span> <span class="n">register</span> <span class="n">to</span> <span class="n">register</span>
<span class="n">BPF_ARSH</span>  <span class="mh">0xc</span>  <span class="n">right</span> <span class="n">shift</span> <span class="p">(</span><span class="n">sign</span> <span class="n">extended</span><span class="p">)</span>
<span class="n">BPF_END</span>   <span class="mh">0xd</span>  <span class="n">endianness</span> <span class="n">conversion</span>
</pre></div>
</div>
<p>If BPF_CLASS(code) == BPF_JMP, BPF_OP(code) is one of</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BPF_JA</span>    <span class="mh">0x0</span>  <span class="n">unconditional</span> <span class="n">jump</span>
<span class="n">BPF_JEQ</span>   <span class="mh">0x1</span>  <span class="n">jump</span> <span class="o">==</span>
<span class="n">BPF_JGT</span>   <span class="mh">0x2</span>  <span class="n">jump</span> <span class="o">&gt;</span>
<span class="n">BPF_JGE</span>   <span class="mh">0x3</span>  <span class="n">jump</span> <span class="o">&gt;=</span>
<span class="n">BPF_JSET</span>  <span class="mh">0x4</span>  <span class="n">jump</span> <span class="k">if</span> <span class="p">(</span><span class="n">DST</span> <span class="o">&amp;</span> <span class="n">SRC</span><span class="p">)</span>
<span class="n">BPF_JNE</span>   <span class="mh">0x5</span>  <span class="n">jump</span> <span class="o">!=</span>
<span class="n">BPF_JSGT</span>  <span class="mh">0x6</span>  <span class="n">jump</span> <span class="n">signed</span> <span class="o">&gt;</span>
<span class="n">BPF_JSGE</span>  <span class="mh">0x7</span>  <span class="n">jump</span> <span class="n">signed</span> <span class="o">&gt;=</span>
<span class="n">BPF_CALL</span>  <span class="mh">0x8</span>  <span class="n">function</span> <span class="n">call</span>
<span class="n">BPF_EXIT</span>  <span class="mh">0x9</span>  <span class="n">function</span> <span class="k">return</span>
</pre></div>
</div>
</div>
<div class="section" id="instruction-encoding-load-store">
<h4><a class="toc-backref" href="#id97">Instruction encoding (load, store)</a><a class="headerlink" href="#instruction-encoding-load-store" title="Permalink to this headline">¶</a></h4>
<p>For load and store instructions the 8-bit ‘code’ field is divided as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>+--------+--------+-------------------+
| 3 bits | 2 bits |   3 bits          |
|  mode  |  size  | instruction class |
+--------+--------+-------------------+
(MSB)                             (LSB)
</pre></div>
</div>
<p>Size modifier is one of</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BPF_W</span>       <span class="mh">0x0</span>  <span class="n">word</span>
<span class="n">BPF_H</span>       <span class="mh">0x1</span>  <span class="n">half</span> <span class="n">word</span>
<span class="n">BPF_B</span>       <span class="mh">0x2</span>  <span class="n">byte</span>
<span class="n">BPF_DW</span>      <span class="mh">0x3</span>  <span class="n">double</span> <span class="n">word</span>
</pre></div>
</div>
<p>Mode modifier is one of</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BPF_IMM</span>     <span class="mh">0x0</span>  <span class="n">immediate</span>
<span class="n">BPF_ABS</span>     <span class="mh">0x1</span>  <span class="n">used</span> <span class="n">to</span> <span class="n">access</span> <span class="n">packet</span> <span class="n">data</span>
<span class="n">BPF_IND</span>     <span class="mh">0x2</span>  <span class="n">used</span> <span class="n">to</span> <span class="n">access</span> <span class="n">packet</span> <span class="n">data</span>
<span class="n">BPF_MEM</span>     <span class="mh">0x3</span>  <span class="n">memory</span>
<span class="p">(</span><span class="n">reserved</span><span class="p">)</span>  <span class="mh">0x4</span>
<span class="p">(</span><span class="n">reserved</span><span class="p">)</span>  <span class="mh">0x5</span>
<span class="n">BPF_XADD</span>    <span class="mh">0x6</span>  <span class="n">exclusive</span> <span class="n">add</span>
</pre></div>
</div>
</div>
<div class="section" id="packet-data-access-bpf-abs-bpf-ind">
<h4><a class="toc-backref" href="#id98">Packet data access (BPF_ABS, BPF_IND)</a><a class="headerlink" href="#packet-data-access-bpf-abs-bpf-ind" title="Permalink to this headline">¶</a></h4>
<p>Two non-generic instructions: (BPF_ABS | &lt;size&gt; | BPF_LD) and
(BPF_IND | &lt;size&gt; | BPF_LD) which are used to access packet data.
Register R6 is an implicit input that must contain pointer to sk_buff.
Register R0 is an implicit output which contains the data fetched
from the packet.  Registers R1-R5 are scratch registers and must not
be used to store the data across BPF_ABS | BPF_LD or BPF_IND | BPF_LD
instructions.  These instructions have implicit program exit condition
as well.  When eBPF program is trying to access the data beyond
the packet boundary, the interpreter will abort the execution of the program.</p>
<dl class="simple">
<dt>BPF_IND | BPF_W | BPF_LD is equivalent to:</dt><dd><p>R0 = ntohl(*(u32 *) (((struct sk_buff *) R6)-&gt;data + src_reg + imm32))</p>
</dd>
</dl>
</div>
<div class="section" id="ebpf-maps">
<h4><a class="toc-backref" href="#id99">eBPF maps</a><a class="headerlink" href="#ebpf-maps" title="Permalink to this headline">¶</a></h4>
<p>eBPF maps are provided for sharing data between kernel and user-space.
Currently implemented types are hash and array, with potential extension to
support bloom filters, radix trees, etc.  A map is defined by its type,
maximum number of elements, key size and value size in bytes.  eBPF syscall
supports create, update, find and delete functions on maps.</p>
</div>
<div class="section" id="function-calls">
<h4><a class="toc-backref" href="#id100">Function calls</a><a class="headerlink" href="#function-calls" title="Permalink to this headline">¶</a></h4>
<p>Function call arguments are passed using up to five registers (R1 - R5).
The return value is passed in a dedicated register (R0).  Four additional
registers (R6 - R9) are callee-saved, and the values in these registers
are preserved within kernel functions.  R0 - R5 are scratch registers within
kernel functions, and eBPF programs must therefor store/restore values in
these registers if needed across function calls.  The stack can be accessed
using the read-only frame pointer R10.  eBPF registers map 1:1 to hardware
registers on x86_64 and other 64-bit architectures.  For example, x86_64
in-kernel JIT maps them as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R0</span> <span class="o">-</span> <span class="n">rax</span>
<span class="n">R1</span> <span class="o">-</span> <span class="n">rdi</span>
<span class="n">R2</span> <span class="o">-</span> <span class="n">rsi</span>
<span class="n">R3</span> <span class="o">-</span> <span class="n">rdx</span>
<span class="n">R4</span> <span class="o">-</span> <span class="n">rcx</span>
<span class="n">R5</span> <span class="o">-</span> <span class="n">r8</span>
<span class="n">R6</span> <span class="o">-</span> <span class="n">rbx</span>
<span class="n">R7</span> <span class="o">-</span> <span class="n">r13</span>
<span class="n">R8</span> <span class="o">-</span> <span class="n">r14</span>
<span class="n">R9</span> <span class="o">-</span> <span class="n">r15</span>
<span class="n">R10</span> <span class="o">-</span> <span class="n">rbp</span>
</pre></div>
</div>
<p>since x86_64 ABI mandates rdi, rsi, rdx, rcx, r8, r9 for argument passing
and rbx, r12 - r15 are callee saved.</p>
</div>
<div class="section" id="program-start">
<h4><a class="toc-backref" href="#id101">Program start</a><a class="headerlink" href="#program-start" title="Permalink to this headline">¶</a></h4>
<p>An eBPF program receives a single argument and contains
a single eBPF main routine; the program does not contain eBPF functions.
Function calls are limited to a predefined set of kernel functions.  The size
of a program is limited to 4K instructions:  this ensures fast termination and
a limited number of kernel function calls.  Prior to running an eBPF program,
a verifier performs static analysis to prevent loops in the code and
to ensure valid register usage and operand types.</p>
</div>
</div>
<div class="section" id="the-amdgpu-backend">
<h3><a class="toc-backref" href="#id102">The AMDGPU backend</a><a class="headerlink" href="#the-amdgpu-backend" title="Permalink to this headline">¶</a></h3>
<p>The AMDGPU code generator lives in the <code class="docutils literal notranslate"><span class="pre">lib/Target/AMDGPU</span></code>
directory. This code generator is capable of targeting a variety of
AMD GPU processors. Refer to <a class="reference internal" href="AMDGPUUsage.html"><span class="doc">User Guide for AMDGPU Backend</span></a> for more information.</p>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="ExceptionHandling.html" title="Exception Handling in LLVM"
             >next</a> |</li>
        <li class="right" >
          <a href="Bugpoint.html" title="LLVM bugpoint tool: design and usage"
             >previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2003-2020, LLVM Project.
      Last updated on 2020-01-13.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.3.1.
    </div>
  </body>
</html>