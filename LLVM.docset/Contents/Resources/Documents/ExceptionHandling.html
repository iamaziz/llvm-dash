

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Exception Handling in LLVM &#8212; LLVM 9 documentation</title>
    <link rel="stylesheet" href="_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="How To Add A Constrained Floating-Point Intrinsic" href="AddingConstrainedIntrinsics.html" />
    <link rel="prev" title="The LLVM Target-Independent Code Generator" href="CodeGenerator.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="AddingConstrainedIntrinsics.html" title="How To Add A Constrained Floating-Point Intrinsic"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="CodeGenerator.html" title="The LLVM Target-Independent Code Generator"
             accesskey="P">previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="exception-handling-in-llvm">
<h1>Exception Handling in LLVM<a class="headerlink" href="#exception-handling-in-llvm" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id8">Introduction</a></p>
<ul>
<li><p><a class="reference internal" href="#itanium-abi-zero-cost-exception-handling" id="id9">Itanium ABI Zero-cost Exception Handling</a></p></li>
<li><p><a class="reference internal" href="#setjmp-longjmp-exception-handling" id="id10">Setjmp/Longjmp Exception Handling</a></p></li>
<li><p><a class="reference internal" href="#windows-runtime-exception-handling" id="id11">Windows Runtime Exception Handling</a></p></li>
<li><p><a class="reference internal" href="#overview" id="id12">Overview</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#llvm-code-generation" id="id13">LLVM Code Generation</a></p>
<ul>
<li><p><a class="reference internal" href="#throw" id="id14">Throw</a></p></li>
<li><p><a class="reference internal" href="#try-catch" id="id15">Try/Catch</a></p></li>
<li><p><a class="reference internal" href="#cleanups" id="id16">Cleanups</a></p></li>
<li><p><a class="reference internal" href="#throw-filters" id="id17">Throw Filters</a></p></li>
<li><p><a class="reference internal" href="#restrictions" id="id18">Restrictions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#exception-handling-intrinsics" id="id19">Exception Handling Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-eh-typeid-for" id="id20"><code class="docutils literal notranslate"><span class="pre">llvm.eh.typeid.for</span></code></a></p></li>
<li><p><a class="reference internal" href="#llvm-eh-begincatch" id="id21"><code class="docutils literal notranslate"><span class="pre">llvm.eh.begincatch</span></code></a></p></li>
<li><p><a class="reference internal" href="#llvm-eh-endcatch" id="id22"><code class="docutils literal notranslate"><span class="pre">llvm.eh.endcatch</span></code></a></p></li>
<li><p><a class="reference internal" href="#llvm-eh-exceptionpointer" id="id23"><code class="docutils literal notranslate"><span class="pre">llvm.eh.exceptionpointer</span></code></a></p></li>
<li><p><a class="reference internal" href="#sjlj-intrinsics" id="id24">SJLJ Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-eh-sjlj-setjmp" id="id25"><code class="docutils literal notranslate"><span class="pre">llvm.eh.sjlj.setjmp</span></code></a></p></li>
<li><p><a class="reference internal" href="#llvm-eh-sjlj-longjmp" id="id26"><code class="docutils literal notranslate"><span class="pre">llvm.eh.sjlj.longjmp</span></code></a></p></li>
<li><p><a class="reference internal" href="#llvm-eh-sjlj-lsda" id="id27"><code class="docutils literal notranslate"><span class="pre">llvm.eh.sjlj.lsda</span></code></a></p></li>
<li><p><a class="reference internal" href="#llvm-eh-sjlj-callsite" id="id28"><code class="docutils literal notranslate"><span class="pre">llvm.eh.sjlj.callsite</span></code></a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#asm-table-formats" id="id29">Asm Table Formats</a></p>
<ul>
<li><p><a class="reference internal" href="#exception-handling-frame" id="id30">Exception Handling Frame</a></p></li>
<li><p><a class="reference internal" href="#exception-tables" id="id31">Exception Tables</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#exception-handling-using-the-windows-runtime" id="id32">Exception Handling using the Windows Runtime</a></p>
<ul>
<li><p><a class="reference internal" href="#background-on-windows-exceptions" id="id33">Background on Windows exceptions</a></p></li>
<li><p><a class="reference internal" href="#seh-filter-expressions" id="id34">SEH filter expressions</a></p></li>
<li><p><a class="reference internal" href="#new-exception-handling-instructions" id="id35">New exception handling instructions</a></p></li>
<li><p><a class="reference internal" href="#funclet-parent-tokens" id="id36">Funclet parent tokens</a></p></li>
<li><p><a class="reference internal" href="#funclet-transitions" id="id37">Funclet transitions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#exception-handling-support-on-the-target" id="id38">Exception Handling support on the target</a></p></li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id8">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document is the central repository for all information pertaining to
exception handling in LLVM.  It describes the format that LLVM exception
handling information takes, which is useful for those interested in creating
front-ends or dealing directly with the information.  Further, this document
provides specific examples of what exception handling information is used for in
C and C++.</p>
<div class="section" id="itanium-abi-zero-cost-exception-handling">
<h3><a class="toc-backref" href="#id9">Itanium ABI Zero-cost Exception Handling</a><a class="headerlink" href="#itanium-abi-zero-cost-exception-handling" title="Permalink to this headline">¶</a></h3>
<p>Exception handling for most programming languages is designed to recover from
conditions that rarely occur during general use of an application.  To that end,
exception handling should not interfere with the main flow of an application’s
algorithm by performing checkpointing tasks, such as saving the current pc or
register state.</p>
<p>The Itanium ABI Exception Handling Specification defines a methodology for
providing outlying data in the form of exception tables without inlining
speculative exception handling code in the flow of an application’s main
algorithm.  Thus, the specification is said to add “zero-cost” to the normal
execution of an application.</p>
<p>A more complete description of the Itanium ABI exception handling runtime
support of can be found at <a class="reference external" href="http://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html">Itanium C++ ABI: Exception Handling</a>. A description of the
exception frame format can be found at <a class="reference external" href="http://refspecs.linuxfoundation.org/LSB_3.0.0/LSB-Core-generic/LSB-Core-generic/ehframechpt.html">Exception Frames</a>,
with details of the DWARF 4 specification at <a class="reference external" href="http://dwarfstd.org/Dwarf4Std.php">DWARF 4 Standard</a>.  A description for the C++ exception
table formats can be found at <a class="reference external" href="http://itanium-cxx-abi.github.io/cxx-abi/exceptions.pdf">Exception Handling Tables</a>.</p>
</div>
<div class="section" id="setjmp-longjmp-exception-handling">
<h3><a class="toc-backref" href="#id10">Setjmp/Longjmp Exception Handling</a><a class="headerlink" href="#setjmp-longjmp-exception-handling" title="Permalink to this headline">¶</a></h3>
<p>Setjmp/Longjmp (SJLJ) based exception handling uses LLVM intrinsics
<a class="reference internal" href="#llvm-eh-sjlj-setjmp">llvm.eh.sjlj.setjmp</a> and <a class="reference internal" href="#llvm-eh-sjlj-longjmp">llvm.eh.sjlj.longjmp</a> to handle control flow for
exception handling.</p>
<p>For each function which does exception processing — be it <code class="docutils literal notranslate"><span class="pre">try</span></code>/<code class="docutils literal notranslate"><span class="pre">catch</span></code>
blocks or cleanups — that function registers itself on a global frame
list. When exceptions are unwinding, the runtime uses this list to identify
which functions need processing.</p>
<p>Landing pad selection is encoded in the call site entry of the function
context. The runtime returns to the function via <a class="reference internal" href="#llvm-eh-sjlj-longjmp">llvm.eh.sjlj.longjmp</a>, where
a switch table transfers control to the appropriate landing pad based on the
index stored in the function context.</p>
<p>In contrast to DWARF exception handling, which encodes exception regions and
frame information in out-of-line tables, SJLJ exception handling builds and
removes the unwind frame context at runtime. This results in faster exception
handling at the expense of slower execution when no exceptions are thrown. As
exceptions are, by their nature, intended for uncommon code paths, DWARF
exception handling is generally preferred to SJLJ.</p>
</div>
<div class="section" id="windows-runtime-exception-handling">
<h3><a class="toc-backref" href="#id11">Windows Runtime Exception Handling</a><a class="headerlink" href="#windows-runtime-exception-handling" title="Permalink to this headline">¶</a></h3>
<p>LLVM supports handling exceptions produced by the Windows runtime, but it
requires a very different intermediate representation. It is not based on the
“<a class="reference internal" href="LangRef.html#i-landingpad"><span class="std std-ref">landingpad</span></a>” instruction like the other two models, and is
described later in this document under <a class="reference internal" href="#wineh"><span class="std std-ref">Exception Handling using the Windows Runtime</span></a>.</p>
</div>
<div class="section" id="overview">
<h3><a class="toc-backref" href="#id12">Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p>When an exception is thrown in LLVM code, the runtime does its best to find a
handler suited to processing the circumstance.</p>
<p>The runtime first attempts to find an <em>exception frame</em> corresponding to the
function where the exception was thrown.  If the programming language supports
exception handling (e.g. C++), the exception frame contains a reference to an
exception table describing how to process the exception.  If the language does
not support exception handling (e.g. C), or if the exception needs to be
forwarded to a prior activation, the exception frame contains information about
how to unwind the current activation and restore the state of the prior
activation.  This process is repeated until the exception is handled. If the
exception is not handled and no activations remain, then the application is
terminated with an appropriate error message.</p>
<p>Because different programming languages have different behaviors when handling
exceptions, the exception handling ABI provides a mechanism for
supplying <em>personalities</em>. An exception handling personality is defined by
way of a <em>personality function</em> (e.g. <code class="docutils literal notranslate"><span class="pre">__gxx_personality_v0</span></code> in C++),
which receives the context of the exception, an <em>exception structure</em>
containing the exception object type and value, and a reference to the exception
table for the current function.  The personality function for the current
compile unit is specified in a <em>common exception frame</em>.</p>
<p>The organization of an exception table is language dependent. For C++, an
exception table is organized as a series of code ranges defining what to do if
an exception occurs in that range. Typically, the information associated with a
range defines which types of exception objects (using C++ <em>type info</em>) that are
handled in that range, and an associated action that should take place. Actions
typically pass control to a <em>landing pad</em>.</p>
<p>A landing pad corresponds roughly to the code found in the <code class="docutils literal notranslate"><span class="pre">catch</span></code> portion of
a <code class="docutils literal notranslate"><span class="pre">try</span></code>/<code class="docutils literal notranslate"><span class="pre">catch</span></code> sequence. When execution resumes at a landing pad, it
receives an <em>exception structure</em> and a <em>selector value</em> corresponding to the
<em>type</em> of exception thrown. The selector is then used to determine which <em>catch</em>
should actually process the exception.</p>
</div>
</div>
<div class="section" id="llvm-code-generation">
<h2><a class="toc-backref" href="#id13">LLVM Code Generation</a><a class="headerlink" href="#llvm-code-generation" title="Permalink to this headline">¶</a></h2>
<p>From a C++ developer’s perspective, exceptions are defined in terms of the
<code class="docutils literal notranslate"><span class="pre">throw</span></code> and <code class="docutils literal notranslate"><span class="pre">try</span></code>/<code class="docutils literal notranslate"><span class="pre">catch</span></code> statements. In this section we will describe the
implementation of LLVM exception handling in terms of C++ examples.</p>
<div class="section" id="throw">
<h3><a class="toc-backref" href="#id14">Throw</a><a class="headerlink" href="#throw" title="Permalink to this headline">¶</a></h3>
<p>Languages that support exception handling typically provide a <code class="docutils literal notranslate"><span class="pre">throw</span></code>
operation to initiate the exception process. Internally, a <code class="docutils literal notranslate"><span class="pre">throw</span></code> operation
breaks down into two steps.</p>
<ol class="arabic simple">
<li><p>A request is made to allocate exception space for an exception structure.
This structure needs to survive beyond the current activation. This structure
will contain the type and value of the object being thrown.</p></li>
<li><p>A call is made to the runtime to raise the exception, passing the exception
structure as an argument.</p></li>
</ol>
<p>In C++, the allocation of the exception structure is done by the
<code class="docutils literal notranslate"><span class="pre">__cxa_allocate_exception</span></code> runtime function. The exception raising is handled
by <code class="docutils literal notranslate"><span class="pre">__cxa_throw</span></code>. The type of the exception is represented using a C++ RTTI
structure.</p>
</div>
<div class="section" id="try-catch">
<h3><a class="toc-backref" href="#id15">Try/Catch</a><a class="headerlink" href="#try-catch" title="Permalink to this headline">¶</a></h3>
<p>A call within the scope of a <em>try</em> statement can potentially raise an
exception. In those circumstances, the LLVM C++ front-end replaces the call with
an <code class="docutils literal notranslate"><span class="pre">invoke</span></code> instruction. Unlike a call, the <code class="docutils literal notranslate"><span class="pre">invoke</span></code> has two potential
continuation points:</p>
<ol class="arabic simple">
<li><p>where to continue when the call succeeds as per normal, and</p></li>
<li><p>where to continue if the call raises an exception, either by a throw or the
unwinding of a throw</p></li>
</ol>
<p>The term used to define the place where an <code class="docutils literal notranslate"><span class="pre">invoke</span></code> continues after an
exception is called a <em>landing pad</em>. LLVM landing pads are conceptually
alternative function entry points where an exception structure reference and a
type info index are passed in as arguments. The landing pad saves the exception
structure reference and then proceeds to select the catch block that corresponds
to the type info of the exception object.</p>
<p>The LLVM <a class="reference internal" href="LangRef.html#i-landingpad"><span class="std std-ref">‘landingpad’ Instruction</span></a> is used to convey information about the landing
pad to the back end. For C++, the <code class="docutils literal notranslate"><span class="pre">landingpad</span></code> instruction returns a pointer
and integer pair corresponding to the pointer to the <em>exception structure</em> and
the <em>selector value</em> respectively.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">landingpad</span></code> instruction looks for a reference to the personality
function to be used for this <code class="docutils literal notranslate"><span class="pre">try</span></code>/<code class="docutils literal notranslate"><span class="pre">catch</span></code> sequence in the parent
function’s attribute list. The instruction contains a list of <em>cleanup</em>,
<em>catch</em>, and <em>filter</em> clauses. The exception is tested against the clauses
sequentially from first to last. The clauses have the following meanings:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">catch</span> <span class="pre">&lt;type&gt;</span> <span class="pre">&#64;ExcType</span></code></p>
<ul class="simple">
<li><p>This clause means that the landingpad block should be entered if the
exception being thrown is of type <code class="docutils literal notranslate"><span class="pre">&#64;ExcType</span></code> or a subtype of
<code class="docutils literal notranslate"><span class="pre">&#64;ExcType</span></code>. For C++, <code class="docutils literal notranslate"><span class="pre">&#64;ExcType</span></code> is a pointer to the <code class="docutils literal notranslate"><span class="pre">std::type_info</span></code>
object (an RTTI object) representing the C++ exception type.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">&#64;ExcType</span></code> is <code class="docutils literal notranslate"><span class="pre">null</span></code>, any exception matches, so the landingpad
should always be entered. This is used for C++ catch-all blocks (“<code class="docutils literal notranslate"><span class="pre">catch</span>
<span class="pre">(...)</span></code>”).</p></li>
<li><p>When this clause is matched, the selector value will be equal to the value
returned by “<code class="docutils literal notranslate"><span class="pre">&#64;llvm.eh.typeid.for(i8*</span> <span class="pre">&#64;ExcType)</span></code>”. This will always be a
positive value.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">filter</span> <span class="pre">&lt;type&gt;</span> <span class="pre">[&lt;type&gt;</span> <span class="pre">&#64;ExcType1,</span> <span class="pre">...,</span> <span class="pre">&lt;type&gt;</span> <span class="pre">&#64;ExcTypeN]</span></code></p>
<ul class="simple">
<li><p>This clause means that the landingpad should be entered if the exception
being thrown does <em>not</em> match any of the types in the list (which, for C++,
are again specified as <code class="docutils literal notranslate"><span class="pre">std::type_info</span></code> pointers).</p></li>
<li><p>C++ front-ends use this to implement C++ exception specifications, such as
“<code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">foo()</span> <span class="pre">throw</span> <span class="pre">(ExcType1,</span> <span class="pre">...,</span> <span class="pre">ExcTypeN)</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>”.</p></li>
<li><p>When this clause is matched, the selector value will be negative.</p></li>
<li><p>The array argument to <code class="docutils literal notranslate"><span class="pre">filter</span></code> may be empty; for example, “<code class="docutils literal notranslate"><span class="pre">[0</span> <span class="pre">x</span> <span class="pre">i8**]</span>
<span class="pre">undef</span></code>”. This means that the landingpad should always be entered. (Note
that such a <code class="docutils literal notranslate"><span class="pre">filter</span></code> would not be equivalent to “<code class="docutils literal notranslate"><span class="pre">catch</span> <span class="pre">i8*</span> <span class="pre">null</span></code>”,
because <code class="docutils literal notranslate"><span class="pre">filter</span></code> and <code class="docutils literal notranslate"><span class="pre">catch</span></code> produce negative and positive selector
values respectively.)</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">cleanup</span></code></p>
<ul>
<li><p>This clause means that the landingpad should always be entered.</p></li>
<li><p>C++ front-ends use this for calling objects’ destructors.</p></li>
<li><p>When this clause is matched, the selector value will be zero.</p></li>
<li><p>The runtime may treat “<code class="docutils literal notranslate"><span class="pre">cleanup</span></code>” differently from “<code class="docutils literal notranslate"><span class="pre">catch</span> <span class="pre">&lt;type&gt;</span>
<span class="pre">null</span></code>”.</p>
<p>In C++, if an unhandled exception occurs, the language runtime will call
<code class="docutils literal notranslate"><span class="pre">std::terminate()</span></code>, but it is implementation-defined whether the runtime
unwinds the stack and calls object destructors first. For example, the GNU
C++ unwinder does not call object destructors when an unhandled exception
occurs. The reason for this is to improve debuggability: it ensures that
<code class="docutils literal notranslate"><span class="pre">std::terminate()</span></code> is called from the context of the <code class="docutils literal notranslate"><span class="pre">throw</span></code>, so that
this context is not lost by unwinding the stack. A runtime will typically
implement this by searching for a matching non-<code class="docutils literal notranslate"><span class="pre">cleanup</span></code> clause, and
aborting if it does not find one, before entering any landingpad blocks.</p>
</li>
</ul>
</li>
</ul>
<p>Once the landing pad has the type info selector, the code branches to the code
for the first catch. The catch then checks the value of the type info selector
against the index of type info for that catch.  Since the type info index is not
known until all the type infos have been gathered in the backend, the catch code
must call the <a class="reference internal" href="#llvm-eh-typeid-for">llvm.eh.typeid.for</a> intrinsic to determine the index for a given
type info. If the catch fails to match the selector then control is passed on to
the next catch.</p>
<p>Finally, the entry and exit of catch code is bracketed with calls to
<code class="docutils literal notranslate"><span class="pre">__cxa_begin_catch</span></code> and <code class="docutils literal notranslate"><span class="pre">__cxa_end_catch</span></code>.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">__cxa_begin_catch</span></code> takes an exception structure reference as an argument
and returns the value of the exception object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__cxa_end_catch</span></code> takes no arguments. This function:</p>
<ol class="arabic simple">
<li><p>Locates the most recently caught exception and decrements its handler
count,</p></li>
<li><p>Removes the exception from the <em>caught</em> stack if the handler count goes to
zero, and</p></li>
<li><p>Destroys the exception if the handler count goes to zero and the exception
was not re-thrown by throw.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>a rethrow from within the catch may replace this call with a
<code class="docutils literal notranslate"><span class="pre">__cxa_rethrow</span></code>.</p>
</div>
</li>
</ul>
</div>
<div class="section" id="cleanups">
<h3><a class="toc-backref" href="#id16">Cleanups</a><a class="headerlink" href="#cleanups" title="Permalink to this headline">¶</a></h3>
<p>A cleanup is extra code which needs to be run as part of unwinding a scope.  C++
destructors are a typical example, but other languages and language extensions
provide a variety of different kinds of cleanups. In general, a landing pad may
need to run arbitrary amounts of cleanup code before actually entering a catch
block. To indicate the presence of cleanups, a <a class="reference internal" href="LangRef.html#i-landingpad"><span class="std std-ref">‘landingpad’ Instruction</span></a> should have
a <em>cleanup</em> clause.  Otherwise, the unwinder will not stop at the landing pad if
there are no catches or filters that require it to.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Do not allow a new exception to propagate out of the execution of a
cleanup. This can corrupt the internal state of the unwinder.  Different
languages describe different high-level semantics for these situations: for
example, C++ requires that the process be terminated, whereas Ada cancels both
exceptions and throws a third.</p>
</div>
<p>When all cleanups are finished, if the exception is not handled by the current
function, resume unwinding by calling the <a class="reference internal" href="LangRef.html#i-resume"><span class="std std-ref">resume instruction</span></a>,
passing in the result of the <code class="docutils literal notranslate"><span class="pre">landingpad</span></code> instruction for the original
landing pad.</p>
</div>
<div class="section" id="throw-filters">
<h3><a class="toc-backref" href="#id17">Throw Filters</a><a class="headerlink" href="#throw-filters" title="Permalink to this headline">¶</a></h3>
<p>C++ allows the specification of which exception types may be thrown from a
function. To represent this, a top level landing pad may exist to filter out
invalid types. To express this in LLVM code the <a class="reference internal" href="LangRef.html#i-landingpad"><span class="std std-ref">‘landingpad’ Instruction</span></a> will have a
filter clause. The clause consists of an array of type infos.
<code class="docutils literal notranslate"><span class="pre">landingpad</span></code> will return a negative value
if the exception does not match any of the type infos. If no match is found then
a call to <code class="docutils literal notranslate"><span class="pre">__cxa_call_unexpected</span></code> should be made, otherwise
<code class="docutils literal notranslate"><span class="pre">_Unwind_Resume</span></code>.  Each of these functions requires a reference to the
exception structure.  Note that the most general form of a <code class="docutils literal notranslate"><span class="pre">landingpad</span></code>
instruction can have any number of catch, cleanup, and filter clauses (though
having more than one cleanup is pointless). The LLVM C++ front-end can generate
such <code class="docutils literal notranslate"><span class="pre">landingpad</span></code> instructions due to inlining creating nested exception
handling scopes.</p>
</div>
<div class="section" id="restrictions">
<span id="undefined"></span><h3><a class="toc-backref" href="#id18">Restrictions</a><a class="headerlink" href="#restrictions" title="Permalink to this headline">¶</a></h3>
<p>The unwinder delegates the decision of whether to stop in a call frame to that
call frame’s language-specific personality function. Not all unwinders guarantee
that they will stop to perform cleanups. For example, the GNU C++ unwinder
doesn’t do so unless the exception is actually caught somewhere further up the
stack.</p>
<p>In order for inlining to behave correctly, landing pads must be prepared to
handle selector results that they did not originally advertise. Suppose that a
function catches exceptions of type <code class="docutils literal notranslate"><span class="pre">A</span></code>, and it’s inlined into a function that
catches exceptions of type <code class="docutils literal notranslate"><span class="pre">B</span></code>. The inliner will update the <code class="docutils literal notranslate"><span class="pre">landingpad</span></code>
instruction for the inlined landing pad to include the fact that <code class="docutils literal notranslate"><span class="pre">B</span></code> is also
caught. If that landing pad assumes that it will only be entered to catch an
<code class="docutils literal notranslate"><span class="pre">A</span></code>, it’s in for a rude awakening.  Consequently, landing pads must test for
the selector results they understand and then resume exception propagation with
the <a class="reference external" href="LangRef.html#i_resume">resume instruction</a> if none of the conditions
match.</p>
</div>
</div>
<div class="section" id="exception-handling-intrinsics">
<h2><a class="toc-backref" href="#id19">Exception Handling Intrinsics</a><a class="headerlink" href="#exception-handling-intrinsics" title="Permalink to this headline">¶</a></h2>
<p>In addition to the <code class="docutils literal notranslate"><span class="pre">landingpad</span></code> and <code class="docutils literal notranslate"><span class="pre">resume</span></code> instructions, LLVM uses several
intrinsic functions (name prefixed with <code class="docutils literal notranslate"><span class="pre">llvm.eh</span></code>) to provide exception
handling information at various points in generated code.</p>
<div class="section" id="llvm-eh-typeid-for">
<span id="id1"></span><h3><a class="toc-backref" href="#id20"><code class="docutils literal notranslate"><span class="pre">llvm.eh.typeid.for</span></code></a><a class="headerlink" href="#llvm-eh-typeid-for" title="Permalink to this headline">¶</a></h3>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">i32</span> <span class="vg">@llvm.eh.typeid.for</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%type_info</span><span class="p">)</span>
</pre></div>
</div>
<p>This intrinsic returns the type info index in the exception table of the current
function.  This value can be used to compare against the result of
<code class="docutils literal notranslate"><span class="pre">landingpad</span></code> instruction.  The single argument is a reference to a type info.</p>
<p>Uses of this intrinsic are generated by the C++ front-end.</p>
</div>
<div class="section" id="llvm-eh-begincatch">
<span id="id2"></span><h3><a class="toc-backref" href="#id21"><code class="docutils literal notranslate"><span class="pre">llvm.eh.begincatch</span></code></a><a class="headerlink" href="#llvm-eh-begincatch" title="Permalink to this headline">¶</a></h3>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">void</span> <span class="vg">@llvm.eh.begincatch</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%ehptr</span><span class="p">,</span> <span class="k">i8</span><span class="p">*</span> <span class="nv">%ehobj</span><span class="p">)</span>
</pre></div>
</div>
<p>This intrinsic marks the beginning of catch handling code within the blocks
following a <code class="docutils literal notranslate"><span class="pre">landingpad</span></code> instruction.  The exact behavior of this function
depends on the compilation target and the personality function associated
with the <code class="docutils literal notranslate"><span class="pre">landingpad</span></code> instruction.</p>
<p>The first argument to this intrinsic is a pointer that was previously extracted
from the aggregate return value of the <code class="docutils literal notranslate"><span class="pre">landingpad</span></code> instruction.  The second
argument to the intrinsic is a pointer to stack space where the exception object
should be stored. The runtime handles the details of copying the exception
object into the slot. If the second parameter is null, no copy occurs.</p>
<p>Uses of this intrinsic are generated by the C++ front-end.  Many targets will
use implementation-specific functions (such as <code class="docutils literal notranslate"><span class="pre">__cxa_begin_catch</span></code>) instead
of this intrinsic.  The intrinsic is provided for targets that require a more
abstract interface.</p>
<p>When used in the native Windows C++ exception handling implementation, this
intrinsic serves as a placeholder to delimit code before a catch handler is
outlined.  When the handler is outlined, this intrinsic will be replaced
by instructions that retrieve the exception object pointer from the frame
allocation block.</p>
</div>
<div class="section" id="llvm-eh-endcatch">
<span id="id3"></span><h3><a class="toc-backref" href="#id22"><code class="docutils literal notranslate"><span class="pre">llvm.eh.endcatch</span></code></a><a class="headerlink" href="#llvm-eh-endcatch" title="Permalink to this headline">¶</a></h3>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">void</span> <span class="vg">@llvm.eh.endcatch</span><span class="p">()</span>
</pre></div>
</div>
<p>This intrinsic marks the end of catch handling code within the current block,
which will be a successor of a block which called <code class="docutils literal notranslate"><span class="pre">llvm.eh.begincatch''.</span>
<span class="pre">The</span> <span class="pre">exact</span> <span class="pre">behavior</span> <span class="pre">of</span> <span class="pre">this</span> <span class="pre">function</span> <span class="pre">depends</span> <span class="pre">on</span> <span class="pre">the</span> <span class="pre">compilation</span> <span class="pre">target</span> <span class="pre">and</span> <span class="pre">the</span>
<span class="pre">personality</span> <span class="pre">function</span> <span class="pre">associated</span> <span class="pre">with</span> <span class="pre">the</span> <span class="pre">corresponding</span> <span class="pre">``landingpad</span></code>
instruction.</p>
<p>There may be more than one call to <code class="docutils literal notranslate"><span class="pre">llvm.eh.endcatch</span></code> for any given call to
<code class="docutils literal notranslate"><span class="pre">llvm.eh.begincatch</span></code> with each <code class="docutils literal notranslate"><span class="pre">llvm.eh.endcatch</span></code> call corresponding to the
end of a different control path.  All control paths following a call to
<code class="docutils literal notranslate"><span class="pre">llvm.eh.begincatch</span></code> must reach a call to <code class="docutils literal notranslate"><span class="pre">llvm.eh.endcatch</span></code>.</p>
<p>Uses of this intrinsic are generated by the C++ front-end.  Many targets will
use implementation-specific functions (such as <code class="docutils literal notranslate"><span class="pre">__cxa_begin_catch</span></code>) instead
of this intrinsic.  The intrinsic is provided for targets that require a more
abstract interface.</p>
<p>When used in the native Windows C++ exception handling implementation, this
intrinsic serves as a placeholder to delimit code before a catch handler is
outlined.  After the handler is outlined, this intrinsic is simply removed.</p>
</div>
<div class="section" id="llvm-eh-exceptionpointer">
<span id="id4"></span><h3><a class="toc-backref" href="#id23"><code class="docutils literal notranslate"><span class="pre">llvm.eh.exceptionpointer</span></code></a><a class="headerlink" href="#llvm-eh-exceptionpointer" title="Permalink to this headline">¶</a></h3>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>i8 addrspace(N)* @llvm.eh.padparam.pNi8(token %catchpad)
</pre></div>
</div>
<p>This intrinsic retrieves a pointer to the exception caught by the given
<code class="docutils literal notranslate"><span class="pre">catchpad</span></code>.</p>
</div>
<div class="section" id="sjlj-intrinsics">
<h3><a class="toc-backref" href="#id24">SJLJ Intrinsics</a><a class="headerlink" href="#sjlj-intrinsics" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">llvm.eh.sjlj</span></code> intrinsics are used internally within LLVM’s
backend.  Uses of them are generated by the backend’s
<code class="docutils literal notranslate"><span class="pre">SjLjEHPrepare</span></code> pass.</p>
<div class="section" id="llvm-eh-sjlj-setjmp">
<span id="id5"></span><h4><a class="toc-backref" href="#id25"><code class="docutils literal notranslate"><span class="pre">llvm.eh.sjlj.setjmp</span></code></a><a class="headerlink" href="#llvm-eh-sjlj-setjmp" title="Permalink to this headline">¶</a></h4>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>i32 @llvm.eh.sjlj.setjmp(i8* %setjmp_buf)
</pre></div>
</div>
<p>For SJLJ based exception handling, this intrinsic forces register saving for the
current function and stores the address of the following instruction for use as
a destination address by <a class="reference internal" href="#llvm-eh-sjlj-longjmp">llvm.eh.sjlj.longjmp</a>. The buffer format and the
overall functioning of this intrinsic is compatible with the GCC
<code class="docutils literal notranslate"><span class="pre">__builtin_setjmp</span></code> implementation allowing code built with the clang and GCC
to interoperate.</p>
<p>The single parameter is a pointer to a five word buffer in which the calling
context is saved. The front end places the frame pointer in the first word, and
the target implementation of this intrinsic should place the destination address
for a <a class="reference internal" href="#llvm-eh-sjlj-longjmp">llvm.eh.sjlj.longjmp</a> in the second word. The following three words are
available for use in a target-specific manner.</p>
</div>
<div class="section" id="llvm-eh-sjlj-longjmp">
<span id="id6"></span><h4><a class="toc-backref" href="#id26"><code class="docutils literal notranslate"><span class="pre">llvm.eh.sjlj.longjmp</span></code></a><a class="headerlink" href="#llvm-eh-sjlj-longjmp" title="Permalink to this headline">¶</a></h4>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">void</span> <span class="vg">@llvm.eh.sjlj.longjmp</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="nv">%setjmp_buf</span><span class="p">)</span>
</pre></div>
</div>
<p>For SJLJ based exception handling, the <code class="docutils literal notranslate"><span class="pre">llvm.eh.sjlj.longjmp</span></code> intrinsic is
used to implement <code class="docutils literal notranslate"><span class="pre">__builtin_longjmp()</span></code>. The single parameter is a pointer to
a buffer populated by <a class="reference internal" href="#llvm-eh-sjlj-setjmp">llvm.eh.sjlj.setjmp</a>. The frame pointer and stack
pointer are restored from the buffer, then control is transferred to the
destination address.</p>
</div>
<div class="section" id="llvm-eh-sjlj-lsda">
<h4><a class="toc-backref" href="#id27"><code class="docutils literal notranslate"><span class="pre">llvm.eh.sjlj.lsda</span></code></a><a class="headerlink" href="#llvm-eh-sjlj-lsda" title="Permalink to this headline">¶</a></h4>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">i8</span><span class="p">*</span> <span class="vg">@llvm.eh.sjlj.lsda</span><span class="p">()</span>
</pre></div>
</div>
<p>For SJLJ based exception handling, the <code class="docutils literal notranslate"><span class="pre">llvm.eh.sjlj.lsda</span></code> intrinsic returns
the address of the Language Specific Data Area (LSDA) for the current
function. The SJLJ front-end code stores this address in the exception handling
function context for use by the runtime.</p>
</div>
<div class="section" id="llvm-eh-sjlj-callsite">
<h4><a class="toc-backref" href="#id28"><code class="docutils literal notranslate"><span class="pre">llvm.eh.sjlj.callsite</span></code></a><a class="headerlink" href="#llvm-eh-sjlj-callsite" title="Permalink to this headline">¶</a></h4>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">void</span> <span class="vg">@llvm.eh.sjlj.callsite</span><span class="p">(</span><span class="k">i32</span> <span class="nv">%call_site_num</span><span class="p">)</span>
</pre></div>
</div>
<p>For SJLJ based exception handling, the <code class="docutils literal notranslate"><span class="pre">llvm.eh.sjlj.callsite</span></code> intrinsic
identifies the callsite value associated with the following <code class="docutils literal notranslate"><span class="pre">invoke</span></code>
instruction. This is used to ensure that landing pad entries in the LSDA are
generated in matching order.</p>
</div>
</div>
</div>
<div class="section" id="asm-table-formats">
<h2><a class="toc-backref" href="#id29">Asm Table Formats</a><a class="headerlink" href="#asm-table-formats" title="Permalink to this headline">¶</a></h2>
<p>There are two tables that are used by the exception handling runtime to
determine which actions should be taken when an exception is thrown.</p>
<div class="section" id="exception-handling-frame">
<h3><a class="toc-backref" href="#id30">Exception Handling Frame</a><a class="headerlink" href="#exception-handling-frame" title="Permalink to this headline">¶</a></h3>
<p>An exception handling frame <code class="docutils literal notranslate"><span class="pre">eh_frame</span></code> is very similar to the unwind frame
used by DWARF debug info. The frame contains all the information necessary to
tear down the current frame and restore the state of the prior frame. There is
an exception handling frame for each function in a compile unit, plus a common
exception handling frame that defines information common to all functions in the
unit.</p>
<p>The format of this call frame information (CFI) is often platform-dependent,
however. ARM, for example, defines their own format. Apple has their own compact
unwind info format.  On Windows, another format is used for all architectures
since 32-bit x86.  LLVM will emit whatever information is required by the
target.</p>
</div>
<div class="section" id="exception-tables">
<h3><a class="toc-backref" href="#id31">Exception Tables</a><a class="headerlink" href="#exception-tables" title="Permalink to this headline">¶</a></h3>
<p>An exception table contains information about what actions to take when an
exception is thrown in a particular part of a function’s code. This is typically
referred to as the language-specific data area (LSDA). The format of the LSDA
table is specific to the personality function, but the majority of personalities
out there use a variation of the tables consumed by <code class="docutils literal notranslate"><span class="pre">__gxx_personality_v0</span></code>.
There is one exception table per function, except leaf functions and functions
that have calls only to non-throwing functions. They do not need an exception
table.</p>
</div>
</div>
<div class="section" id="exception-handling-using-the-windows-runtime">
<span id="wineh"></span><h2><a class="toc-backref" href="#id32">Exception Handling using the Windows Runtime</a><a class="headerlink" href="#exception-handling-using-the-windows-runtime" title="Permalink to this headline">¶</a></h2>
<div class="section" id="background-on-windows-exceptions">
<h3><a class="toc-backref" href="#id33">Background on Windows exceptions</a><a class="headerlink" href="#background-on-windows-exceptions" title="Permalink to this headline">¶</a></h3>
<p>Interacting with exceptions on Windows is significantly more complicated than
on Itanium C++ ABI platforms. The fundamental difference between the two models
is that Itanium EH is designed around the idea of “successive unwinding,” while
Windows EH is not.</p>
<p>Under Itanium, throwing an exception typically involes allocating thread local
memory to hold the exception, and calling into the EH runtime. The runtime
identifies frames with appropriate exception handling actions, and successively
resets the register context of the current thread to the most recently active
frame with actions to run. In LLVM, execution resumes at a <code class="docutils literal notranslate"><span class="pre">landingpad</span></code>
instruction, which produces register values provided by the runtime. If a
function is only cleaning up allocated resources, the function is responsible
for calling <code class="docutils literal notranslate"><span class="pre">_Unwind_Resume</span></code> to transition to the next most recently active
frame after it is finished cleaning up. Eventually, the frame responsible for
handling the exception calls <code class="docutils literal notranslate"><span class="pre">__cxa_end_catch</span></code> to destroy the exception,
release its memory, and resume normal control flow.</p>
<p>The Windows EH model does not use these successive register context resets.
Instead, the active exception is typically described by a frame on the stack.
In the case of C++ exceptions, the exception object is allocated in stack memory
and its address is passed to <code class="docutils literal notranslate"><span class="pre">__CxxThrowException</span></code>. General purpose structured
exceptions (SEH) are more analogous to Linux signals, and they are dispatched by
userspace DLLs provided with Windows. Each frame on the stack has an assigned EH
personality routine, which decides what actions to take to handle the exception.
There are a few major personalities for C and C++ code: the C++ personality
(<code class="docutils literal notranslate"><span class="pre">__CxxFrameHandler3</span></code>) and the SEH personalities (<code class="docutils literal notranslate"><span class="pre">_except_handler3</span></code>,
<code class="docutils literal notranslate"><span class="pre">_except_handler4</span></code>, and <code class="docutils literal notranslate"><span class="pre">__C_specific_handler</span></code>). All of them implement
cleanups by calling back into a “funclet” contained in the parent function.</p>
<p>Funclets, in this context, are regions of the parent function that can be called
as though they were a function pointer with a very special calling convention.
The frame pointer of the parent frame is passed into the funclet either using
the standard EBP register or as the first parameter register, depending on the
architecture. The funclet implements the EH action by accessing local variables
in memory through the frame pointer, and returning some appropriate value,
continuing the EH process.  No variables live in to or out of the funclet can be
allocated in registers.</p>
<p>The C++ personality also uses funclets to contain the code for catch blocks
(i.e. all user code between the braces in <code class="docutils literal notranslate"><span class="pre">catch</span> <span class="pre">(Type</span> <span class="pre">obj)</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>). The
runtime must use funclets for catch bodies because the C++ exception object is
allocated in a child stack frame of the function handling the exception. If the
runtime rewound the stack back to frame of the catch, the memory holding the
exception would be overwritten quickly by subsequent function calls.  The use of
funclets also allows <code class="docutils literal notranslate"><span class="pre">__CxxFrameHandler3</span></code> to implement rethrow without
resorting to TLS. Instead, the runtime throws a special exception, and then uses
SEH (<code class="docutils literal notranslate"><span class="pre">__try</span> <span class="pre">/</span> <span class="pre">__except</span></code>) to resume execution with new information in the child
frame.</p>
<p>In other words, the successive unwinding approach is incompatible with Visual
C++ exceptions and general purpose Windows exception handling. Because the C++
exception object lives in stack memory, LLVM cannot provide a custom personality
function that uses landingpads.  Similarly, SEH does not provide any mechanism
to rethrow an exception or continue unwinding.  Therefore, LLVM must use the IR
constructs described later in this document to implement compatible exception
handling.</p>
</div>
<div class="section" id="seh-filter-expressions">
<h3><a class="toc-backref" href="#id34">SEH filter expressions</a><a class="headerlink" href="#seh-filter-expressions" title="Permalink to this headline">¶</a></h3>
<p>The SEH personality functions also use funclets to implement filter expressions,
which allow executing arbitrary user code to decide which exceptions to catch.
Filter expressions should not be confused with the <code class="docutils literal notranslate"><span class="pre">filter</span></code> clause of the LLVM
<code class="docutils literal notranslate"><span class="pre">landingpad</span></code> instruction.  Typically filter expressions are used to determine
if the exception came from a particular DLL or code region, or if code faulted
while accessing a particular memory address range. LLVM does not currently have
IR to represent filter expressions because it is difficult to represent their
control dependencies.  Filter expressions run during the first phase of EH,
before cleanups run, making it very difficult to build a faithful control flow
graph.  For now, the new EH instructions cannot represent SEH filter
expressions, and frontends must outline them ahead of time. Local variables of
the parent function can be escaped and accessed using the <code class="docutils literal notranslate"><span class="pre">llvm.localescape</span></code>
and <code class="docutils literal notranslate"><span class="pre">llvm.localrecover</span></code> intrinsics.</p>
</div>
<div class="section" id="new-exception-handling-instructions">
<h3><a class="toc-backref" href="#id35">New exception handling instructions</a><a class="headerlink" href="#new-exception-handling-instructions" title="Permalink to this headline">¶</a></h3>
<p>The primary design goal of the new EH instructions is to support funclet
generation while preserving information about the CFG so that SSA formation
still works.  As a secondary goal, they are designed to be generic across MSVC
and Itanium C++ exceptions. They make very few assumptions about the data
required by the personality, so long as it uses the familiar core EH actions:
catch, cleanup, and terminate.  However, the new instructions are hard to modify
without knowing details of the EH personality. While they can be used to
represent Itanium EH, the landingpad model is strictly better for optimization
purposes.</p>
<p>The following new instructions are considered “exception handling pads”, in that
they must be the first non-phi instruction of a basic block that may be the
unwind destination of an EH flow edge:
<code class="docutils literal notranslate"><span class="pre">catchswitch</span></code>, <code class="docutils literal notranslate"><span class="pre">catchpad</span></code>, and <code class="docutils literal notranslate"><span class="pre">cleanuppad</span></code>.
As with landingpads, when entering a try scope, if the
frontend encounters a call site that may throw an exception, it should emit an
invoke that unwinds to a <code class="docutils literal notranslate"><span class="pre">catchswitch</span></code> block. Similarly, inside the scope of a
C++ object with a destructor, invokes should unwind to a <code class="docutils literal notranslate"><span class="pre">cleanuppad</span></code>.</p>
<p>New instructions are also used to mark the points where control is transferred
out of a catch/cleanup handler (which will correspond to exits from the
generated funclet).  A catch handler which reaches its end by normal execution
executes a <code class="docutils literal notranslate"><span class="pre">catchret</span></code> instruction, which is a terminator indicating where in
the function control is returned to.  A cleanup handler which reaches its end
by normal execution executes a <code class="docutils literal notranslate"><span class="pre">cleanupret</span></code> instruction, which is a terminator
indicating where the active exception will unwind to next.</p>
<p>Each of these new EH pad instructions has a way to identify which action should
be considered after this action. The <code class="docutils literal notranslate"><span class="pre">catchswitch</span></code> instruction is a terminator
and has an unwind destination operand analogous to the unwind destination of an
invoke.  The <code class="docutils literal notranslate"><span class="pre">cleanuppad</span></code> instruction is not
a terminator, so the unwind destination is stored on the <code class="docutils literal notranslate"><span class="pre">cleanupret</span></code>
instruction instead. Successfully executing a catch handler should resume
normal control flow, so neither <code class="docutils literal notranslate"><span class="pre">catchpad</span></code> nor <code class="docutils literal notranslate"><span class="pre">catchret</span></code> instructions can
unwind. All of these “unwind edges” may refer to a basic block that contains an
EH pad instruction, or they may unwind to the caller.  Unwinding to the caller
has roughly the same semantics as the <code class="docutils literal notranslate"><span class="pre">resume</span></code> instruction in the landingpad
model. When inlining through an invoke, instructions that unwind to the caller
are hooked up to unwind to the unwind destination of the call site.</p>
<p>Putting things together, here is a hypothetical lowering of some C++ that uses
all of the new IR instructions:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">Cleanup</span> <span class="p">{</span>
  <span class="n">Cleanup</span><span class="p">();</span>
  <span class="o">~</span><span class="n">Cleanup</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">m</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">may_throw</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">f</span><span class="p">()</span> <span class="n">noexcept</span> <span class="p">{</span>
  <span class="n">try</span> <span class="p">{</span>
    <span class="n">Cleanup</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">may_throw</span><span class="p">();</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="kt">int</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">may_throw</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">e</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>define i32 @f() nounwind personality i32 (...)* @__CxxFrameHandler3 {
entry:
  %obj = alloca %struct.Cleanup, align 4
  %e = alloca i32, align 4
  %call = invoke %struct.Cleanup* @&quot;\01??0Cleanup@@QEAA@XZ&quot;(%struct.Cleanup* nonnull %obj)
          to label %invoke.cont unwind label %lpad.catch

invoke.cont:                                      ; preds = %entry
  invoke void @&quot;\01?may_throw@@YAXXZ&quot;()
          to label %invoke.cont.2 unwind label %lpad.cleanup

invoke.cont.2:                                    ; preds = %invoke.cont
  call void @&quot;\01??_DCleanup@@QEAA@XZ&quot;(%struct.Cleanup* nonnull %obj) nounwind
  br label %return

return:                                           ; preds = %invoke.cont.3, %invoke.cont.2
  %retval.0 = phi i32 [ 0, %invoke.cont.2 ], [ %3, %invoke.cont.3 ]
  ret i32 %retval.0

lpad.cleanup:                                     ; preds = %invoke.cont.2
  %0 = cleanuppad within none []
  call void @&quot;\01??1Cleanup@@QEAA@XZ&quot;(%struct.Cleanup* nonnull %obj) nounwind
  cleanupret %0 unwind label %lpad.catch

lpad.catch:                                       ; preds = %lpad.cleanup, %entry
  %1 = catchswitch within none [label %catch.body] unwind label %lpad.terminate

catch.body:                                       ; preds = %lpad.catch
  %catch = catchpad within %1 [%rtti.TypeDescriptor2* @&quot;\01??_R0H@8&quot;, i32 0, i32* %e]
  invoke void @&quot;\01?may_throw@@YAXXZ&quot;()
          to label %invoke.cont.3 unwind label %lpad.terminate

invoke.cont.3:                                    ; preds = %catch.body
  %3 = load i32, i32* %e, align 4
  catchret from %catch to label %return

lpad.terminate:                                   ; preds = %catch.body, %lpad.catch
  cleanuppad within none []
  call void @&quot;\01?terminate@@YAXXZ&quot;
  unreachable
}
</pre></div>
</div>
</div>
<div class="section" id="funclet-parent-tokens">
<h3><a class="toc-backref" href="#id36">Funclet parent tokens</a><a class="headerlink" href="#funclet-parent-tokens" title="Permalink to this headline">¶</a></h3>
<p>In order to produce tables for EH personalities that use funclets, it is
necessary to recover the nesting that was present in the source. This funclet
parent relationship is encoded in the IR using tokens produced by the new “pad”
instructions. The token operand of a “pad” or “ret” instruction indicates which
funclet it is in, or “none” if it is not nested within another funclet.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">catchpad</span></code> and <code class="docutils literal notranslate"><span class="pre">cleanuppad</span></code> instructions establish new funclets, and
their tokens are consumed by other “pad” instructions to establish membership.
The <code class="docutils literal notranslate"><span class="pre">catchswitch</span></code> instruction does not create a funclet, but it produces a
token that is always consumed by its immediate successor <code class="docutils literal notranslate"><span class="pre">catchpad</span></code>
instructions. This ensures that every catch handler modelled by a <code class="docutils literal notranslate"><span class="pre">catchpad</span></code>
belongs to exactly one <code class="docutils literal notranslate"><span class="pre">catchswitch</span></code>, which models the dispatch point after a
C++ try.</p>
<p>Here is an example of what this nesting looks like using some hypothetical
C++ code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">try</span> <span class="p">{</span>
    <span class="n">throw</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="n">try</span> <span class="p">{</span>
      <span class="n">throw</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">catch</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>define void @f() #0 personality i8* bitcast (i32 (...)* @__CxxFrameHandler3 to i8*) {
entry:
  invoke void @_CxxThrowException(i8* null, %eh.ThrowInfo* null) #1
          to label %unreachable unwind label %catch.dispatch

catch.dispatch:                                   ; preds = %entry
  %0 = catchswitch within none [label %catch] unwind to caller

catch:                                            ; preds = %catch.dispatch
  %1 = catchpad within %0 [i8* null, i32 64, i8* null]
  invoke void @_CxxThrowException(i8* null, %eh.ThrowInfo* null) #1
          to label %unreachable unwind label %catch.dispatch2

catch.dispatch2:                                  ; preds = %catch
  %2 = catchswitch within %1 [label %catch3] unwind to caller

catch3:                                           ; preds = %catch.dispatch2
  %3 = catchpad within %2 [i8* null, i32 64, i8* null]
  catchret from %3 to label %try.cont

try.cont:                                         ; preds = %catch3
  catchret from %1 to label %try.cont6

try.cont6:                                        ; preds = %try.cont
  ret void

unreachable:                                      ; preds = %catch, %entry
  unreachable
}
</pre></div>
</div>
<p>The “inner” <code class="docutils literal notranslate"><span class="pre">catchswitch</span></code> consumes <code class="docutils literal notranslate"><span class="pre">%1</span></code> which is produced by the outer
catchswitch.</p>
</div>
<div class="section" id="funclet-transitions">
<span id="wineh-constraints"></span><h3><a class="toc-backref" href="#id37">Funclet transitions</a><a class="headerlink" href="#funclet-transitions" title="Permalink to this headline">¶</a></h3>
<p>The EH tables for personalities that use funclets make implicit use of the
funclet nesting relationship to encode unwind destinations, and so are
constrained in the set of funclet transitions they can represent.  The related
LLVM IR instructions accordingly have constraints that ensure encodability of
the EH edges in the flow graph.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">catchswitch</span></code>, <code class="docutils literal notranslate"><span class="pre">catchpad</span></code>, or <code class="docutils literal notranslate"><span class="pre">cleanuppad</span></code> is said to be “entered”
when it executes.  It may subsequently be “exited” by any of the following
means:</p>
<ul class="simple">
<li><p>A <code class="docutils literal notranslate"><span class="pre">catchswitch</span></code> is immediately exited when none of its constituent
<code class="docutils literal notranslate"><span class="pre">catchpad</span></code>s are appropriate for the in-flight exception and it unwinds
to its unwind destination or the caller.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">catchpad</span></code> and its parent <code class="docutils literal notranslate"><span class="pre">catchswitch</span></code> are both exited when a
<code class="docutils literal notranslate"><span class="pre">catchret</span></code> from the <code class="docutils literal notranslate"><span class="pre">catchpad</span></code> is executed.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">cleanuppad</span></code> is exited when a <code class="docutils literal notranslate"><span class="pre">cleanupret</span></code> from it is executed.</p></li>
<li><p>Any of these pads is exited when control unwinds to the function’s caller,
either by a <code class="docutils literal notranslate"><span class="pre">call</span></code> which unwinds all the way to the function’s caller,
a nested <code class="docutils literal notranslate"><span class="pre">catchswitch</span></code> marked “<code class="docutils literal notranslate"><span class="pre">unwinds</span> <span class="pre">to</span> <span class="pre">caller</span></code>”, or a nested
<code class="docutils literal notranslate"><span class="pre">cleanuppad</span></code>’s <code class="docutils literal notranslate"><span class="pre">cleanupret</span></code> marked “<code class="docutils literal notranslate"><span class="pre">unwinds</span> <span class="pre">to</span> <span class="pre">caller&quot;</span></code>.</p></li>
<li><p>Any of these pads is exited when an unwind edge (from an <code class="docutils literal notranslate"><span class="pre">invoke</span></code>,
nested <code class="docutils literal notranslate"><span class="pre">catchswitch</span></code>, or nested <code class="docutils literal notranslate"><span class="pre">cleanuppad</span></code>’s <code class="docutils literal notranslate"><span class="pre">cleanupret</span></code>)
unwinds to a destination pad that is not a descendant of the given pad.</p></li>
</ul>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">ret</span></code> instruction is <em>not</em> a valid way to exit a funclet pad;
it is undefined behavior to execute a <code class="docutils literal notranslate"><span class="pre">ret</span></code> when a pad has been entered but
not exited.</p>
<p>A single unwind edge may exit any number of pads (with the restrictions that
the edge from a <code class="docutils literal notranslate"><span class="pre">catchswitch</span></code> must exit at least itself, and the edge from
a <code class="docutils literal notranslate"><span class="pre">cleanupret</span></code> must exit at least its <code class="docutils literal notranslate"><span class="pre">cleanuppad</span></code>), and then must enter
exactly one pad, which must be distinct from all the exited pads.  The parent
of the pad that an unwind edge enters must be the most-recently-entered
not-yet-exited pad (after exiting from any pads that the unwind edge exits),
or “none” if there is no such pad.  This ensures that the stack of executing
funclets at run-time always corresponds to some path in the funclet pad tree
that the parent tokens encode.</p>
<p>All unwind edges which exit any given funclet pad (including <code class="docutils literal notranslate"><span class="pre">cleanupret</span></code>
edges exiting their <code class="docutils literal notranslate"><span class="pre">cleanuppad</span></code> and <code class="docutils literal notranslate"><span class="pre">catchswitch</span></code> edges exiting their
<code class="docutils literal notranslate"><span class="pre">catchswitch</span></code>) must share the same unwind destination.  Similarly, any
funclet pad which may be exited by unwind to caller must not be exited by
any exception edges which unwind anywhere other than the caller.  This
ensures that each funclet as a whole has only one unwind destination, which
EH tables for funclet personalities may require.  Note that any unwind edge
which exits a <code class="docutils literal notranslate"><span class="pre">catchpad</span></code> also exits its parent <code class="docutils literal notranslate"><span class="pre">catchswitch</span></code>, so this
implies that for any given <code class="docutils literal notranslate"><span class="pre">catchswitch</span></code>, its unwind destination must also
be the unwind destination of any unwind edge that exits any of its constituent
<code class="docutils literal notranslate"><span class="pre">catchpad</span></code>s.  Because <code class="docutils literal notranslate"><span class="pre">catchswitch</span></code> has no <code class="docutils literal notranslate"><span class="pre">nounwind</span></code> variant, and
because IR producers are not <em>required</em> to annotate calls which will not
unwind as <code class="docutils literal notranslate"><span class="pre">nounwind</span></code>, it is legal to nest a <code class="docutils literal notranslate"><span class="pre">call</span></code> or an “<code class="docutils literal notranslate"><span class="pre">unwind</span> <span class="pre">to</span>
<span class="pre">caller</span></code>” <code class="docutils literal notranslate"><span class="pre">catchswitch</span></code> within a funclet pad that has an unwind
destination other than caller; it is undefined behavior for such a <code class="docutils literal notranslate"><span class="pre">call</span></code>
or <code class="docutils literal notranslate"><span class="pre">catchswitch</span></code> to unwind.</p>
<p>Finally, the funclet pads’ unwind destinations cannot form a cycle.  This
ensures that EH lowering can construct “try regions” with a tree-like
structure, which funclet-based personalities may require.</p>
</div>
</div>
<div class="section" id="exception-handling-support-on-the-target">
<h2><a class="toc-backref" href="#id38">Exception Handling support on the target</a><a class="headerlink" href="#exception-handling-support-on-the-target" title="Permalink to this headline">¶</a></h2>
<p>In order to support exception handling on particular target, there are a few
items need to be implemented.</p>
<ul>
<li><p>CFI directives</p>
<p>First, you have to assign each target register with a unique DWARF number.
Then in <code class="docutils literal notranslate"><span class="pre">TargetFrameLowering</span></code>’s <code class="docutils literal notranslate"><span class="pre">emitPrologue</span></code>, you have to emit <a class="reference external" href="https://sourceware.org/binutils/docs/as/CFI-directives.html">CFI
directives</a>
to specify how to calculate the CFA (Canonical Frame Address) and how register
is restored from the address pointed by the CFA with an offset. The assembler
is instructed by CFI directives to build <code class="docutils literal notranslate"><span class="pre">.eh_frame</span></code> section, which is used
by th unwinder to unwind stack during exception handling.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">getExceptionPointerRegister</span></code> and <code class="docutils literal notranslate"><span class="pre">getExceptionSelectorRegister</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">TargetLowering</span></code> must implement both functions. The <em>personality function</em>
passes the <em>exception structure</em> (a pointer) and <em>selector value</em> (an integer)
to the landing pad through the registers specified by <code class="docutils literal notranslate"><span class="pre">getExceptionPointerRegister</span></code>
and <code class="docutils literal notranslate"><span class="pre">getExceptionSelectorRegister</span></code> respectively. On most platforms, they
will be GPRs and will be the same as the ones specified in the calling convention.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">EH_RETURN</span></code></p>
<p>The ISD node represents the undocumented GCC extension <code class="docutils literal notranslate"><span class="pre">__builtin_eh_return</span> <span class="pre">(offset,</span> <span class="pre">handler)</span></code>,
which adjusts the stack by offset and then jumps to the handler. <code class="docutils literal notranslate"><span class="pre">__builtin_eh_return</span></code>
is used in GCC unwinder (<a class="reference external" href="https://gcc.gnu.org/onlinedocs/gccint/Libgcc.html">libgcc</a>),
but not in LLVM unwinder (<a class="reference external" href="https://clang.llvm.org/docs/Toolchain.html#unwind-library">libunwind</a>).
If you are on the top of <code class="docutils literal notranslate"><span class="pre">libgcc</span></code> and have particular requirement on your target,
you have to handle <code class="docutils literal notranslate"><span class="pre">EH_RETURN</span></code> in <code class="docutils literal notranslate"><span class="pre">TargetLowering</span></code>.</p>
</li>
</ul>
<p>If you don’t leverage the existing runtime (<code class="docutils literal notranslate"><span class="pre">libstdc++</span></code> and <code class="docutils literal notranslate"><span class="pre">libgcc</span></code>),
you have to take a look on <a class="reference external" href="https://libcxx.llvm.org/">libc++</a> and
<a class="reference external" href="https://clang.llvm.org/docs/Toolchain.html#unwind-library">libunwind</a>
to see what have to be done there. For <code class="docutils literal notranslate"><span class="pre">libunwind</span></code>, you have to do the following</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">__libunwind_config.h</span></code></p>
<p>Define macros for your target.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">include/libunwind.h</span></code></p>
<p>Define enum for the target registers.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">src/Registers.hpp</span></code></p>
<p>Define <code class="docutils literal notranslate"><span class="pre">Registers</span></code> class for your target, implement setter and getter functions.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">src/UnwindCursor.hpp</span></code></p>
<p>Define <code class="docutils literal notranslate"><span class="pre">dwarfEncoding</span></code> and <code class="docutils literal notranslate"><span class="pre">stepWithCompactEncoding</span></code> for your <code class="docutils literal notranslate"><span class="pre">Registers</span></code>
class.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">src/UnwindRegistersRestore.S</span></code></p>
<p>Write an assembly function to restore all your target registers from the memory.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">src/UnwindRegistersSave.S</span></code></p>
<p>Write an assembly function to save all your target registers on the memory.</p>
</li>
</ul>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="AddingConstrainedIntrinsics.html" title="How To Add A Constrained Floating-Point Intrinsic"
             >next</a> |</li>
        <li class="right" >
          <a href="CodeGenerator.html" title="The LLVM Target-Independent Code Generator"
             >previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2003-2020, LLVM Project.
      Last updated on 2020-01-13.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.3.1.
    </div>
  </body>
</html>