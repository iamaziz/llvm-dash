

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  
<!-- Mirrored from llvm.org/docs/ProgrammersManual.html by HTTrack Website Copier/3.x [XR&CO'2013], Sat, 26 Apr 2014 21:32:25 GMT -->
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>LLVM Programmer’s Manual &mdash; LLVM 3.4 documentation</title>
    
    <link rel="stylesheet" href="_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="LLVM 3.4 documentation" href="index-2.html" />
    <link rel="next" title="LLVM Extensions" href="Extensions.html" />
    <link rel="prev" title="How to set up LLVM-style RTTI for your class hierarchy" href="HowToSetUpLLVMStyleRTTI.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head>
  <body>
<div class="logo">
  <a href="index-2.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="Extensions.html" title="LLVM Extensions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="HowToSetUpLLVMStyleRTTI.html" title="How to set up LLVM-style RTTI for your class hierarchy"
             accesskey="P">previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index-2.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="llvm-programmer-s-manual">
<h1>LLVM Programmer&#8217;s Manual<a class="headerlink" href="#llvm-programmer-s-manual" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id6">Introduction</a></li>
<li><a class="reference internal" href="#general-information" id="id7">General Information</a><ul>
<li><a class="reference internal" href="#the-c-standard-template-library" id="id8">The C++ Standard Template Library</a></li>
<li><a class="reference internal" href="#other-useful-references" id="id9">Other useful references</a></li>
</ul>
</li>
<li><a class="reference internal" href="#important-and-useful-llvm-apis" id="id10">Important and useful LLVM APIs</a><ul>
<li><a class="reference internal" href="#the-isa-cast-and-dyn-cast-templates" id="id11">The <tt class="docutils literal"><span class="pre">isa&lt;&gt;</span></tt>, <tt class="docutils literal"><span class="pre">cast&lt;&gt;</span></tt> and <tt class="docutils literal"><span class="pre">dyn_cast&lt;&gt;</span></tt> templates</a></li>
<li><a class="reference internal" href="#passing-strings-the-stringref-and-twine-classes" id="id12">Passing strings (the <tt class="docutils literal"><span class="pre">StringRef</span></tt> and <tt class="docutils literal"><span class="pre">Twine</span></tt> classes)</a><ul>
<li><a class="reference internal" href="#the-stringref-class" id="id13">The <tt class="docutils literal"><span class="pre">StringRef</span></tt> class</a></li>
<li><a class="reference internal" href="#the-twine-class" id="id14">The <tt class="docutils literal"><span class="pre">Twine</span></tt> class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-debug-macro-and-debug-option" id="id15">The <tt class="docutils literal"><span class="pre">DEBUG()</span></tt> macro and <tt class="docutils literal"><span class="pre">-debug</span></tt> option</a><ul>
<li><a class="reference internal" href="#fine-grained-debug-info-with-debug-type-and-the-debug-only-option" id="id16">Fine grained debug info with <tt class="docutils literal"><span class="pre">DEBUG_TYPE</span></tt> and the <tt class="docutils literal"><span class="pre">-debug-only</span></tt> option</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-statistic-class-stats-option" id="id17">The <tt class="docutils literal"><span class="pre">Statistic</span></tt> class &amp; <tt class="docutils literal"><span class="pre">-stats</span></tt> option</a></li>
<li><a class="reference internal" href="#viewing-graphs-while-debugging-code" id="id18">Viewing graphs while debugging code</a></li>
</ul>
</li>
<li><a class="reference internal" href="#picking-the-right-data-structure-for-a-task" id="id19">Picking the Right Data Structure for a Task</a><ul>
<li><a class="reference internal" href="#sequential-containers-std-vector-std-list-etc" id="id20">Sequential Containers (std::vector, std::list, etc)</a><ul>
<li><a class="reference internal" href="#llvm-adt-arrayref-h" id="id21">llvm/ADT/ArrayRef.h</a></li>
<li><a class="reference internal" href="#fixed-size-arrays" id="id22">Fixed Size Arrays</a></li>
<li><a class="reference internal" href="#heap-allocated-arrays" id="id23">Heap Allocated Arrays</a></li>
<li><a class="reference internal" href="#llvm-adt-tinyptrvector-h" id="id24">llvm/ADT/TinyPtrVector.h</a></li>
<li><a class="reference internal" href="#llvm-adt-smallvector-h" id="id25">llvm/ADT/SmallVector.h</a></li>
<li><a class="reference internal" href="#vector" id="id26">&lt;vector&gt;</a></li>
<li><a class="reference internal" href="#deque" id="id27">&lt;deque&gt;</a></li>
<li><a class="reference internal" href="#list" id="id28">&lt;list&gt;</a></li>
<li><a class="reference internal" href="#llvm-adt-ilist-h" id="id29">llvm/ADT/ilist.h</a></li>
<li><a class="reference internal" href="#llvm-adt-packedvector-h" id="id30">llvm/ADT/PackedVector.h</a></li>
<li><a class="reference internal" href="#ilist-traits" id="id31">ilist_traits</a></li>
<li><a class="reference internal" href="#iplist" id="id32">iplist</a></li>
<li><a class="reference internal" href="#llvm-adt-ilist-node-h" id="id33">llvm/ADT/ilist_node.h</a></li>
<li><a class="reference internal" href="#sentinels" id="id34">Sentinels</a></li>
<li><a class="reference internal" href="#other-sequential-container-options" id="id35">Other Sequential Container options</a></li>
</ul>
</li>
<li><a class="reference internal" href="#string-like-containers" id="id36">String-like containers</a><ul>
<li><a class="reference internal" href="#llvm-adt-stringref-h" id="id37">llvm/ADT/StringRef.h</a></li>
<li><a class="reference internal" href="#llvm-adt-twine-h" id="id38">llvm/ADT/Twine.h</a></li>
<li><a class="reference internal" href="#llvm-adt-smallstring-h" id="id39">llvm/ADT/SmallString.h</a></li>
<li><a class="reference internal" href="#std-string" id="id40">std::string</a></li>
</ul>
</li>
<li><a class="reference internal" href="#set-like-containers-std-set-smallset-setvector-etc" id="id41">Set-Like Containers (std::set, SmallSet, SetVector, etc)</a><ul>
<li><a class="reference internal" href="#a-sorted-vector" id="id42">A sorted &#8216;vector&#8217;</a></li>
<li><a class="reference internal" href="#llvm-adt-smallset-h" id="id43">llvm/ADT/SmallSet.h</a></li>
<li><a class="reference internal" href="#llvm-adt-smallptrset-h" id="id44">llvm/ADT/SmallPtrSet.h</a></li>
<li><a class="reference internal" href="#llvm-adt-denseset-h" id="id45">llvm/ADT/DenseSet.h</a></li>
<li><a class="reference internal" href="#llvm-adt-sparseset-h" id="id46">llvm/ADT/SparseSet.h</a></li>
<li><a class="reference internal" href="#llvm-adt-sparsemultiset-h" id="id47">llvm/ADT/SparseMultiSet.h</a></li>
<li><a class="reference internal" href="#llvm-adt-foldingset-h" id="id48">llvm/ADT/FoldingSet.h</a></li>
<li><a class="reference internal" href="#set" id="id49">&lt;set&gt;</a></li>
<li><a class="reference internal" href="#llvm-adt-setvector-h" id="id50">llvm/ADT/SetVector.h</a></li>
<li><a class="reference internal" href="#llvm-adt-uniquevector-h" id="id51">llvm/ADT/UniqueVector.h</a></li>
<li><a class="reference internal" href="#llvm-adt-immutableset-h" id="id52">llvm/ADT/ImmutableSet.h</a></li>
<li><a class="reference internal" href="#other-set-like-container-options" id="id53">Other Set-Like Container Options</a></li>
</ul>
</li>
<li><a class="reference internal" href="#map-like-containers-std-map-densemap-etc" id="id54">Map-Like Containers (std::map, DenseMap, etc)</a><ul>
<li><a class="reference internal" href="#dss-sortedvectormap" id="id55">A sorted &#8216;vector&#8217;</a></li>
<li><a class="reference internal" href="#llvm-adt-stringmap-h" id="id56">llvm/ADT/StringMap.h</a></li>
<li><a class="reference internal" href="#llvm-adt-indexedmap-h" id="id57">llvm/ADT/IndexedMap.h</a></li>
<li><a class="reference internal" href="#llvm-adt-densemap-h" id="id58">llvm/ADT/DenseMap.h</a></li>
<li><a class="reference internal" href="#llvm-ir-valuemap-h" id="id59">llvm/IR/ValueMap.h</a></li>
<li><a class="reference internal" href="#llvm-adt-intervalmap-h" id="id60">llvm/ADT/IntervalMap.h</a></li>
<li><a class="reference internal" href="#map" id="id61">&lt;map&gt;</a></li>
<li><a class="reference internal" href="#llvm-adt-mapvector-h" id="id62">llvm/ADT/MapVector.h</a></li>
<li><a class="reference internal" href="#llvm-adt-inteqclasses-h" id="id63">llvm/ADT/IntEqClasses.h</a></li>
<li><a class="reference internal" href="#llvm-adt-immutablemap-h" id="id64">llvm/ADT/ImmutableMap.h</a></li>
<li><a class="reference internal" href="#other-map-like-container-options" id="id65">Other Map-Like Container Options</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bit-storage-containers-bitvector-sparsebitvector" id="id66">Bit storage containers (BitVector, SparseBitVector)</a><ul>
<li><a class="reference internal" href="#bitvector" id="id67">BitVector</a></li>
<li><a class="reference internal" href="#smallbitvector" id="id68">SmallBitVector</a></li>
<li><a class="reference internal" href="#sparsebitvector" id="id69">SparseBitVector</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#helpful-hints-for-common-operations" id="id70">Helpful Hints for Common Operations</a><ul>
<li><a class="reference internal" href="#basic-inspection-and-traversal-routines" id="id71">Basic Inspection and Traversal Routines</a><ul>
<li><a class="reference internal" href="#iterating-over-the-basicblock-in-a-function" id="id72">Iterating over the <tt class="docutils literal"><span class="pre">BasicBlock</span></tt> in a <tt class="docutils literal"><span class="pre">Function</span></tt></a></li>
<li><a class="reference internal" href="#iterating-over-the-instruction-in-a-basicblock" id="id73">Iterating over the <tt class="docutils literal"><span class="pre">Instruction</span></tt> in a <tt class="docutils literal"><span class="pre">BasicBlock</span></tt></a></li>
<li><a class="reference internal" href="#iterating-over-the-instruction-in-a-function" id="id74">Iterating over the <tt class="docutils literal"><span class="pre">Instruction</span></tt> in a <tt class="docutils literal"><span class="pre">Function</span></tt></a></li>
<li><a class="reference internal" href="#turning-an-iterator-into-a-class-pointer-and-vice-versa" id="id75">Turning an iterator into a class pointer (and vice-versa)</a></li>
<li><a class="reference internal" href="#finding-call-sites-a-slightly-more-complex-example" id="id76">Finding call sites: a slightly more complex example</a></li>
<li><a class="reference internal" href="#treating-calls-and-invokes-the-same-way" id="id77">Treating calls and invokes the same way</a></li>
<li><a class="reference internal" href="#iterating-over-def-use-use-def-chains" id="id78">Iterating over def-use &amp; use-def chains</a></li>
<li><a class="reference internal" href="#iterating-over-predecessors-successors-of-blocks" id="id79">Iterating over predecessors &amp; successors of blocks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#making-simple-changes" id="id80">Making simple changes</a><ul>
<li><a class="reference internal" href="#creating-and-inserting-new-instructions" id="id81">Creating and inserting new <tt class="docutils literal"><span class="pre">Instruction</span></tt>s</a></li>
<li><a class="reference internal" href="#deleting-instructions" id="id82">Deleting Instructions</a></li>
<li><a class="reference internal" href="#replacing-an-instruction-with-another-value" id="id83">Replacing an Instruction with another Value</a><ul>
<li><a class="reference internal" href="#replacing-individual-instructions" id="id84">Replacing individual instructions</a></li>
<li><a class="reference internal" href="#schanges-deleting-sub" id="id85">Deleting Instructions</a></li>
<li><a class="reference internal" href="#replacing-multiple-uses-of-users-and-values" id="id86">Replacing multiple uses of Users and Values</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deleting-globalvariables" id="id87">Deleting GlobalVariables</a></li>
</ul>
</li>
<li><a class="reference internal" href="#how-to-create-types" id="id88">How to Create Types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#threads-and-llvm" id="id89">Threads and LLVM</a><ul>
<li><a class="reference internal" href="#entering-and-exiting-multithreaded-mode" id="id90">Entering and Exiting Multithreaded Mode</a></li>
<li><a class="reference internal" href="#ending-execution-with-llvm-shutdown" id="id91">Ending Execution with <tt class="docutils literal"><span class="pre">llvm_shutdown()</span></tt></a></li>
<li><a class="reference internal" href="#lazy-initialization-with-managedstatic" id="id92">Lazy Initialization with <tt class="docutils literal"><span class="pre">ManagedStatic</span></tt></a></li>
<li><a class="reference internal" href="#achieving-isolation-with-llvmcontext" id="id93">Achieving Isolation with <tt class="docutils literal"><span class="pre">LLVMContext</span></tt></a></li>
<li><a class="reference internal" href="#threads-and-the-jit" id="id94">Threads and the JIT</a></li>
</ul>
</li>
<li><a class="reference internal" href="#advanced-topics" id="id95">Advanced Topics</a><ul>
<li><a class="reference internal" href="#the-valuesymboltable-class" id="id96">The <tt class="docutils literal"><span class="pre">ValueSymbolTable</span></tt> class</a></li>
<li><a class="reference internal" href="#the-user-and-owned-use-classes-memory-layout" id="id97">The <tt class="docutils literal"><span class="pre">User</span></tt> and owned <tt class="docutils literal"><span class="pre">Use</span></tt> classes&#8217; memory layout</a><ul>
<li><a class="reference internal" href="#interaction-and-relationship-between-user-and-use-objects" id="id98">Interaction and relationship between <tt class="docutils literal"><span class="pre">User</span></tt> and <tt class="docutils literal"><span class="pre">Use</span></tt> objects</a></li>
<li><a class="reference internal" href="#the-waymarking-algorithm" id="id99">The waymarking algorithm</a></li>
<li><a class="reference internal" href="#reference-implementation" id="id100">Reference implementation</a></li>
<li><a class="reference internal" href="#tagging-considerations" id="id101">Tagging considerations</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#the-core-llvm-class-hierarchy-reference" id="id102">The Core LLVM Class Hierarchy Reference</a><ul>
<li><a class="reference internal" href="#the-type-class-and-derived-types" id="id103">The Type class and Derived Types</a><ul>
<li><a class="reference internal" href="#important-public-methods" id="id104">Important Public Methods</a></li>
<li><a class="reference internal" href="#important-derived-types" id="id105">Important Derived Types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-module-class" id="id106">The <tt class="docutils literal"><span class="pre">Module</span></tt> class</a><ul>
<li><a class="reference internal" href="#important-public-members-of-the-module-class" id="id107">Important Public Members of the <tt class="docutils literal"><span class="pre">Module</span></tt> class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-value-class" id="id108">The <tt class="docutils literal"><span class="pre">Value</span></tt> class</a><ul>
<li><a class="reference internal" href="#important-public-members-of-the-value-class" id="id109">Important Public Members of the <tt class="docutils literal"><span class="pre">Value</span></tt> class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-user-class" id="id110">The <tt class="docutils literal"><span class="pre">User</span></tt> class</a><ul>
<li><a class="reference internal" href="#important-public-members-of-the-user-class" id="id111">Important Public Members of the <tt class="docutils literal"><span class="pre">User</span></tt> class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-instruction-class" id="id112">The <tt class="docutils literal"><span class="pre">Instruction</span></tt> class</a><ul>
<li><a class="reference internal" href="#important-subclasses-of-the-instruction-class" id="id113">Important Subclasses of the <tt class="docutils literal"><span class="pre">Instruction</span></tt> class</a></li>
<li><a class="reference internal" href="#important-public-members-of-the-instruction-class" id="id114">Important Public Members of the <tt class="docutils literal"><span class="pre">Instruction</span></tt> class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-constant-class-and-subclasses" id="id115">The <tt class="docutils literal"><span class="pre">Constant</span></tt> class and subclasses</a><ul>
<li><a class="reference internal" href="#important-subclasses-of-constant" id="id116">Important Subclasses of Constant</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-globalvalue-class" id="id117">The <tt class="docutils literal"><span class="pre">GlobalValue</span></tt> class</a><ul>
<li><a class="reference internal" href="#important-public-members-of-the-globalvalue-class" id="id118">Important Public Members of the <tt class="docutils literal"><span class="pre">GlobalValue</span></tt> class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-function-class" id="id119">The <tt class="docutils literal"><span class="pre">Function</span></tt> class</a><ul>
<li><a class="reference internal" href="#important-public-members-of-the-function" id="id120">Important Public Members of the <tt class="docutils literal"><span class="pre">Function</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-globalvariable-class" id="id121">The <tt class="docutils literal"><span class="pre">GlobalVariable</span></tt> class</a><ul>
<li><a class="reference internal" href="#important-public-members-of-the-globalvariable-class" id="id122">Important Public Members of the <tt class="docutils literal"><span class="pre">GlobalVariable</span></tt> class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-basicblock-class" id="id123">The <tt class="docutils literal"><span class="pre">BasicBlock</span></tt> class</a><ul>
<li><a class="reference internal" href="#important-public-members-of-the-basicblock-class" id="id124">Important Public Members of the <tt class="docutils literal"><span class="pre">BasicBlock</span></tt> class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-argument-class" id="id125">The <tt class="docutils literal"><span class="pre">Argument</span></tt> class</a></li>
</ul>
</li>
</ul>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is always a work in progress.</p>
</div>
<div class="section" id="introduction">
<span id="id1"></span><h2><a class="toc-backref" href="#id6">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document is meant to highlight some of the important classes and interfaces
available in the LLVM source-base.  This manual is not intended to explain what
LLVM is, how it works, and what LLVM code looks like.  It assumes that you know
the basics of LLVM and are interested in writing transformations or otherwise
analyzing or manipulating the code.</p>
<p>This document should get you oriented so that you can find your way in the
continuously growing source code that makes up the LLVM infrastructure.  Note
that this manual is not intended to serve as a replacement for reading the
source code, so if you think there should be a method in one of these classes to
do something, but it&#8217;s not listed, check the source.  Links to the <a class="reference external" href="http://llvm.org/doxygen/">doxygen</a> sources are provided to make this as easy as
possible.</p>
<p>The first section of this document describes general information that is useful
to know when working in the LLVM infrastructure, and the second describes the
Core LLVM classes.  In the future this manual will be extended with information
describing how to use extension libraries, such as dominator information, CFG
traversal routines, and useful utilities like the <tt class="docutils literal"><span class="pre">InstVisitor</span></tt> (<a class="reference external" href="http://llvm.org/doxygen/InstVisitor_8h-source.html">doxygen</a>) template.</p>
</div>
<div class="section" id="general-information">
<span id="general"></span><h2><a class="toc-backref" href="#id7">General Information</a><a class="headerlink" href="#general-information" title="Permalink to this headline">¶</a></h2>
<p>This section contains general information that is useful if you are working in
the LLVM source-base, but that isn&#8217;t specific to any particular API.</p>
<div class="section" id="the-c-standard-template-library">
<span id="stl"></span><h3><a class="toc-backref" href="#id8">The C++ Standard Template Library</a><a class="headerlink" href="#the-c-standard-template-library" title="Permalink to this headline">¶</a></h3>
<p>LLVM makes heavy use of the C++ Standard Template Library (STL), perhaps much
more than you are used to, or have seen before.  Because of this, you might want
to do a little background reading in the techniques used and capabilities of the
library.  There are many good pages that discuss the STL, and several books on
the subject that you can get, so it will not be discussed in this document.</p>
<p>Here are some useful links:</p>
<ol class="arabic simple">
<li><a class="reference external" href="http://en.cppreference.com/w/">cppreference.com</a> - an excellent
reference for the STL and other parts of the standard C++ library.</li>
<li><a class="reference external" href="http://www.tempest-sw.com/cpp/">C++ In a Nutshell</a> - This is an O&#8217;Reilly
book in the making.  It has a decent Standard Library Reference that rivals
Dinkumware&#8217;s, and is unfortunately no longer free since the book has been
published.</li>
<li><a class="reference external" href="http://www.parashift.com/c++-faq-lite/">C++ Frequently Asked Questions</a>.</li>
<li><a class="reference external" href="http://www.sgi.com/tech/stl/">SGI&#8217;s STL Programmer&#8217;s Guide</a> - Contains a
useful <a class="reference external" href="http://www.sgi.com/tech/stl/stl_introduction.html">Introduction to the STL</a>.</li>
<li><a class="reference external" href="http://www.research.att.com/~bs/C++.html">Bjarne Stroustrup&#8217;s C++ Page</a>.</li>
<li><a class="reference external" href="http://www.mindview.net/Books/TICPP/ThinkingInCPP2e.html">Bruce Eckel&#8217;s Thinking in C++, 2nd ed. Volume 2 Revision 4.0
(even better, get the book)</a>.</li>
</ol>
<p>You are also encouraged to take a look at the <a class="reference internal" href="CodingStandards.html"><em>LLVM Coding Standards</em></a> guide which focuses on how to write maintainable code more
than where to put your curly braces.</p>
</div>
<div class="section" id="other-useful-references">
<span id="resources"></span><h3><a class="toc-backref" href="#id9">Other useful references</a><a class="headerlink" href="#other-useful-references" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><a class="reference external" href="http://www.fortran-2000.com/ArnaudRecipes/sharedlib.html">Using static and shared libraries across platforms</a></li>
</ol>
</div>
</div>
<div class="section" id="important-and-useful-llvm-apis">
<span id="apis"></span><h2><a class="toc-backref" href="#id10">Important and useful LLVM APIs</a><a class="headerlink" href="#important-and-useful-llvm-apis" title="Permalink to this headline">¶</a></h2>
<p>Here we highlight some LLVM APIs that are generally useful and good to know
about when writing transformations.</p>
<div class="section" id="the-isa-cast-and-dyn-cast-templates">
<span id="isa"></span><h3><a class="toc-backref" href="#id11">The <tt class="docutils literal"><span class="pre">isa&lt;&gt;</span></tt>, <tt class="docutils literal"><span class="pre">cast&lt;&gt;</span></tt> and <tt class="docutils literal"><span class="pre">dyn_cast&lt;&gt;</span></tt> templates</a><a class="headerlink" href="#the-isa-cast-and-dyn-cast-templates" title="Permalink to this headline">¶</a></h3>
<p>The LLVM source-base makes extensive use of a custom form of RTTI.  These
templates have many similarities to the C++ <tt class="docutils literal"><span class="pre">dynamic_cast&lt;&gt;</span></tt> operator, but
they don&#8217;t have some drawbacks (primarily stemming from the fact that
<tt class="docutils literal"><span class="pre">dynamic_cast&lt;&gt;</span></tt> only works on classes that have a v-table).  Because they are
used so often, you must know what they do and how they work.  All of these
templates are defined in the <tt class="docutils literal"><span class="pre">llvm/Support/Casting.h</span></tt> (<a class="reference external" href="http://llvm.org/doxygen/Casting_8h-source.html">doxygen</a>) file (note that you very
rarely have to include this file directly).</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">isa&lt;&gt;</span></tt>:</dt>
<dd>The <tt class="docutils literal"><span class="pre">isa&lt;&gt;</span></tt> operator works exactly like the Java &#8220;<tt class="docutils literal"><span class="pre">instanceof</span></tt>&#8221; operator.
It returns true or false depending on whether a reference or pointer points to
an instance of the specified class.  This can be very useful for constraint
checking of various sorts (example below).</dd>
<dt><tt class="docutils literal"><span class="pre">cast&lt;&gt;</span></tt>:</dt>
<dd><p class="first">The <tt class="docutils literal"><span class="pre">cast&lt;&gt;</span></tt> operator is a &#8220;checked cast&#8221; operation.  It converts a pointer
or reference from a base class to a derived class, causing an assertion
failure if it is not really an instance of the right type.  This should be
used in cases where you have some information that makes you believe that
something is of the right type.  An example of the <tt class="docutils literal"><span class="pre">isa&lt;&gt;</span></tt> and <tt class="docutils literal"><span class="pre">cast&lt;&gt;</span></tt>
template is:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="kt">bool</span> <span class="nf">isLoopInvariant</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">Loop</span> <span class="o">*</span><span class="n">L</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">Constant</span><span class="o">&gt;</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">||</span> <span class="n">isa</span><span class="o">&lt;</span><span class="n">Argument</span><span class="o">&gt;</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">||</span> <span class="n">isa</span><span class="o">&lt;</span><span class="n">GlobalValue</span><span class="o">&gt;</span><span class="p">(</span><span class="n">V</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

  <span class="c1">// Otherwise, it must be an instruction...</span>
  <span class="k">return</span> <span class="o">!</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">contains</span><span class="p">(</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">Instruction</span><span class="o">&gt;</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="last">Note that you should <strong>not</strong> use an <tt class="docutils literal"><span class="pre">isa&lt;&gt;</span></tt> test followed by a <tt class="docutils literal"><span class="pre">cast&lt;&gt;</span></tt>,
for that use the <tt class="docutils literal"><span class="pre">dyn_cast&lt;&gt;</span></tt> operator.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">dyn_cast&lt;&gt;</span></tt>:</dt>
<dd><p class="first">The <tt class="docutils literal"><span class="pre">dyn_cast&lt;&gt;</span></tt> operator is a &#8220;checking cast&#8221; operation.  It checks to see
if the operand is of the specified type, and if so, returns a pointer to it
(this operator does not work with references).  If the operand is not of the
correct type, a null pointer is returned.  Thus, this works very much like
the <tt class="docutils literal"><span class="pre">dynamic_cast&lt;&gt;</span></tt> operator in C++, and should be used in the same
circumstances.  Typically, the <tt class="docutils literal"><span class="pre">dyn_cast&lt;&gt;</span></tt> operator is used in an <tt class="docutils literal"><span class="pre">if</span></tt>
statement or some other flow control statement like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">AllocationInst</span> <span class="o">*</span><span class="n">AI</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">AllocationInst</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Val</span><span class="p">))</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This form of the <tt class="docutils literal"><span class="pre">if</span></tt> statement effectively combines together a call to
<tt class="docutils literal"><span class="pre">isa&lt;&gt;</span></tt> and a call to <tt class="docutils literal"><span class="pre">cast&lt;&gt;</span></tt> into one statement, which is very
convenient.</p>
<p class="last">Note that the <tt class="docutils literal"><span class="pre">dyn_cast&lt;&gt;</span></tt> operator, like C++&#8217;s <tt class="docutils literal"><span class="pre">dynamic_cast&lt;&gt;</span></tt> or Java&#8217;s
<tt class="docutils literal"><span class="pre">instanceof</span></tt> operator, can be abused.  In particular, you should not use big
chained <tt class="docutils literal"><span class="pre">if/then/else</span></tt> blocks to check for lots of different variants of
classes.  If you find yourself wanting to do this, it is much cleaner and more
efficient to use the <tt class="docutils literal"><span class="pre">InstVisitor</span></tt> class to dispatch over the instruction
type directly.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">cast_or_null&lt;&gt;</span></tt>:</dt>
<dd>The <tt class="docutils literal"><span class="pre">cast_or_null&lt;&gt;</span></tt> operator works just like the <tt class="docutils literal"><span class="pre">cast&lt;&gt;</span></tt> operator,
except that it allows for a null pointer as an argument (which it then
propagates).  This can sometimes be useful, allowing you to combine several
null checks into one.</dd>
<dt><tt class="docutils literal"><span class="pre">dyn_cast_or_null&lt;&gt;</span></tt>:</dt>
<dd>The <tt class="docutils literal"><span class="pre">dyn_cast_or_null&lt;&gt;</span></tt> operator works just like the <tt class="docutils literal"><span class="pre">dyn_cast&lt;&gt;</span></tt>
operator, except that it allows for a null pointer as an argument (which it
then propagates).  This can sometimes be useful, allowing you to combine
several null checks into one.</dd>
</dl>
<p>These five templates can be used with any classes, whether they have a v-table
or not.  If you want to add support for these templates, see the document
<a class="reference internal" href="HowToSetUpLLVMStyleRTTI.html"><em>How to set up LLVM-style RTTI for your class hierarchy</em></a></p>
</div>
<div class="section" id="passing-strings-the-stringref-and-twine-classes">
<span id="string-apis"></span><h3><a class="toc-backref" href="#id12">Passing strings (the <tt class="docutils literal"><span class="pre">StringRef</span></tt> and <tt class="docutils literal"><span class="pre">Twine</span></tt> classes)</a><a class="headerlink" href="#passing-strings-the-stringref-and-twine-classes" title="Permalink to this headline">¶</a></h3>
<p>Although LLVM generally does not do much string manipulation, we do have several
important APIs which take strings.  Two important examples are the Value class
&#8211; which has names for instructions, functions, etc. &#8211; and the <tt class="docutils literal"><span class="pre">StringMap</span></tt>
class which is used extensively in LLVM and Clang.</p>
<p>These are generic classes, and they need to be able to accept strings which may
have embedded null characters.  Therefore, they cannot simply take a <tt class="docutils literal"><span class="pre">const</span>
<span class="pre">char</span> <span class="pre">*</span></tt>, and taking a <tt class="docutils literal"><span class="pre">const</span> <span class="pre">std::string&amp;</span></tt> requires clients to perform a heap
allocation which is usually unnecessary.  Instead, many LLVM APIs use a
<tt class="docutils literal"><span class="pre">StringRef</span></tt> or a <tt class="docutils literal"><span class="pre">const</span> <span class="pre">Twine&amp;</span></tt> for passing strings efficiently.</p>
<div class="section" id="the-stringref-class">
<span id="stringref"></span><h4><a class="toc-backref" href="#id13">The <tt class="docutils literal"><span class="pre">StringRef</span></tt> class</a><a class="headerlink" href="#the-stringref-class" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="docutils literal"><span class="pre">StringRef</span></tt> data type represents a reference to a constant string (a
character array and a length) and supports the common operations available on
<tt class="docutils literal"><span class="pre">std::string</span></tt>, but does not require heap allocation.</p>
<p>It can be implicitly constructed using a C style null-terminated string, an
<tt class="docutils literal"><span class="pre">std::string</span></tt>, or explicitly with a character pointer and length.  For
example, the <tt class="docutils literal"><span class="pre">StringRef</span></tt> find function is declared as:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">iterator</span> <span class="nf">find</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Key</span><span class="p">);</span>
</pre></div>
</div>
<p>and clients can call it using any one of:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Map</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">);</span>                 <span class="c1">// Lookup &quot;foo&quot;</span>
<span class="n">Map</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">));</span>    <span class="c1">// Lookup &quot;bar&quot;</span>
<span class="n">Map</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\0</span><span class="s">baz&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">));</span> <span class="c1">// Lookup &quot;\0baz&quot;</span>
</pre></div>
</div>
<p>Similarly, APIs which need to return a string may return a <tt class="docutils literal"><span class="pre">StringRef</span></tt>
instance, which can be used directly or converted to an <tt class="docutils literal"><span class="pre">std::string</span></tt> using
the <tt class="docutils literal"><span class="pre">str</span></tt> member function.  See <tt class="docutils literal"><span class="pre">llvm/ADT/StringRef.h</span></tt> (<a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1StringRef_8h-source.html">doxygen</a>) for more
information.</p>
<p>You should rarely use the <tt class="docutils literal"><span class="pre">StringRef</span></tt> class directly, because it contains
pointers to external memory it is not generally safe to store an instance of the
class (unless you know that the external storage will not be freed).
<tt class="docutils literal"><span class="pre">StringRef</span></tt> is small and pervasive enough in LLVM that it should always be
passed by value.</p>
</div>
<div class="section" id="the-twine-class">
<h4><a class="toc-backref" href="#id14">The <tt class="docutils literal"><span class="pre">Twine</span></tt> class</a><a class="headerlink" href="#the-twine-class" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="docutils literal"><span class="pre">Twine</span></tt> (<a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Twine.html">doxygen</a>)
class is an efficient way for APIs to accept concatenated strings.  For example,
a common LLVM paradigm is to name one instruction based on the name of another
instruction with a suffix, for example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">New</span> <span class="o">=</span> <span class="n">CmpInst</span><span class="o">::</span><span class="n">Create</span><span class="p">(...,</span> <span class="n">SO</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot;.cmp&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">Twine</span></tt> class is effectively a lightweight <a class="reference external" href="http://en.wikipedia.org/wiki/Rope_(computer_science)">rope</a> which points to
temporary (stack allocated) objects.  Twines can be implicitly constructed as
the result of the plus operator applied to strings (i.e., a C strings, an
<tt class="docutils literal"><span class="pre">std::string</span></tt>, or a <tt class="docutils literal"><span class="pre">StringRef</span></tt>).  The twine delays the actual concatenation
of strings until it is actually required, at which point it can be efficiently
rendered directly into a character array.  This avoids unnecessary heap
allocation involved in constructing the temporary results of string
concatenation.  See <tt class="docutils literal"><span class="pre">llvm/ADT/Twine.h</span></tt> (<a class="reference external" href="http://llvm.org/doxygen/Twine_8h_source.html">doxygen</a>) and <a class="reference internal" href="#dss-twine"><em>here</em></a>
for more information.</p>
<p>As with a <tt class="docutils literal"><span class="pre">StringRef</span></tt>, <tt class="docutils literal"><span class="pre">Twine</span></tt> objects point to external memory and should
almost never be stored or mentioned directly.  They are intended solely for use
when defining a function which should be able to efficiently accept concatenated
strings.</p>
</div>
</div>
<div class="section" id="the-debug-macro-and-debug-option">
<span id="debug"></span><h3><a class="toc-backref" href="#id15">The <tt class="docutils literal"><span class="pre">DEBUG()</span></tt> macro and <tt class="docutils literal"><span class="pre">-debug</span></tt> option</a><a class="headerlink" href="#the-debug-macro-and-debug-option" title="Permalink to this headline">¶</a></h3>
<p>Often when working on your pass you will put a bunch of debugging printouts and
other code into your pass.  After you get it working, you want to remove it, but
you may need it again in the future (to work out new bugs that you run across).</p>
<p>Naturally, because of this, you don&#8217;t want to delete the debug printouts, but
you don&#8217;t want them to always be noisy.  A standard compromise is to comment
them out, allowing you to enable them if you need them in the future.</p>
<p>The <tt class="docutils literal"><span class="pre">llvm/Support/Debug.h</span></tt> (<a class="reference external" href="http://llvm.org/doxygen/Debug_8h-source.html">doxygen</a>) file provides a macro named
<tt class="docutils literal"><span class="pre">DEBUG()</span></tt> that is a much nicer solution to this problem.  Basically, you can
put arbitrary code into the argument of the <tt class="docutils literal"><span class="pre">DEBUG</span></tt> macro, and it is only
executed if &#8216;<tt class="docutils literal"><span class="pre">opt</span></tt>&#8216; (or any other tool) is run with the &#8216;<tt class="docutils literal"><span class="pre">-debug</span></tt>&#8216; command
line argument:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;I am here!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Then you can run your pass like this:</p>
<div class="highlight-none"><div class="highlight"><pre>$ opt &lt; a.bc &gt; /dev/null -mypass
&lt;no output&gt;
$ opt &lt; a.bc &gt; /dev/null -mypass -debug
I am here!
</pre></div>
</div>
<p>Using the <tt class="docutils literal"><span class="pre">DEBUG()</span></tt> macro instead of a home-brewed solution allows you to not
have to create &#8220;yet another&#8221; command line option for the debug output for your
pass.  Note that <tt class="docutils literal"><span class="pre">DEBUG()</span></tt> macros are disabled for optimized builds, so they
do not cause a performance impact at all (for the same reason, they should also
not contain side-effects!).</p>
<p>One additional nice thing about the <tt class="docutils literal"><span class="pre">DEBUG()</span></tt> macro is that you can enable or
disable it directly in gdb.  Just use &#8220;<tt class="docutils literal"><span class="pre">set</span> <span class="pre">DebugFlag=0</span></tt>&#8221; or &#8220;<tt class="docutils literal"><span class="pre">set</span>
<span class="pre">DebugFlag=1</span></tt>&#8221; from the gdb if the program is running.  If the program hasn&#8217;t
been started yet, you can always just run it with <tt class="docutils literal"><span class="pre">-debug</span></tt>.</p>
<div class="section" id="fine-grained-debug-info-with-debug-type-and-the-debug-only-option">
<span id="debug-type"></span><h4><a class="toc-backref" href="#id16">Fine grained debug info with <tt class="docutils literal"><span class="pre">DEBUG_TYPE</span></tt> and the <tt class="docutils literal"><span class="pre">-debug-only</span></tt> option</a><a class="headerlink" href="#fine-grained-debug-info-with-debug-type-and-the-debug-only-option" title="Permalink to this headline">¶</a></h4>
<p>Sometimes you may find yourself in a situation where enabling <tt class="docutils literal"><span class="pre">-debug</span></tt> just
turns on <strong>too much</strong> information (such as when working on the code generator).
If you want to enable debug information with more fine-grained control, you
define the <tt class="docutils literal"><span class="pre">DEBUG_TYPE</span></tt> macro and the <tt class="docutils literal"><span class="pre">-debug</span></tt> only option as follows:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#undef  DEBUG_TYPE</span>
<span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;No debug type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#define DEBUG_TYPE &quot;foo&quot;</span>
<span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;foo&#39; debug type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#undef  DEBUG_TYPE</span>
<span class="cp">#define DEBUG_TYPE &quot;bar&quot;</span>
<span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;bar&#39; debug type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
<span class="cp">#undef  DEBUG_TYPE</span>
<span class="cp">#define DEBUG_TYPE &quot;&quot;</span>
<span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;No debug type (2)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Then you can run your pass like this:</p>
<div class="highlight-none"><div class="highlight"><pre>$ opt &lt; a.bc &gt; /dev/null -mypass
&lt;no output&gt;
$ opt &lt; a.bc &gt; /dev/null -mypass -debug
No debug type
&#39;foo&#39; debug type
&#39;bar&#39; debug type
No debug type (2)
$ opt &lt; a.bc &gt; /dev/null -mypass -debug-only=foo
&#39;foo&#39; debug type
$ opt &lt; a.bc &gt; /dev/null -mypass -debug-only=bar
&#39;bar&#39; debug type
</pre></div>
</div>
<p>Of course, in practice, you should only set <tt class="docutils literal"><span class="pre">DEBUG_TYPE</span></tt> at the top of a file,
to specify the debug type for the entire module (if you do this before you
<tt class="docutils literal"><span class="pre">#include</span> <span class="pre">&quot;llvm/Support/Debug.h&quot;</span></tt>, you don&#8217;t have to insert the ugly
<tt class="docutils literal"><span class="pre">#undef</span></tt>&#8216;s).  Also, you should use names more meaningful than &#8220;foo&#8221; and &#8220;bar&#8221;,
because there is no system in place to ensure that names do not conflict.  If
two different modules use the same string, they will all be turned on when the
name is specified.  This allows, for example, all debug information for
instruction scheduling to be enabled with <tt class="docutils literal"><span class="pre">-debug-type=InstrSched</span></tt>, even if
the source lives in multiple files.</p>
<p>The <tt class="docutils literal"><span class="pre">DEBUG_WITH_TYPE</span></tt> macro is also available for situations where you would
like to set <tt class="docutils literal"><span class="pre">DEBUG_TYPE</span></tt>, but only for one specific <tt class="docutils literal"><span class="pre">DEBUG</span></tt> statement.  It
takes an additional first parameter, which is the type to use.  For example, the
preceding example could be written as:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DEBUG_WITH_TYPE</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;No debug type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">DEBUG_WITH_TYPE</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;foo&#39; debug type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">DEBUG_WITH_TYPE</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">,</span> <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;bar&#39; debug type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
<span class="n">DEBUG_WITH_TYPE</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;No debug type (2)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="the-statistic-class-stats-option">
<span id="statistic"></span><h3><a class="toc-backref" href="#id17">The <tt class="docutils literal"><span class="pre">Statistic</span></tt> class &amp; <tt class="docutils literal"><span class="pre">-stats</span></tt> option</a><a class="headerlink" href="#the-statistic-class-stats-option" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">llvm/ADT/Statistic.h</span></tt> (<a class="reference external" href="http://llvm.org/doxygen/Statistic_8h-source.html">doxygen</a>) file provides a class
named <tt class="docutils literal"><span class="pre">Statistic</span></tt> that is used as a unified way to keep track of what the LLVM
compiler is doing and how effective various optimizations are.  It is useful to
see what optimizations are contributing to making a particular program run
faster.</p>
<p>Often you may run your pass on some big program, and you&#8217;re interested to see
how many times it makes a certain transformation.  Although you can do this with
hand inspection, or some ad-hoc method, this is a real pain and not very useful
for big programs.  Using the <tt class="docutils literal"><span class="pre">Statistic</span></tt> class makes it very easy to keep
track of this information, and the calculated information is presented in a
uniform manner with the rest of the passes being executed.</p>
<p>There are many examples of <tt class="docutils literal"><span class="pre">Statistic</span></tt> uses, but the basics of using it are as
follows:</p>
<ol class="arabic simple">
<li>Define your statistic like this:</li>
</ol>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="cp">#define DEBUG_TYPE &quot;mypassname&quot;   </span><span class="c1">// This goes before any #includes.</span>
<span class="n">STATISTIC</span><span class="p">(</span><span class="n">NumXForms</span><span class="p">,</span> <span class="s">&quot;The # of times I did stuff&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">STATISTIC</span></tt> macro defines a static variable, whose name is specified by
the first argument.  The pass name is taken from the <tt class="docutils literal"><span class="pre">DEBUG_TYPE</span></tt> macro, and
the description is taken from the second argument.  The variable defined
(&#8220;NumXForms&#8221; in this case) acts like an unsigned integer.</p>
</div></blockquote>
<ol class="arabic simple">
<li>Whenever you make a transformation, bump the counter:</li>
</ol>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="o">++</span><span class="n">NumXForms</span><span class="p">;</span>   <span class="c1">// I did stuff!</span>
</pre></div>
</div>
</div></blockquote>
<p>That&#8217;s all you have to do.  To get &#8216;<tt class="docutils literal"><span class="pre">opt</span></tt>&#8216; to print out the statistics
gathered, use the &#8216;<tt class="docutils literal"><span class="pre">-stats</span></tt>&#8216; option:</p>
<div class="highlight-none"><div class="highlight"><pre>$ opt -stats -mypassname &lt; program.bc &gt; /dev/null
... statistics output ...
</pre></div>
</div>
<p>When running <tt class="docutils literal"><span class="pre">opt</span></tt> on a C file from the SPEC benchmark suite, it gives a
report that looks like this:</p>
<div class="highlight-none"><div class="highlight"><pre>  7646 bitcodewriter   - Number of normal instructions
   725 bitcodewriter   - Number of oversized instructions
129996 bitcodewriter   - Number of bitcode bytes written
  2817 raise           - Number of insts DCEd or constprop&#39;d
  3213 raise           - Number of cast-of-self removed
  5046 raise           - Number of expression trees converted
    75 raise           - Number of other getelementptr&#39;s formed
   138 raise           - Number of load/store peepholes
    42 deadtypeelim    - Number of unused typenames removed from symtab
   392 funcresolve     - Number of varargs functions resolved
    27 globaldce       - Number of global variables removed
     2 adce            - Number of basic blocks removed
   134 cee             - Number of branches revectored
    49 cee             - Number of setcc instruction eliminated
   532 gcse            - Number of loads removed
  2919 gcse            - Number of instructions removed
    86 indvars         - Number of canonical indvars added
    87 indvars         - Number of aux indvars removed
    25 instcombine     - Number of dead inst eliminate
   434 instcombine     - Number of insts combined
   248 licm            - Number of load insts hoisted
  1298 licm            - Number of insts hoisted to a loop pre-header
     3 licm            - Number of insts hoisted to multiple loop preds (bad, no loop pre-header)
    75 mem2reg         - Number of alloca&#39;s promoted
  1444 cfgsimplify     - Number of blocks simplified
</pre></div>
</div>
<p>Obviously, with so many optimizations, having a unified framework for this stuff
is very nice.  Making your pass fit well into the framework makes it more
maintainable and useful.</p>
</div>
<div class="section" id="viewing-graphs-while-debugging-code">
<span id="viewgraph"></span><h3><a class="toc-backref" href="#id18">Viewing graphs while debugging code</a><a class="headerlink" href="#viewing-graphs-while-debugging-code" title="Permalink to this headline">¶</a></h3>
<p>Several of the important data structures in LLVM are graphs: for example CFGs
made out of LLVM <a class="reference internal" href="#basicblock"><em>BasicBlocks</em></a>, CFGs made out of LLVM
<a class="reference internal" href="CodeGenerator.html#machinebasicblock"><em>MachineBasicBlocks</em></a>, and <a class="reference internal" href="CodeGenerator.html#selectiondag"><em>Instruction Selection
DAGs</em></a>.  In many cases, while debugging various parts of the
compiler, it is nice to instantly visualize these graphs.</p>
<p>LLVM provides several callbacks that are available in a debug build to do
exactly that.  If you call the <tt class="docutils literal"><span class="pre">Function::viewCFG()</span></tt> method, for example, the
current LLVM tool will pop up a window containing the CFG for the function where
each basic block is a node in the graph, and each node contains the instructions
in the block.  Similarly, there also exists <tt class="docutils literal"><span class="pre">Function::viewCFGOnly()</span></tt> (does
not include the instructions), the <tt class="docutils literal"><span class="pre">MachineFunction::viewCFG()</span></tt> and
<tt class="docutils literal"><span class="pre">MachineFunction::viewCFGOnly()</span></tt>, and the <tt class="docutils literal"><span class="pre">SelectionDAG::viewGraph()</span></tt>
methods.  Within GDB, for example, you can usually use something like <tt class="docutils literal"><span class="pre">call</span>
<span class="pre">DAG.viewGraph()</span></tt> to pop up a window.  Alternatively, you can sprinkle calls to
these functions in your code in places you want to debug.</p>
<p>Getting this to work requires a small amount of configuration.  On Unix systems
with X11, install the <a class="reference external" href="http://www.graphviz.org/">graphviz</a> toolkit, and make
sure &#8216;dot&#8217; and &#8216;gv&#8217; are in your path.  If you are running on Mac OS X, download
and install the Mac OS X <a class="reference external" href="http://www.pixelglow.com/graphviz/">Graphviz program</a> and add
<tt class="docutils literal"><span class="pre">/Applications/Graphviz.app/Contents/MacOS/</span></tt> (or wherever you install it) to
your path.  Once in your system and path are set up, rerun the LLVM configure
script and rebuild LLVM to enable this functionality.</p>
<p><tt class="docutils literal"><span class="pre">SelectionDAG</span></tt> has been extended to make it easier to locate <em>interesting</em>
nodes in large complex graphs.  From gdb, if you <tt class="docutils literal"><span class="pre">call</span> <span class="pre">DAG.setGraphColor(node,</span>
<span class="pre">&quot;color&quot;)</span></tt>, then the next <tt class="docutils literal"><span class="pre">call</span> <span class="pre">DAG.viewGraph()</span></tt> would highlight the node in
the specified color (choices of colors can be found at <a class="reference external" href="http://www.graphviz.org/doc/info/colors.html">colors</a>.) More complex node attributes
can be provided with <tt class="docutils literal"><span class="pre">call</span> <span class="pre">DAG.setGraphAttrs(node,</span> <span class="pre">&quot;attributes&quot;)</span></tt> (choices can
be found at <a class="reference external" href="http://www.graphviz.org/doc/info/attrs.html">Graph attributes</a>.)
If you want to restart and clear all the current graph attributes, then you can
<tt class="docutils literal"><span class="pre">call</span> <span class="pre">DAG.clearGraphAttrs()</span></tt>.</p>
<p>Note that graph visualization features are compiled out of Release builds to
reduce file size.  This means that you need a Debug+Asserts or Release+Asserts
build to use these features.</p>
</div>
</div>
<div class="section" id="picking-the-right-data-structure-for-a-task">
<span id="datastructure"></span><h2><a class="toc-backref" href="#id19">Picking the Right Data Structure for a Task</a><a class="headerlink" href="#picking-the-right-data-structure-for-a-task" title="Permalink to this headline">¶</a></h2>
<p>LLVM has a plethora of data structures in the <tt class="docutils literal"><span class="pre">llvm/ADT/</span></tt> directory, and we
commonly use STL data structures.  This section describes the trade-offs you
should consider when you pick one.</p>
<p>The first step is a choose your own adventure: do you want a sequential
container, a set-like container, or a map-like container?  The most important
thing when choosing a container is the algorithmic properties of how you plan to
access the container.  Based on that, you should use:</p>
<ul class="simple">
<li>a <a class="reference internal" href="#ds-map"><em>map-like</em></a> container if you need efficient look-up of a
value based on another value.  Map-like containers also support efficient
queries for containment (whether a key is in the map).  Map-like containers
generally do not support efficient reverse mapping (values to keys).  If you
need that, use two maps.  Some map-like containers also support efficient
iteration through the keys in sorted order.  Map-like containers are the most
expensive sort, only use them if you need one of these capabilities.</li>
<li>a <a class="reference internal" href="#ds-set"><em>set-like</em></a> container if you need to put a bunch of stuff into
a container that automatically eliminates duplicates.  Some set-like
containers support efficient iteration through the elements in sorted order.
Set-like containers are more expensive than sequential containers.</li>
<li>a <a class="reference internal" href="#ds-sequential"><em>sequential</em></a> container provides the most efficient way
to add elements and keeps track of the order they are added to the collection.
They permit duplicates and support efficient iteration, but do not support
efficient look-up based on a key.</li>
<li>a <a class="reference internal" href="#ds-string"><em>string</em></a> container is a specialized sequential container or
reference structure that is used for character or byte arrays.</li>
<li>a <a class="reference internal" href="#ds-bit"><em>bit</em></a> container provides an efficient way to store and
perform set operations on sets of numeric id&#8217;s, while automatically
eliminating duplicates.  Bit containers require a maximum of 1 bit for each
identifier you want to store.</li>
</ul>
<p>Once the proper category of container is determined, you can fine tune the
memory use, constant factors, and cache behaviors of access by intelligently
picking a member of the category.  Note that constant factors and cache behavior
can be a big deal.  If you have a vector that usually only contains a few
elements (but could contain many), for example, it&#8217;s much better to use
<a class="reference internal" href="#dss-smallvector"><em>SmallVector</em></a> than <a class="reference internal" href="#dss-vector"><em>vector</em></a>.  Doing so
avoids (relatively) expensive malloc/free calls, which dwarf the cost of adding
the elements to the container.</p>
<div class="section" id="sequential-containers-std-vector-std-list-etc">
<span id="ds-sequential"></span><h3><a class="toc-backref" href="#id20">Sequential Containers (std::vector, std::list, etc)</a><a class="headerlink" href="#sequential-containers-std-vector-std-list-etc" title="Permalink to this headline">¶</a></h3>
<p>There are a variety of sequential containers available for you, based on your
needs.  Pick the first in this section that will do what you want.</p>
<div class="section" id="llvm-adt-arrayref-h">
<span id="dss-arrayref"></span><h4><a class="toc-backref" href="#id21">llvm/ADT/ArrayRef.h</a><a class="headerlink" href="#llvm-adt-arrayref-h" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="docutils literal"><span class="pre">llvm::ArrayRef</span></tt> class is the preferred class to use in an interface that
accepts a sequential list of elements in memory and just reads from them.  By
taking an <tt class="docutils literal"><span class="pre">ArrayRef</span></tt>, the API can be passed a fixed size array, an
<tt class="docutils literal"><span class="pre">std::vector</span></tt>, an <tt class="docutils literal"><span class="pre">llvm::SmallVector</span></tt> and anything else that is contiguous
in memory.</p>
</div>
<div class="section" id="fixed-size-arrays">
<span id="dss-fixedarrays"></span><h4><a class="toc-backref" href="#id22">Fixed Size Arrays</a><a class="headerlink" href="#fixed-size-arrays" title="Permalink to this headline">¶</a></h4>
<p>Fixed size arrays are very simple and very fast.  They are good if you know
exactly how many elements you have, or you have a (low) upper bound on how many
you have.</p>
</div>
<div class="section" id="heap-allocated-arrays">
<span id="dss-heaparrays"></span><h4><a class="toc-backref" href="#id23">Heap Allocated Arrays</a><a class="headerlink" href="#heap-allocated-arrays" title="Permalink to this headline">¶</a></h4>
<p>Heap allocated arrays (<tt class="docutils literal"><span class="pre">new[]</span></tt> + <tt class="docutils literal"><span class="pre">delete[]</span></tt>) are also simple.  They are good
if the number of elements is variable, if you know how many elements you will
need before the array is allocated, and if the array is usually large (if not,
consider a <a class="reference internal" href="#dss-smallvector"><em>SmallVector</em></a>).  The cost of a heap allocated
array is the cost of the new/delete (aka malloc/free).  Also note that if you
are allocating an array of a type with a constructor, the constructor and
destructors will be run for every element in the array (re-sizable vectors only
construct those elements actually used).</p>
</div>
<div class="section" id="llvm-adt-tinyptrvector-h">
<span id="dss-tinyptrvector"></span><h4><a class="toc-backref" href="#id24">llvm/ADT/TinyPtrVector.h</a><a class="headerlink" href="#llvm-adt-tinyptrvector-h" title="Permalink to this headline">¶</a></h4>
<p><tt class="docutils literal"><span class="pre">TinyPtrVector&lt;Type&gt;</span></tt> is a highly specialized collection class that is
optimized to avoid allocation in the case when a vector has zero or one
elements.  It has two major restrictions: 1) it can only hold values of pointer
type, and 2) it cannot hold a null pointer.</p>
<p>Since this container is highly specialized, it is rarely used.</p>
</div>
<div class="section" id="llvm-adt-smallvector-h">
<span id="dss-smallvector"></span><h4><a class="toc-backref" href="#id25">llvm/ADT/SmallVector.h</a><a class="headerlink" href="#llvm-adt-smallvector-h" title="Permalink to this headline">¶</a></h4>
<p><tt class="docutils literal"><span class="pre">SmallVector&lt;Type,</span> <span class="pre">N&gt;</span></tt> is a simple class that looks and smells just like
<tt class="docutils literal"><span class="pre">vector&lt;Type&gt;</span></tt>: it supports efficient iteration, lays out elements in memory
order (so you can do pointer arithmetic between elements), supports efficient
push_back/pop_back operations, supports efficient random access to its elements,
etc.</p>
<p>The advantage of SmallVector is that it allocates space for some number of
elements (N) <strong>in the object itself</strong>.  Because of this, if the SmallVector is
dynamically smaller than N, no malloc is performed.  This can be a big win in
cases where the malloc/free call is far more expensive than the code that
fiddles around with the elements.</p>
<p>This is good for vectors that are &#8220;usually small&#8221; (e.g. the number of
predecessors/successors of a block is usually less than 8).  On the other hand,
this makes the size of the SmallVector itself large, so you don&#8217;t want to
allocate lots of them (doing so will waste a lot of space).  As such,
SmallVectors are most useful when on the stack.</p>
<p>SmallVector also provides a nice portable and efficient replacement for
<tt class="docutils literal"><span class="pre">alloca</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Prefer to use <tt class="docutils literal"><span class="pre">SmallVectorImpl&lt;T&gt;</span></tt> as a parameter type.</p>
<p>In APIs that don&#8217;t care about the &#8220;small size&#8221; (most?), prefer to use
the <tt class="docutils literal"><span class="pre">SmallVectorImpl&lt;T&gt;</span></tt> class, which is basically just the &#8220;vector
header&#8221; (and methods) without the elements allocated after it. Note that
<tt class="docutils literal"><span class="pre">SmallVector&lt;T,</span> <span class="pre">N&gt;</span></tt> inherits from <tt class="docutils literal"><span class="pre">SmallVectorImpl&lt;T&gt;</span></tt> so the
conversion is implicit and costs nothing. E.g.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// BAD: Clients cannot pass e.g. SmallVector&lt;Foo, 4&gt;.</span>
<span class="n">hardcodedSmallSize</span><span class="p">(</span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Out</span><span class="p">);</span>
<span class="c1">// GOOD: Clients can pass any SmallVector&lt;Foo, N&gt;.</span>
<span class="n">allowsAnySmallSize</span><span class="p">(</span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Out</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">someFunc</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">Vec</span><span class="p">;</span>
  <span class="n">hardcodedSmallSize</span><span class="p">(</span><span class="n">Vec</span><span class="p">);</span> <span class="c1">// Error.</span>
  <span class="n">allowsAnySmallSize</span><span class="p">(</span><span class="n">Vec</span><span class="p">);</span> <span class="c1">// Works.</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="last">Even though it has &#8220;<tt class="docutils literal"><span class="pre">Impl</span></tt>&#8221; in the name, this is so widely used that
it really isn&#8217;t &#8220;private to the implementation&#8221; anymore. A name like
<tt class="docutils literal"><span class="pre">SmallVectorHeader</span></tt> would be more appropriate.</p>
</div>
</div>
<div class="section" id="vector">
<span id="dss-vector"></span><h4><a class="toc-backref" href="#id26">&lt;vector&gt;</a><a class="headerlink" href="#vector" title="Permalink to this headline">¶</a></h4>
<p><tt class="docutils literal"><span class="pre">std::vector</span></tt> is well loved and respected.  It is useful when SmallVector
isn&#8217;t: when the size of the vector is often large (thus the small optimization
will rarely be a benefit) or if you will be allocating many instances of the
vector itself (which would waste space for elements that aren&#8217;t in the
container).  vector is also useful when interfacing with code that expects
vectors :).</p>
<p>One worthwhile note about std::vector: avoid code like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">for</span> <span class="p">(</span> <span class="p">...</span> <span class="p">)</span> <span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span> <span class="n">V</span><span class="p">;</span>
   <span class="c1">// make use of V.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Instead, write this as:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span> <span class="n">V</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span> <span class="p">...</span> <span class="p">)</span> <span class="p">{</span>
   <span class="c1">// make use of V.</span>
   <span class="n">V</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Doing so will save (at least) one heap allocation and free per iteration of the
loop.</p>
</div>
<div class="section" id="deque">
<span id="dss-deque"></span><h4><a class="toc-backref" href="#id27">&lt;deque&gt;</a><a class="headerlink" href="#deque" title="Permalink to this headline">¶</a></h4>
<p><tt class="docutils literal"><span class="pre">std::deque</span></tt> is, in some senses, a generalized version of <tt class="docutils literal"><span class="pre">std::vector</span></tt>.
Like <tt class="docutils literal"><span class="pre">std::vector</span></tt>, it provides constant time random access and other similar
properties, but it also provides efficient access to the front of the list.  It
does not guarantee continuity of elements within memory.</p>
<p>In exchange for this extra flexibility, <tt class="docutils literal"><span class="pre">std::deque</span></tt> has significantly higher
constant factor costs than <tt class="docutils literal"><span class="pre">std::vector</span></tt>.  If possible, use <tt class="docutils literal"><span class="pre">std::vector</span></tt> or
something cheaper.</p>
</div>
<div class="section" id="list">
<span id="dss-list"></span><h4><a class="toc-backref" href="#id28">&lt;list&gt;</a><a class="headerlink" href="#list" title="Permalink to this headline">¶</a></h4>
<p><tt class="docutils literal"><span class="pre">std::list</span></tt> is an extremely inefficient class that is rarely useful.  It
performs a heap allocation for every element inserted into it, thus having an
extremely high constant factor, particularly for small data types.
<tt class="docutils literal"><span class="pre">std::list</span></tt> also only supports bidirectional iteration, not random access
iteration.</p>
<p>In exchange for this high cost, std::list supports efficient access to both ends
of the list (like <tt class="docutils literal"><span class="pre">std::deque</span></tt>, but unlike <tt class="docutils literal"><span class="pre">std::vector</span></tt> or
<tt class="docutils literal"><span class="pre">SmallVector</span></tt>).  In addition, the iterator invalidation characteristics of
std::list are stronger than that of a vector class: inserting or removing an
element into the list does not invalidate iterator or pointers to other elements
in the list.</p>
</div>
<div class="section" id="llvm-adt-ilist-h">
<span id="dss-ilist"></span><h4><a class="toc-backref" href="#id29">llvm/ADT/ilist.h</a><a class="headerlink" href="#llvm-adt-ilist-h" title="Permalink to this headline">¶</a></h4>
<p><tt class="docutils literal"><span class="pre">ilist&lt;T&gt;</span></tt> implements an &#8216;intrusive&#8217; doubly-linked list.  It is intrusive,
because it requires the element to store and provide access to the prev/next
pointers for the list.</p>
<p><tt class="docutils literal"><span class="pre">ilist</span></tt> has the same drawbacks as <tt class="docutils literal"><span class="pre">std::list</span></tt>, and additionally requires an
<tt class="docutils literal"><span class="pre">ilist_traits</span></tt> implementation for the element type, but it provides some novel
characteristics.  In particular, it can efficiently store polymorphic objects,
the traits class is informed when an element is inserted or removed from the
list, and <tt class="docutils literal"><span class="pre">ilist</span></tt>s are guaranteed to support a constant-time splice
operation.</p>
<p>These properties are exactly what we want for things like <tt class="docutils literal"><span class="pre">Instruction</span></tt>s and
basic blocks, which is why these are implemented with <tt class="docutils literal"><span class="pre">ilist</span></tt>s.</p>
<p>Related classes of interest are explained in the following subsections:</p>
<ul class="simple">
<li><a class="reference internal" href="#dss-ilist-traits"><em>ilist_traits</em></a></li>
<li><a class="reference internal" href="#dss-iplist"><em>iplist</em></a></li>
<li><a class="reference internal" href="#dss-ilist-node"><em>llvm/ADT/ilist_node.h</em></a></li>
<li><a class="reference internal" href="#dss-ilist-sentinel"><em>Sentinels</em></a></li>
</ul>
</div>
<div class="section" id="llvm-adt-packedvector-h">
<span id="dss-packedvector"></span><h4><a class="toc-backref" href="#id30">llvm/ADT/PackedVector.h</a><a class="headerlink" href="#llvm-adt-packedvector-h" title="Permalink to this headline">¶</a></h4>
<p>Useful for storing a vector of values using only a few number of bits for each
value.  Apart from the standard operations of a vector-like container, it can
also perform an &#8216;or&#8217; set operation.</p>
<p>For example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">enum</span> <span class="n">State</span> <span class="p">{</span>
    <span class="n">None</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
    <span class="n">FirstCondition</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
    <span class="n">SecondCondition</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
    <span class="n">Both</span> <span class="o">=</span> <span class="mh">0x3</span>
<span class="p">};</span>

<span class="n">State</span> <span class="nf">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">PackedVector</span><span class="o">&lt;</span><span class="n">State</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Vec1</span><span class="p">;</span>
    <span class="n">Vec1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">FirstCondition</span><span class="p">);</span>

    <span class="n">PackedVector</span><span class="o">&lt;</span><span class="n">State</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Vec2</span><span class="p">;</span>
    <span class="n">Vec2</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">SecondCondition</span><span class="p">);</span>

    <span class="n">Vec1</span> <span class="o">|=</span> <span class="n">Vec2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Vec1</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// returns &#39;Both&#39;.</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="ilist-traits">
<span id="dss-ilist-traits"></span><h4><a class="toc-backref" href="#id31">ilist_traits</a><a class="headerlink" href="#ilist-traits" title="Permalink to this headline">¶</a></h4>
<p><tt class="docutils literal"><span class="pre">ilist_traits&lt;T&gt;</span></tt> is <tt class="docutils literal"><span class="pre">ilist&lt;T&gt;</span></tt>&#8216;s customization mechanism. <tt class="docutils literal"><span class="pre">iplist&lt;T&gt;</span></tt>
(and consequently <tt class="docutils literal"><span class="pre">ilist&lt;T&gt;</span></tt>) publicly derive from this traits class.</p>
</div>
<div class="section" id="iplist">
<span id="dss-iplist"></span><h4><a class="toc-backref" href="#id32">iplist</a><a class="headerlink" href="#iplist" title="Permalink to this headline">¶</a></h4>
<p><tt class="docutils literal"><span class="pre">iplist&lt;T&gt;</span></tt> is <tt class="docutils literal"><span class="pre">ilist&lt;T&gt;</span></tt>&#8216;s base and as such supports a slightly narrower
interface.  Notably, inserters from <tt class="docutils literal"><span class="pre">T&amp;</span></tt> are absent.</p>
<p><tt class="docutils literal"><span class="pre">ilist_traits&lt;T&gt;</span></tt> is a public base of this class and can be used for a wide
variety of customizations.</p>
</div>
<div class="section" id="llvm-adt-ilist-node-h">
<span id="dss-ilist-node"></span><h4><a class="toc-backref" href="#id33">llvm/ADT/ilist_node.h</a><a class="headerlink" href="#llvm-adt-ilist-node-h" title="Permalink to this headline">¶</a></h4>
<p><tt class="docutils literal"><span class="pre">ilist_node&lt;T&gt;</span></tt> implements a the forward and backward links that are expected
by the <tt class="docutils literal"><span class="pre">ilist&lt;T&gt;</span></tt> (and analogous containers) in the default manner.</p>
<p><tt class="docutils literal"><span class="pre">ilist_node&lt;T&gt;</span></tt>s are meant to be embedded in the node type <tt class="docutils literal"><span class="pre">T</span></tt>, usually
<tt class="docutils literal"><span class="pre">T</span></tt> publicly derives from <tt class="docutils literal"><span class="pre">ilist_node&lt;T&gt;</span></tt>.</p>
</div>
<div class="section" id="sentinels">
<span id="dss-ilist-sentinel"></span><h4><a class="toc-backref" href="#id34">Sentinels</a><a class="headerlink" href="#sentinels" title="Permalink to this headline">¶</a></h4>
<p><tt class="docutils literal"><span class="pre">ilist</span></tt>s have another specialty that must be considered.  To be a good
citizen in the C++ ecosystem, it needs to support the standard container
operations, such as <tt class="docutils literal"><span class="pre">begin</span></tt> and <tt class="docutils literal"><span class="pre">end</span></tt> iterators, etc.  Also, the
<tt class="docutils literal"><span class="pre">operator--</span></tt> must work correctly on the <tt class="docutils literal"><span class="pre">end</span></tt> iterator in the case of
non-empty <tt class="docutils literal"><span class="pre">ilist</span></tt>s.</p>
<p>The only sensible solution to this problem is to allocate a so-called <em>sentinel</em>
along with the intrusive list, which serves as the <tt class="docutils literal"><span class="pre">end</span></tt> iterator, providing
the back-link to the last element.  However conforming to the C++ convention it
is illegal to <tt class="docutils literal"><span class="pre">operator++</span></tt> beyond the sentinel and it also must not be
dereferenced.</p>
<p>These constraints allow for some implementation freedom to the <tt class="docutils literal"><span class="pre">ilist</span></tt> how to
allocate and store the sentinel.  The corresponding policy is dictated by
<tt class="docutils literal"><span class="pre">ilist_traits&lt;T&gt;</span></tt>.  By default a <tt class="docutils literal"><span class="pre">T</span></tt> gets heap-allocated whenever the need
for a sentinel arises.</p>
<p>While the default policy is sufficient in most cases, it may break down when
<tt class="docutils literal"><span class="pre">T</span></tt> does not provide a default constructor.  Also, in the case of many
instances of <tt class="docutils literal"><span class="pre">ilist</span></tt>s, the memory overhead of the associated sentinels is
wasted.  To alleviate the situation with numerous and voluminous
<tt class="docutils literal"><span class="pre">T</span></tt>-sentinels, sometimes a trick is employed, leading to <em>ghostly sentinels</em>.</p>
<p>Ghostly sentinels are obtained by specially-crafted <tt class="docutils literal"><span class="pre">ilist_traits&lt;T&gt;</span></tt> which
superpose the sentinel with the <tt class="docutils literal"><span class="pre">ilist</span></tt> instance in memory.  Pointer
arithmetic is used to obtain the sentinel, which is relative to the <tt class="docutils literal"><span class="pre">ilist</span></tt>&#8216;s
<tt class="docutils literal"><span class="pre">this</span></tt> pointer.  The <tt class="docutils literal"><span class="pre">ilist</span></tt> is augmented by an extra pointer, which serves
as the back-link of the sentinel.  This is the only field in the ghostly
sentinel which can be legally accessed.</p>
</div>
<div class="section" id="other-sequential-container-options">
<span id="dss-other"></span><h4><a class="toc-backref" href="#id35">Other Sequential Container options</a><a class="headerlink" href="#other-sequential-container-options" title="Permalink to this headline">¶</a></h4>
<p>Other STL containers are available, such as <tt class="docutils literal"><span class="pre">std::string</span></tt>.</p>
<p>There are also various STL adapter classes such as <tt class="docutils literal"><span class="pre">std::queue</span></tt>,
<tt class="docutils literal"><span class="pre">std::priority_queue</span></tt>, <tt class="docutils literal"><span class="pre">std::stack</span></tt>, etc.  These provide simplified access
to an underlying container but don&#8217;t affect the cost of the container itself.</p>
</div>
</div>
<div class="section" id="string-like-containers">
<span id="ds-string"></span><h3><a class="toc-backref" href="#id36">String-like containers</a><a class="headerlink" href="#string-like-containers" title="Permalink to this headline">¶</a></h3>
<p>There are a variety of ways to pass around and use strings in C and C++, and
LLVM adds a few new options to choose from.  Pick the first option on this list
that will do what you need, they are ordered according to their relative cost.</p>
<p>Note that is is generally preferred to <em>not</em> pass strings around as <tt class="docutils literal"><span class="pre">const</span>
<span class="pre">char*</span></tt>&#8216;s.  These have a number of problems, including the fact that they
cannot represent embedded nul (&#8220;0&#8221;) characters, and do not have a length
available efficiently.  The general replacement for &#8216;<tt class="docutils literal"><span class="pre">const</span> <span class="pre">char*</span></tt>&#8216; is
StringRef.</p>
<p>For more information on choosing string containers for APIs, please see
<a class="reference internal" href="#string-apis"><em>Passing Strings</em></a>.</p>
<div class="section" id="llvm-adt-stringref-h">
<span id="dss-stringref"></span><h4><a class="toc-backref" href="#id37">llvm/ADT/StringRef.h</a><a class="headerlink" href="#llvm-adt-stringref-h" title="Permalink to this headline">¶</a></h4>
<p>The StringRef class is a simple value class that contains a pointer to a
character and a length, and is quite related to the <a class="reference internal" href="#dss-arrayref"><em>ArrayRef</em></a> class (but specialized for arrays of characters).  Because
StringRef carries a length with it, it safely handles strings with embedded nul
characters in it, getting the length does not require a strlen call, and it even
has very convenient APIs for slicing and dicing the character range that it
represents.</p>
<p>StringRef is ideal for passing simple strings around that are known to be live,
either because they are C string literals, std::string, a C array, or a
SmallVector.  Each of these cases has an efficient implicit conversion to
StringRef, which doesn&#8217;t result in a dynamic strlen being executed.</p>
<p>StringRef has a few major limitations which make more powerful string containers
useful:</p>
<ol class="arabic simple">
<li>You cannot directly convert a StringRef to a &#8216;const char*&#8217; because there is
no way to add a trailing nul (unlike the .c_str() method on various stronger
classes).</li>
<li>StringRef doesn&#8217;t own or keep alive the underlying string bytes.
As such it can easily lead to dangling pointers, and is not suitable for
embedding in datastructures in most cases (instead, use an std::string or
something like that).</li>
<li>For the same reason, StringRef cannot be used as the return value of a
method if the method &#8220;computes&#8221; the result string.  Instead, use std::string.</li>
<li>StringRef&#8217;s do not allow you to mutate the pointed-to string bytes and it
doesn&#8217;t allow you to insert or remove bytes from the range.  For editing
operations like this, it interoperates with the <a class="reference internal" href="#dss-twine"><em>Twine</em></a>
class.</li>
</ol>
<p>Because of its strengths and limitations, it is very common for a function to
take a StringRef and for a method on an object to return a StringRef that points
into some string that it owns.</p>
</div>
<div class="section" id="llvm-adt-twine-h">
<span id="dss-twine"></span><h4><a class="toc-backref" href="#id38">llvm/ADT/Twine.h</a><a class="headerlink" href="#llvm-adt-twine-h" title="Permalink to this headline">¶</a></h4>
<p>The Twine class is used as an intermediary datatype for APIs that want to take a
string that can be constructed inline with a series of concatenations.  Twine
works by forming recursive instances of the Twine datatype (a simple value
object) on the stack as temporary objects, linking them together into a tree
which is then linearized when the Twine is consumed.  Twine is only safe to use
as the argument to a function, and should always be a const reference, e.g.:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">Twine</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">StringRef</span> <span class="n">X</span> <span class="o">=</span> <span class="p">...</span>
<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">foo</span><span class="p">(</span><span class="n">X</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span> <span class="o">+</span> <span class="n">Twine</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</pre></div>
</div>
<p>This example forms a string like &#8220;blarg.42&#8221; by concatenating the values
together, and does not form intermediate strings containing &#8220;blarg&#8221; or &#8220;blarg.&#8221;.</p>
<p>Because Twine is constructed with temporary objects on the stack, and because
these instances are destroyed at the end of the current statement, it is an
inherently dangerous API.  For example, this simple variant contains undefined
behavior and will probably crash:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">Twine</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">StringRef</span> <span class="n">X</span> <span class="o">=</span> <span class="p">...</span>
<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="p">...</span>
<span class="k">const</span> <span class="n">Twine</span> <span class="o">&amp;</span><span class="n">Tmp</span> <span class="o">=</span> <span class="n">X</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span> <span class="o">+</span> <span class="n">Twine</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="n">foo</span><span class="p">(</span><span class="n">Tmp</span><span class="p">);</span>
</pre></div>
</div>
<p>... because the temporaries are destroyed before the call.  That said, Twine&#8217;s
are much more efficient than intermediate std::string temporaries, and they work
really well with StringRef.  Just be aware of their limitations.</p>
</div>
<div class="section" id="llvm-adt-smallstring-h">
<span id="dss-smallstring"></span><h4><a class="toc-backref" href="#id39">llvm/ADT/SmallString.h</a><a class="headerlink" href="#llvm-adt-smallstring-h" title="Permalink to this headline">¶</a></h4>
<p>SmallString is a subclass of <a class="reference internal" href="#dss-smallvector"><em>SmallVector</em></a> that adds some
convenience APIs like += that takes StringRef&#8217;s.  SmallString avoids allocating
memory in the case when the preallocated space is enough to hold its data, and
it calls back to general heap allocation when required.  Since it owns its data,
it is very safe to use and supports full mutation of the string.</p>
<p>Like SmallVector&#8217;s, the big downside to SmallString is their sizeof.  While they
are optimized for small strings, they themselves are not particularly small.
This means that they work great for temporary scratch buffers on the stack, but
should not generally be put into the heap: it is very rare to see a SmallString
as the member of a frequently-allocated heap data structure or returned
by-value.</p>
</div>
<div class="section" id="std-string">
<span id="dss-stdstring"></span><h4><a class="toc-backref" href="#id40">std::string</a><a class="headerlink" href="#std-string" title="Permalink to this headline">¶</a></h4>
<p>The standard C++ std::string class is a very general class that (like
SmallString) owns its underlying data.  sizeof(std::string) is very reasonable
so it can be embedded into heap data structures and returned by-value.  On the
other hand, std::string is highly inefficient for inline editing (e.g.
concatenating a bunch of stuff together) and because it is provided by the
standard library, its performance characteristics depend a lot of the host
standard library (e.g. libc++ and MSVC provide a highly optimized string class,
GCC contains a really slow implementation).</p>
<p>The major disadvantage of std::string is that almost every operation that makes
them larger can allocate memory, which is slow.  As such, it is better to use
SmallVector or Twine as a scratch buffer, but then use std::string to persist
the result.</p>
</div>
</div>
<div class="section" id="set-like-containers-std-set-smallset-setvector-etc">
<span id="ds-set"></span><h3><a class="toc-backref" href="#id41">Set-Like Containers (std::set, SmallSet, SetVector, etc)</a><a class="headerlink" href="#set-like-containers-std-set-smallset-setvector-etc" title="Permalink to this headline">¶</a></h3>
<p>Set-like containers are useful when you need to canonicalize multiple values
into a single representation.  There are several different choices for how to do
this, providing various trade-offs.</p>
<div class="section" id="a-sorted-vector">
<span id="dss-sortedvectorset"></span><h4><a class="toc-backref" href="#id42">A sorted &#8216;vector&#8217;</a><a class="headerlink" href="#a-sorted-vector" title="Permalink to this headline">¶</a></h4>
<p>If you intend to insert a lot of elements, then do a lot of queries, a great
approach is to use a vector (or other sequential container) with
std::sort+std::unique to remove duplicates.  This approach works really well if
your usage pattern has these two distinct phases (insert then query), and can be
coupled with a good choice of <a class="reference internal" href="#ds-sequential"><em>sequential container</em></a>.</p>
<p>This combination provides the several nice properties: the result data is
contiguous in memory (good for cache locality), has few allocations, is easy to
address (iterators in the final vector are just indices or pointers), and can be
efficiently queried with a standard binary search (e.g.
<tt class="docutils literal"><span class="pre">std::lower_bound</span></tt>; if you want the whole range of elements comparing
equal, use <tt class="docutils literal"><span class="pre">std::equal_range</span></tt>).</p>
</div>
<div class="section" id="llvm-adt-smallset-h">
<span id="dss-smallset"></span><h4><a class="toc-backref" href="#id43">llvm/ADT/SmallSet.h</a><a class="headerlink" href="#llvm-adt-smallset-h" title="Permalink to this headline">¶</a></h4>
<p>If you have a set-like data structure that is usually small and whose elements
are reasonably small, a <tt class="docutils literal"><span class="pre">SmallSet&lt;Type,</span> <span class="pre">N&gt;</span></tt> is a good choice.  This set has
space for N elements in place (thus, if the set is dynamically smaller than N,
no malloc traffic is required) and accesses them with a simple linear search.
When the set grows beyond &#8216;N&#8217; elements, it allocates a more expensive
representation that guarantees efficient access (for most types, it falls back
to std::set, but for pointers it uses something far better, <a class="reference internal" href="#dss-smallptrset"><em>SmallPtrSet</em></a>.</p>
<p>The magic of this class is that it handles small sets extremely efficiently, but
gracefully handles extremely large sets without loss of efficiency.  The
drawback is that the interface is quite small: it supports insertion, queries
and erasing, but does not support iteration.</p>
</div>
<div class="section" id="llvm-adt-smallptrset-h">
<span id="dss-smallptrset"></span><h4><a class="toc-backref" href="#id44">llvm/ADT/SmallPtrSet.h</a><a class="headerlink" href="#llvm-adt-smallptrset-h" title="Permalink to this headline">¶</a></h4>
<p>SmallPtrSet has all the advantages of <tt class="docutils literal"><span class="pre">SmallSet</span></tt> (and a <tt class="docutils literal"><span class="pre">SmallSet</span></tt> of
pointers is transparently implemented with a <tt class="docutils literal"><span class="pre">SmallPtrSet</span></tt>), but also supports
iterators.  If more than &#8216;N&#8217; insertions are performed, a single quadratically
probed hash table is allocated and grows as needed, providing extremely
efficient access (constant time insertion/deleting/queries with low constant
factors) and is very stingy with malloc traffic.</p>
<p>Note that, unlike <tt class="docutils literal"><span class="pre">std::set</span></tt>, the iterators of <tt class="docutils literal"><span class="pre">SmallPtrSet</span></tt> are invalidated
whenever an insertion occurs.  Also, the values visited by the iterators are not
visited in sorted order.</p>
</div>
<div class="section" id="llvm-adt-denseset-h">
<span id="dss-denseset"></span><h4><a class="toc-backref" href="#id45">llvm/ADT/DenseSet.h</a><a class="headerlink" href="#llvm-adt-denseset-h" title="Permalink to this headline">¶</a></h4>
<p>DenseSet is a simple quadratically probed hash table.  It excels at supporting
small values: it uses a single allocation to hold all of the pairs that are
currently inserted in the set.  DenseSet is a great way to unique small values
that are not simple pointers (use <a class="reference internal" href="#dss-smallptrset"><em>SmallPtrSet</em></a> for
pointers).  Note that DenseSet has the same requirements for the value type that
<a class="reference internal" href="#dss-densemap"><em>DenseMap</em></a> has.</p>
</div>
<div class="section" id="llvm-adt-sparseset-h">
<span id="dss-sparseset"></span><h4><a class="toc-backref" href="#id46">llvm/ADT/SparseSet.h</a><a class="headerlink" href="#llvm-adt-sparseset-h" title="Permalink to this headline">¶</a></h4>
<p>SparseSet holds a small number of objects identified by unsigned keys of
moderate size.  It uses a lot of memory, but provides operations that are almost
as fast as a vector.  Typical keys are physical registers, virtual registers, or
numbered basic blocks.</p>
<p>SparseSet is useful for algorithms that need very fast clear/find/insert/erase
and fast iteration over small sets.  It is not intended for building composite
data structures.</p>
</div>
<div class="section" id="llvm-adt-sparsemultiset-h">
<span id="dss-sparsemultiset"></span><h4><a class="toc-backref" href="#id47">llvm/ADT/SparseMultiSet.h</a><a class="headerlink" href="#llvm-adt-sparsemultiset-h" title="Permalink to this headline">¶</a></h4>
<p>SparseMultiSet adds multiset behavior to SparseSet, while retaining SparseSet&#8217;s
desirable attributes. Like SparseSet, it typically uses a lot of memory, but
provides operations that are almost as fast as a vector.  Typical keys are
physical registers, virtual registers, or numbered basic blocks.</p>
<p>SparseMultiSet is useful for algorithms that need very fast
clear/find/insert/erase of the entire collection, and iteration over sets of
elements sharing a key. It is often a more efficient choice than using composite
data structures (e.g. vector-of-vectors, map-of-vectors). It is not intended for
building composite data structures.</p>
</div>
<div class="section" id="llvm-adt-foldingset-h">
<span id="dss-foldingset"></span><h4><a class="toc-backref" href="#id48">llvm/ADT/FoldingSet.h</a><a class="headerlink" href="#llvm-adt-foldingset-h" title="Permalink to this headline">¶</a></h4>
<p>FoldingSet is an aggregate class that is really good at uniquing
expensive-to-create or polymorphic objects.  It is a combination of a chained
hash table with intrusive links (uniqued objects are required to inherit from
FoldingSetNode) that uses <a class="reference internal" href="#dss-smallvector"><em>SmallVector</em></a> as part of its ID
process.</p>
<p>Consider a case where you want to implement a &#8220;getOrCreateFoo&#8221; method for a
complex object (for example, a node in the code generator).  The client has a
description of <strong>what</strong> it wants to generate (it knows the opcode and all the
operands), but we don&#8217;t want to &#8216;new&#8217; a node, then try inserting it into a set
only to find out it already exists, at which point we would have to delete it
and return the node that already exists.</p>
<p>To support this style of client, FoldingSet perform a query with a
FoldingSetNodeID (which wraps SmallVector) that can be used to describe the
element that we want to query for.  The query either returns the element
matching the ID or it returns an opaque ID that indicates where insertion should
take place.  Construction of the ID usually does not require heap traffic.</p>
<p>Because FoldingSet uses intrusive links, it can support polymorphic objects in
the set (for example, you can have SDNode instances mixed with LoadSDNodes).
Because the elements are individually allocated, pointers to the elements are
stable: inserting or removing elements does not invalidate any pointers to other
elements.</p>
</div>
<div class="section" id="set">
<span id="dss-set"></span><h4><a class="toc-backref" href="#id49">&lt;set&gt;</a><a class="headerlink" href="#set" title="Permalink to this headline">¶</a></h4>
<p><tt class="docutils literal"><span class="pre">std::set</span></tt> is a reasonable all-around set class, which is decent at many
things but great at nothing.  std::set allocates memory for each element
inserted (thus it is very malloc intensive) and typically stores three pointers
per element in the set (thus adding a large amount of per-element space
overhead).  It offers guaranteed log(n) performance, which is not particularly
fast from a complexity standpoint (particularly if the elements of the set are
expensive to compare, like strings), and has extremely high constant factors for
lookup, insertion and removal.</p>
<p>The advantages of std::set are that its iterators are stable (deleting or
inserting an element from the set does not affect iterators or pointers to other
elements) and that iteration over the set is guaranteed to be in sorted order.
If the elements in the set are large, then the relative overhead of the pointers
and malloc traffic is not a big deal, but if the elements of the set are small,
std::set is almost never a good choice.</p>
</div>
<div class="section" id="llvm-adt-setvector-h">
<span id="dss-setvector"></span><h4><a class="toc-backref" href="#id50">llvm/ADT/SetVector.h</a><a class="headerlink" href="#llvm-adt-setvector-h" title="Permalink to this headline">¶</a></h4>
<p>LLVM&#8217;s <tt class="docutils literal"><span class="pre">SetVector&lt;Type&gt;</span></tt> is an adapter class that combines your choice of a
set-like container along with a <a class="reference internal" href="#ds-sequential"><em>Sequential Container</em></a> The
important property that this provides is efficient insertion with uniquing
(duplicate elements are ignored) with iteration support.  It implements this by
inserting elements into both a set-like container and the sequential container,
using the set-like container for uniquing and the sequential container for
iteration.</p>
<p>The difference between SetVector and other sets is that the order of iteration
is guaranteed to match the order of insertion into the SetVector.  This property
is really important for things like sets of pointers.  Because pointer values
are non-deterministic (e.g. vary across runs of the program on different
machines), iterating over the pointers in the set will not be in a well-defined
order.</p>
<p>The drawback of SetVector is that it requires twice as much space as a normal
set and has the sum of constant factors from the set-like container and the
sequential container that it uses.  Use it <strong>only</strong> if you need to iterate over
the elements in a deterministic order.  SetVector is also expensive to delete
elements out of (linear time), unless you use its &#8220;pop_back&#8221; method, which is
faster.</p>
<p><tt class="docutils literal"><span class="pre">SetVector</span></tt> is an adapter class that defaults to using <tt class="docutils literal"><span class="pre">std::vector</span></tt> and a
size 16 <tt class="docutils literal"><span class="pre">SmallSet</span></tt> for the underlying containers, so it is quite expensive.
However, <tt class="docutils literal"><span class="pre">&quot;llvm/ADT/SetVector.h&quot;</span></tt> also provides a <tt class="docutils literal"><span class="pre">SmallSetVector</span></tt> class,
which defaults to using a <tt class="docutils literal"><span class="pre">SmallVector</span></tt> and <tt class="docutils literal"><span class="pre">SmallSet</span></tt> of a specified size.
If you use this, and if your sets are dynamically smaller than <tt class="docutils literal"><span class="pre">N</span></tt>, you will
save a lot of heap traffic.</p>
</div>
<div class="section" id="llvm-adt-uniquevector-h">
<span id="dss-uniquevector"></span><h4><a class="toc-backref" href="#id51">llvm/ADT/UniqueVector.h</a><a class="headerlink" href="#llvm-adt-uniquevector-h" title="Permalink to this headline">¶</a></h4>
<p>UniqueVector is similar to <a class="reference internal" href="#dss-setvector"><em>SetVector</em></a> but it retains a
unique ID for each element inserted into the set.  It internally contains a map
and a vector, and it assigns a unique ID for each value inserted into the set.</p>
<p>UniqueVector is very expensive: its cost is the sum of the cost of maintaining
both the map and vector, it has high complexity, high constant factors, and
produces a lot of malloc traffic.  It should be avoided.</p>
</div>
<div class="section" id="llvm-adt-immutableset-h">
<span id="dss-immutableset"></span><h4><a class="toc-backref" href="#id52">llvm/ADT/ImmutableSet.h</a><a class="headerlink" href="#llvm-adt-immutableset-h" title="Permalink to this headline">¶</a></h4>
<p>ImmutableSet is an immutable (functional) set implementation based on an AVL
tree.  Adding or removing elements is done through a Factory object and results
in the creation of a new ImmutableSet object.  If an ImmutableSet already exists
with the given contents, then the existing one is returned; equality is compared
with a FoldingSetNodeID.  The time and space complexity of add or remove
operations is logarithmic in the size of the original set.</p>
<p>There is no method for returning an element of the set, you can only check for
membership.</p>
</div>
<div class="section" id="other-set-like-container-options">
<span id="dss-otherset"></span><h4><a class="toc-backref" href="#id53">Other Set-Like Container Options</a><a class="headerlink" href="#other-set-like-container-options" title="Permalink to this headline">¶</a></h4>
<p>The STL provides several other options, such as std::multiset and the various
&#8220;hash_set&#8221; like containers (whether from C++ TR1 or from the SGI library).  We
never use hash_set and unordered_set because they are generally very expensive
(each insertion requires a malloc) and very non-portable.</p>
<p>std::multiset is useful if you&#8217;re not interested in elimination of duplicates,
but has all the drawbacks of std::set.  A sorted vector (where you don&#8217;t delete
duplicate entries) or some other approach is almost always better.</p>
</div>
</div>
<div class="section" id="map-like-containers-std-map-densemap-etc">
<span id="ds-map"></span><h3><a class="toc-backref" href="#id54">Map-Like Containers (std::map, DenseMap, etc)</a><a class="headerlink" href="#map-like-containers-std-map-densemap-etc" title="Permalink to this headline">¶</a></h3>
<p>Map-like containers are useful when you want to associate data to a key.  As
usual, there are a lot of different ways to do this. :)</p>
<div class="section" id="dss-sortedvectormap">
<span id="id2"></span><h4><a class="toc-backref" href="#id55">A sorted &#8216;vector&#8217;</a><a class="headerlink" href="#dss-sortedvectormap" title="Permalink to this headline">¶</a></h4>
<p>If your usage pattern follows a strict insert-then-query approach, you can
trivially use the same approach as <a class="reference internal" href="#dss-sortedvectorset"><em>sorted vectors for set-like containers</em></a>.  The only difference is that your query function (which
uses std::lower_bound to get efficient log(n) lookup) should only compare the
key, not both the key and value.  This yields the same advantages as sorted
vectors for sets.</p>
</div>
<div class="section" id="llvm-adt-stringmap-h">
<span id="dss-stringmap"></span><h4><a class="toc-backref" href="#id56">llvm/ADT/StringMap.h</a><a class="headerlink" href="#llvm-adt-stringmap-h" title="Permalink to this headline">¶</a></h4>
<p>Strings are commonly used as keys in maps, and they are difficult to support
efficiently: they are variable length, inefficient to hash and compare when
long, expensive to copy, etc.  StringMap is a specialized container designed to
cope with these issues.  It supports mapping an arbitrary range of bytes to an
arbitrary other object.</p>
<p>The StringMap implementation uses a quadratically-probed hash table, where the
buckets store a pointer to the heap allocated entries (and some other stuff).
The entries in the map must be heap allocated because the strings are variable
length.  The string data (key) and the element object (value) are stored in the
same allocation with the string data immediately after the element object.
This container guarantees the &#8220;<tt class="docutils literal"><span class="pre">(char*)(&amp;Value+1)</span></tt>&#8221; points to the key string
for a value.</p>
<p>The StringMap is very fast for several reasons: quadratic probing is very cache
efficient for lookups, the hash value of strings in buckets is not recomputed
when looking up an element, StringMap rarely has to touch the memory for
unrelated objects when looking up a value (even when hash collisions happen),
hash table growth does not recompute the hash values for strings already in the
table, and each pair in the map is store in a single allocation (the string data
is stored in the same allocation as the Value of a pair).</p>
<p>StringMap also provides query methods that take byte ranges, so it only ever
copies a string if a value is inserted into the table.</p>
<p>StringMap iteratation order, however, is not guaranteed to be deterministic, so
any uses which require that should instead use a std::map.</p>
</div>
<div class="section" id="llvm-adt-indexedmap-h">
<span id="dss-indexmap"></span><h4><a class="toc-backref" href="#id57">llvm/ADT/IndexedMap.h</a><a class="headerlink" href="#llvm-adt-indexedmap-h" title="Permalink to this headline">¶</a></h4>
<p>IndexedMap is a specialized container for mapping small dense integers (or
values that can be mapped to small dense integers) to some other type.  It is
internally implemented as a vector with a mapping function that maps the keys
to the dense integer range.</p>
<p>This is useful for cases like virtual registers in the LLVM code generator: they
have a dense mapping that is offset by a compile-time constant (the first
virtual register ID).</p>
</div>
<div class="section" id="llvm-adt-densemap-h">
<span id="dss-densemap"></span><h4><a class="toc-backref" href="#id58">llvm/ADT/DenseMap.h</a><a class="headerlink" href="#llvm-adt-densemap-h" title="Permalink to this headline">¶</a></h4>
<p>DenseMap is a simple quadratically probed hash table.  It excels at supporting
small keys and values: it uses a single allocation to hold all of the pairs
that are currently inserted in the map.  DenseMap is a great way to map
pointers to pointers, or map other small types to each other.</p>
<p>There are several aspects of DenseMap that you should be aware of, however.
The iterators in a DenseMap are invalidated whenever an insertion occurs,
unlike map.  Also, because DenseMap allocates space for a large number of
key/value pairs (it starts with 64 by default), it will waste a lot of space if
your keys or values are large.  Finally, you must implement a partial
specialization of DenseMapInfo for the key that you want, if it isn&#8217;t already
supported.  This is required to tell DenseMap about two special marker values
(which can never be inserted into the map) that it needs internally.</p>
<p>DenseMap&#8217;s find_as() method supports lookup operations using an alternate key
type.  This is useful in cases where the normal key type is expensive to
construct, but cheap to compare against.  The DenseMapInfo is responsible for
defining the appropriate comparison and hashing methods for each alternate key
type used.</p>
</div>
<div class="section" id="llvm-ir-valuemap-h">
<span id="dss-valuemap"></span><h4><a class="toc-backref" href="#id59">llvm/IR/ValueMap.h</a><a class="headerlink" href="#llvm-ir-valuemap-h" title="Permalink to this headline">¶</a></h4>
<p>ValueMap is a wrapper around a <a class="reference internal" href="#dss-densemap"><em>DenseMap</em></a> mapping
<tt class="docutils literal"><span class="pre">Value*</span></tt>s (or subclasses) to another type.  When a Value is deleted or
RAUW&#8217;ed, ValueMap will update itself so the new version of the key is mapped to
the same value, just as if the key were a WeakVH.  You can configure exactly how
this happens, and what else happens on these two events, by passing a <tt class="docutils literal"><span class="pre">Config</span></tt>
parameter to the ValueMap template.</p>
</div>
<div class="section" id="llvm-adt-intervalmap-h">
<span id="dss-intervalmap"></span><h4><a class="toc-backref" href="#id60">llvm/ADT/IntervalMap.h</a><a class="headerlink" href="#llvm-adt-intervalmap-h" title="Permalink to this headline">¶</a></h4>
<p>IntervalMap is a compact map for small keys and values.  It maps key intervals
instead of single keys, and it will automatically coalesce adjacent intervals.
When then map only contains a few intervals, they are stored in the map object
itself to avoid allocations.</p>
<p>The IntervalMap iterators are quite big, so they should not be passed around as
STL iterators.  The heavyweight iterators allow a smaller data structure.</p>
</div>
<div class="section" id="map">
<span id="dss-map"></span><h4><a class="toc-backref" href="#id61">&lt;map&gt;</a><a class="headerlink" href="#map" title="Permalink to this headline">¶</a></h4>
<p>std::map has similar characteristics to <a class="reference internal" href="#dss-set"><em>std::set</em></a>: it uses a
single allocation per pair inserted into the map, it offers log(n) lookup with
an extremely large constant factor, imposes a space penalty of 3 pointers per
pair in the map, etc.</p>
<p>std::map is most useful when your keys or values are very large, if you need to
iterate over the collection in sorted order, or if you need stable iterators
into the map (i.e. they don&#8217;t get invalidated if an insertion or deletion of
another element takes place).</p>
</div>
<div class="section" id="llvm-adt-mapvector-h">
<span id="dss-mapvector"></span><h4><a class="toc-backref" href="#id62">llvm/ADT/MapVector.h</a><a class="headerlink" href="#llvm-adt-mapvector-h" title="Permalink to this headline">¶</a></h4>
<p><tt class="docutils literal"><span class="pre">MapVector&lt;KeyT,ValueT&gt;</span></tt> provides a subset of the DenseMap interface.  The
main difference is that the iteration order is guaranteed to be the insertion
order, making it an easy (but somewhat expensive) solution for non-deterministic
iteration over maps of pointers.</p>
<p>It is implemented by mapping from key to an index in a vector of key,value
pairs.  This provides fast lookup and iteration, but has two main drawbacks: The
key is stored twice and it doesn&#8217;t support removing elements.</p>
</div>
<div class="section" id="llvm-adt-inteqclasses-h">
<span id="dss-inteqclasses"></span><h4><a class="toc-backref" href="#id63">llvm/ADT/IntEqClasses.h</a><a class="headerlink" href="#llvm-adt-inteqclasses-h" title="Permalink to this headline">¶</a></h4>
<p>IntEqClasses provides a compact representation of equivalence classes of small
integers.  Initially, each integer in the range 0..n-1 has its own equivalence
class.  Classes can be joined by passing two class representatives to the
join(a, b) method.  Two integers are in the same class when findLeader() returns
the same representative.</p>
<p>Once all equivalence classes are formed, the map can be compressed so each
integer 0..n-1 maps to an equivalence class number in the range 0..m-1, where m
is the total number of equivalence classes.  The map must be uncompressed before
it can be edited again.</p>
</div>
<div class="section" id="llvm-adt-immutablemap-h">
<span id="dss-immutablemap"></span><h4><a class="toc-backref" href="#id64">llvm/ADT/ImmutableMap.h</a><a class="headerlink" href="#llvm-adt-immutablemap-h" title="Permalink to this headline">¶</a></h4>
<p>ImmutableMap is an immutable (functional) map implementation based on an AVL
tree.  Adding or removing elements is done through a Factory object and results
in the creation of a new ImmutableMap object.  If an ImmutableMap already exists
with the given key set, then the existing one is returned; equality is compared
with a FoldingSetNodeID.  The time and space complexity of add or remove
operations is logarithmic in the size of the original map.</p>
</div>
<div class="section" id="other-map-like-container-options">
<span id="dss-othermap"></span><h4><a class="toc-backref" href="#id65">Other Map-Like Container Options</a><a class="headerlink" href="#other-map-like-container-options" title="Permalink to this headline">¶</a></h4>
<p>The STL provides several other options, such as std::multimap and the various
&#8220;hash_map&#8221; like containers (whether from C++ TR1 or from the SGI library).  We
never use hash_set and unordered_set because they are generally very expensive
(each insertion requires a malloc) and very non-portable.</p>
<p>std::multimap is useful if you want to map a key to multiple values, but has all
the drawbacks of std::map.  A sorted vector or some other approach is almost
always better.</p>
</div>
</div>
<div class="section" id="bit-storage-containers-bitvector-sparsebitvector">
<span id="ds-bit"></span><h3><a class="toc-backref" href="#id66">Bit storage containers (BitVector, SparseBitVector)</a><a class="headerlink" href="#bit-storage-containers-bitvector-sparsebitvector" title="Permalink to this headline">¶</a></h3>
<p>Unlike the other containers, there are only two bit storage containers, and
choosing when to use each is relatively straightforward.</p>
<p>One additional option is <tt class="docutils literal"><span class="pre">std::vector&lt;bool&gt;</span></tt>: we discourage its use for two
reasons 1) the implementation in many common compilers (e.g.  commonly
available versions of GCC) is extremely inefficient and 2) the C++ standards
committee is likely to deprecate this container and/or change it significantly
somehow.  In any case, please don&#8217;t use it.</p>
<div class="section" id="bitvector">
<span id="dss-bitvector"></span><h4><a class="toc-backref" href="#id67">BitVector</a><a class="headerlink" href="#bitvector" title="Permalink to this headline">¶</a></h4>
<p>The BitVector container provides a dynamic size set of bits for manipulation.
It supports individual bit setting/testing, as well as set operations.  The set
operations take time O(size of bitvector), but operations are performed one word
at a time, instead of one bit at a time.  This makes the BitVector very fast for
set operations compared to other containers.  Use the BitVector when you expect
the number of set bits to be high (i.e. a dense set).</p>
</div>
<div class="section" id="smallbitvector">
<span id="dss-smallbitvector"></span><h4><a class="toc-backref" href="#id68">SmallBitVector</a><a class="headerlink" href="#smallbitvector" title="Permalink to this headline">¶</a></h4>
<p>The SmallBitVector container provides the same interface as BitVector, but it is
optimized for the case where only a small number of bits, less than 25 or so,
are needed.  It also transparently supports larger bit counts, but slightly less
efficiently than a plain BitVector, so SmallBitVector should only be used when
larger counts are rare.</p>
<p>At this time, SmallBitVector does not support set operations (and, or, xor), and
its operator[] does not provide an assignable lvalue.</p>
</div>
<div class="section" id="sparsebitvector">
<span id="dss-sparsebitvector"></span><h4><a class="toc-backref" href="#id69">SparseBitVector</a><a class="headerlink" href="#sparsebitvector" title="Permalink to this headline">¶</a></h4>
<p>The SparseBitVector container is much like BitVector, with one major difference:
Only the bits that are set, are stored.  This makes the SparseBitVector much
more space efficient than BitVector when the set is sparse, as well as making
set operations O(number of set bits) instead of O(size of universe).  The
downside to the SparseBitVector is that setting and testing of random bits is
O(N), and on large SparseBitVectors, this can be slower than BitVector.  In our
implementation, setting or testing bits in sorted order (either forwards or
reverse) is O(1) worst case.  Testing and setting bits within 128 bits (depends
on size) of the current bit is also O(1).  As a general statement,
testing/setting bits in a SparseBitVector is O(distance away from last set bit).</p>
</div>
</div>
</div>
<div class="section" id="helpful-hints-for-common-operations">
<span id="common"></span><h2><a class="toc-backref" href="#id70">Helpful Hints for Common Operations</a><a class="headerlink" href="#helpful-hints-for-common-operations" title="Permalink to this headline">¶</a></h2>
<p>This section describes how to perform some very simple transformations of LLVM
code.  This is meant to give examples of common idioms used, showing the
practical side of LLVM transformations.</p>
<p>Because this is a &#8220;how-to&#8221; section, you should also read about the main classes
that you will be working with.  The <a class="reference internal" href="#coreclasses"><em>Core LLVM Class Hierarchy Reference</em></a> contains details and descriptions of the main classes that you
should know about.</p>
<div class="section" id="basic-inspection-and-traversal-routines">
<span id="inspection"></span><h3><a class="toc-backref" href="#id71">Basic Inspection and Traversal Routines</a><a class="headerlink" href="#basic-inspection-and-traversal-routines" title="Permalink to this headline">¶</a></h3>
<p>The LLVM compiler infrastructure have many different data structures that may be
traversed.  Following the example of the C++ standard template library, the
techniques used to traverse these various data structures are all basically the
same.  For a enumerable sequence of values, the <tt class="docutils literal"><span class="pre">XXXbegin()</span></tt> function (or
method) returns an iterator to the start of the sequence, the <tt class="docutils literal"><span class="pre">XXXend()</span></tt>
function returns an iterator pointing to one past the last valid element of the
sequence, and there is some <tt class="docutils literal"><span class="pre">XXXiterator</span></tt> data type that is common between the
two operations.</p>
<p>Because the pattern for iteration is common across many different aspects of the
program representation, the standard template library algorithms may be used on
them, and it is easier to remember how to iterate.  First we show a few common
examples of the data structures that need to be traversed.  Other data
structures are traversed in very similar ways.</p>
<div class="section" id="iterating-over-the-basicblock-in-a-function">
<span id="iterate-function"></span><h4><a class="toc-backref" href="#id72">Iterating over the <tt class="docutils literal"><span class="pre">BasicBlock</span></tt> in a <tt class="docutils literal"><span class="pre">Function</span></tt></a><a class="headerlink" href="#iterating-over-the-basicblock-in-a-function" title="Permalink to this headline">¶</a></h4>
<p>It&#8217;s quite common to have a <tt class="docutils literal"><span class="pre">Function</span></tt> instance that you&#8217;d like to transform
in some way; in particular, you&#8217;d like to manipulate its <tt class="docutils literal"><span class="pre">BasicBlock</span></tt>s.  To
facilitate this, you&#8217;ll need to iterate over all of the <tt class="docutils literal"><span class="pre">BasicBlock</span></tt>s that
constitute the <tt class="docutils literal"><span class="pre">Function</span></tt>.  The following is an example that prints the name
of a <tt class="docutils literal"><span class="pre">BasicBlock</span></tt> and the number of <tt class="docutils literal"><span class="pre">Instruction</span></tt>s it contains:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// func is a pointer to a Function instance</span>
<span class="k">for</span> <span class="p">(</span><span class="n">Function</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">(),</span> <span class="n">e</span> <span class="o">=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="c1">// Print out the name of the basic block if it has one, and then the</span>
  <span class="c1">// number of instructions that it contains</span>
  <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Basic block (name=&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;) has &quot;</span>
             <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; instructions.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that i can be used as if it were a pointer for the purposes of invoking
member functions of the <tt class="docutils literal"><span class="pre">Instruction</span></tt> class.  This is because the indirection
operator is overloaded for the iterator classes.  In the above code, the
expression <tt class="docutils literal"><span class="pre">i-&gt;size()</span></tt> is exactly equivalent to <tt class="docutils literal"><span class="pre">(*i).size()</span></tt> just like
you&#8217;d expect.</p>
</div>
<div class="section" id="iterating-over-the-instruction-in-a-basicblock">
<span id="iterate-basicblock"></span><h4><a class="toc-backref" href="#id73">Iterating over the <tt class="docutils literal"><span class="pre">Instruction</span></tt> in a <tt class="docutils literal"><span class="pre">BasicBlock</span></tt></a><a class="headerlink" href="#iterating-over-the-instruction-in-a-basicblock" title="Permalink to this headline">¶</a></h4>
<p>Just like when dealing with <tt class="docutils literal"><span class="pre">BasicBlock</span></tt>s in <tt class="docutils literal"><span class="pre">Function</span></tt>s, it&#8217;s easy to
iterate over the individual instructions that make up <tt class="docutils literal"><span class="pre">BasicBlock</span></tt>s.  Here&#8217;s
a code snippet that prints out each instruction in a <tt class="docutils literal"><span class="pre">BasicBlock</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// blk is a pointer to a BasicBlock instance</span>
<span class="k">for</span> <span class="p">(</span><span class="n">BasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">(),</span> <span class="n">e</span> <span class="o">=</span> <span class="n">blk</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
   <span class="c1">// The next statement works since operator&lt;&lt;(ostream&amp;,...)</span>
   <span class="c1">// is overloaded for Instruction&amp;</span>
   <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>However, this isn&#8217;t really the best way to print out the contents of a
<tt class="docutils literal"><span class="pre">BasicBlock</span></tt>!  Since the ostream operators are overloaded for virtually
anything you&#8217;ll care about, you could have just invoked the print routine on the
basic block itself: <tt class="docutils literal"><span class="pre">errs()</span> <span class="pre">&lt;&lt;</span> <span class="pre">*blk</span> <span class="pre">&lt;&lt;</span> <span class="pre">&quot;\n&quot;;</span></tt>.</p>
</div>
<div class="section" id="iterating-over-the-instruction-in-a-function">
<span id="iterate-insiter"></span><h4><a class="toc-backref" href="#id74">Iterating over the <tt class="docutils literal"><span class="pre">Instruction</span></tt> in a <tt class="docutils literal"><span class="pre">Function</span></tt></a><a class="headerlink" href="#iterating-over-the-instruction-in-a-function" title="Permalink to this headline">¶</a></h4>
<p>If you&#8217;re finding that you commonly iterate over a <tt class="docutils literal"><span class="pre">Function</span></tt>&#8216;s
<tt class="docutils literal"><span class="pre">BasicBlock</span></tt>s and then that <tt class="docutils literal"><span class="pre">BasicBlock</span></tt>&#8216;s <tt class="docutils literal"><span class="pre">Instruction</span></tt>s,
<tt class="docutils literal"><span class="pre">InstIterator</span></tt> should be used instead.  You&#8217;ll need to include
<tt class="docutils literal"><span class="pre">llvm/Support/InstIterator.h</span></tt> (<a class="reference external" href="http://llvm.org/doxygen/InstIterator_8h-source.html">doxygen</a>) and then instantiate
<tt class="docutils literal"><span class="pre">InstIterator</span></tt>s explicitly in your code.  Here&#8217;s a small example that shows
how to dump all instructions in a function to the standard error stream:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;llvm/Support/InstIterator.h&quot;</span>

<span class="c1">// F is a pointer to a Function instance</span>
<span class="k">for</span> <span class="p">(</span><span class="n">inst_iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">inst_begin</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">E</span> <span class="o">=</span> <span class="n">inst_end</span><span class="p">(</span><span class="n">F</span><span class="p">);</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">E</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span>
  <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">I</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Easy, isn&#8217;t it?  You can also use <tt class="docutils literal"><span class="pre">InstIterator</span></tt>s to fill a work list with
its initial contents.  For example, if you wanted to initialize a work list to
contain all instructions in a <tt class="docutils literal"><span class="pre">Function</span></tt> F, all you would need to do is
something like:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Instruction</span><span class="o">*&gt;</span> <span class="n">worklist</span><span class="p">;</span>
<span class="c1">// or better yet, SmallPtrSet&lt;Instruction*, 64&gt; worklist;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">inst_iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">inst_begin</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">E</span> <span class="o">=</span> <span class="n">inst_end</span><span class="p">(</span><span class="n">F</span><span class="p">);</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">E</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span>
  <span class="n">worklist</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">I</span><span class="p">);</span>
</pre></div>
</div>
<p>The STL set <tt class="docutils literal"><span class="pre">worklist</span></tt> would now contain all instructions in the <tt class="docutils literal"><span class="pre">Function</span></tt>
pointed to by F.</p>
</div>
<div class="section" id="turning-an-iterator-into-a-class-pointer-and-vice-versa">
<span id="iterate-convert"></span><h4><a class="toc-backref" href="#id75">Turning an iterator into a class pointer (and vice-versa)</a><a class="headerlink" href="#turning-an-iterator-into-a-class-pointer-and-vice-versa" title="Permalink to this headline">¶</a></h4>
<p>Sometimes, it&#8217;ll be useful to grab a reference (or pointer) to a class instance
when all you&#8217;ve got at hand is an iterator.  Well, extracting a reference or a
pointer from an iterator is very straight-forward.  Assuming that <tt class="docutils literal"><span class="pre">i</span></tt> is a
<tt class="docutils literal"><span class="pre">BasicBlock::iterator</span></tt> and <tt class="docutils literal"><span class="pre">j</span></tt> is a <tt class="docutils literal"><span class="pre">BasicBlock::const_iterator</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Instruction</span><span class="o">&amp;</span> <span class="n">inst</span> <span class="o">=</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>   <span class="c1">// Grab reference to instruction reference</span>
<span class="n">Instruction</span><span class="o">*</span> <span class="n">pinst</span> <span class="o">=</span> <span class="o">&amp;*</span><span class="n">i</span><span class="p">;</span> <span class="c1">// Grab pointer to instruction reference</span>
<span class="k">const</span> <span class="n">Instruction</span><span class="o">&amp;</span> <span class="n">inst</span> <span class="o">=</span> <span class="o">*</span><span class="n">j</span><span class="p">;</span>
</pre></div>
</div>
<p>However, the iterators you&#8217;ll be working with in the LLVM framework are special:
they will automatically convert to a ptr-to-instance type whenever they need to.
Instead of derferencing the iterator and then taking the address of the result,
you can simply assign the iterator to the proper pointer type and you get the
dereference and address-of operation as a result of the assignment (behind the
scenes, this is a result of overloading casting mechanisms).  Thus the last line
of the last example,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Instruction</span> <span class="o">*</span><span class="n">pinst</span> <span class="o">=</span> <span class="o">&amp;*</span><span class="n">i</span><span class="p">;</span>
</pre></div>
</div>
<p>is semantically equivalent to</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Instruction</span> <span class="o">*</span><span class="n">pinst</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</pre></div>
</div>
<p>It&#8217;s also possible to turn a class pointer into the corresponding iterator, and
this is a constant time operation (very efficient).  The following code snippet
illustrates use of the conversion constructors provided by LLVM iterators.  By
using these, you can explicitly grab the iterator of something without actually
obtaining it via iteration over some structure:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">printNextInstruction</span><span class="p">(</span><span class="n">Instruction</span><span class="o">*</span> <span class="n">inst</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">BasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
  <span class="o">++</span><span class="n">it</span><span class="p">;</span> <span class="c1">// After this line, it refers to the instruction after *inst</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span> <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Unfortunately, these implicit conversions come at a cost; they prevent these
iterators from conforming to standard iterator conventions, and thus from being
usable with standard algorithms and containers.  For example, they prevent the
following code, where <tt class="docutils literal"><span class="pre">B</span></tt> is a <tt class="docutils literal"><span class="pre">BasicBlock</span></tt>, from compiling:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">llvm</span><span class="o">::</span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">Instruction</span> <span class="o">*</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">B</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">(),</span> <span class="n">B</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">());</span>
</pre></div>
</div>
<p>Because of this, these implicit conversions may be removed some day, and
<tt class="docutils literal"><span class="pre">operator*</span></tt> changed to return a pointer instead of a reference.</p>
</div>
<div class="section" id="finding-call-sites-a-slightly-more-complex-example">
<span id="iterate-complex"></span><h4><a class="toc-backref" href="#id76">Finding call sites: a slightly more complex example</a><a class="headerlink" href="#finding-call-sites-a-slightly-more-complex-example" title="Permalink to this headline">¶</a></h4>
<p>Say that you&#8217;re writing a FunctionPass and would like to count all the locations
in the entire module (that is, across every <tt class="docutils literal"><span class="pre">Function</span></tt>) where a certain
function (i.e., some <tt class="docutils literal"><span class="pre">Function</span> <span class="pre">*</span></tt>) is already in scope.  As you&#8217;ll learn
later, you may want to use an <tt class="docutils literal"><span class="pre">InstVisitor</span></tt> to accomplish this in a much more
straight-forward manner, but this example will allow us to explore how you&#8217;d do
it if you didn&#8217;t have <tt class="docutils literal"><span class="pre">InstVisitor</span></tt> around.  In pseudo-code, this is what we
want to do:</p>
<div class="highlight-none"><div class="highlight"><pre>initialize callCounter to zero
for each Function f in the Module
  for each BasicBlock b in f
    for each Instruction i in b
      if (i is a CallInst and calls the given function)
        increment callCounter
</pre></div>
</div>
<p>And the actual code is (remember, because we&#8217;re writing a <tt class="docutils literal"><span class="pre">FunctionPass</span></tt>, our
<tt class="docutils literal"><span class="pre">FunctionPass</span></tt>-derived class simply has to override the <tt class="docutils literal"><span class="pre">runOnFunction</span></tt>
method):</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Function</span><span class="o">*</span> <span class="n">targetFunc</span> <span class="o">=</span> <span class="p">...;</span>

<span class="k">class</span> <span class="nc">OurFunctionPass</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FunctionPass</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="n">OurFunctionPass</span><span class="p">()</span><span class="o">:</span> <span class="n">callCounter</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">virtual</span> <span class="n">runOnFunction</span><span class="p">(</span><span class="n">Function</span><span class="o">&amp;</span> <span class="n">F</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">Function</span><span class="o">::</span><span class="n">iterator</span> <span class="n">b</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">be</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">b</span> <span class="o">!=</span> <span class="n">be</span><span class="p">;</span> <span class="o">++</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">BasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ie</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">ie</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">CallInst</span><span class="o">*</span> <span class="n">callInst</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">CallInst</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// We know we&#39;ve encountered a call instruction, so we</span>
            <span class="c1">// need to determine if it&#39;s a call to the</span>
            <span class="c1">// function pointed to by m_func or not.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">callInst</span><span class="o">-&gt;</span><span class="n">getCalledFunction</span><span class="p">()</span> <span class="o">==</span> <span class="n">targetFunc</span><span class="p">)</span>
              <span class="o">++</span><span class="n">callCounter</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

  <span class="nl">private:</span>
    <span class="kt">unsigned</span> <span class="n">callCounter</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="treating-calls-and-invokes-the-same-way">
<span id="calls-and-invokes"></span><h4><a class="toc-backref" href="#id77">Treating calls and invokes the same way</a><a class="headerlink" href="#treating-calls-and-invokes-the-same-way" title="Permalink to this headline">¶</a></h4>
<p>You may have noticed that the previous example was a bit oversimplified in that
it did not deal with call sites generated by &#8216;invoke&#8217; instructions.  In this,
and in other situations, you may find that you want to treat <tt class="docutils literal"><span class="pre">CallInst</span></tt>s and
<tt class="docutils literal"><span class="pre">InvokeInst</span></tt>s the same way, even though their most-specific common base
class is <tt class="docutils literal"><span class="pre">Instruction</span></tt>, which includes lots of less closely-related things.
For these cases, LLVM provides a handy wrapper class called <tt class="docutils literal"><span class="pre">CallSite</span></tt>
(<a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1CallSite.html">doxygen</a>) It is
essentially a wrapper around an <tt class="docutils literal"><span class="pre">Instruction</span></tt> pointer, with some methods that
provide functionality common to <tt class="docutils literal"><span class="pre">CallInst</span></tt>s and <tt class="docutils literal"><span class="pre">InvokeInst</span></tt>s.</p>
<p>This class has &#8220;value semantics&#8221;: it should be passed by value, not by reference
and it should not be dynamically allocated or deallocated using <tt class="docutils literal"><span class="pre">operator</span> <span class="pre">new</span></tt>
or <tt class="docutils literal"><span class="pre">operator</span> <span class="pre">delete</span></tt>.  It is efficiently copyable, assignable and
constructable, with costs equivalents to that of a bare pointer.  If you look at
its definition, it has only a single pointer member.</p>
</div>
<div class="section" id="iterating-over-def-use-use-def-chains">
<span id="iterate-chains"></span><h4><a class="toc-backref" href="#id78">Iterating over def-use &amp; use-def chains</a><a class="headerlink" href="#iterating-over-def-use-use-def-chains" title="Permalink to this headline">¶</a></h4>
<p>Frequently, we might have an instance of the <tt class="docutils literal"><span class="pre">Value</span></tt> class (<a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Value.html">doxygen</a>) and we want to determine
which <tt class="docutils literal"><span class="pre">User</span></tt> s use the <tt class="docutils literal"><span class="pre">Value</span></tt>.  The list of all <tt class="docutils literal"><span class="pre">User</span></tt>s of a particular
<tt class="docutils literal"><span class="pre">Value</span></tt> is called a <em>def-use</em> chain.  For example, let&#8217;s say we have a
<tt class="docutils literal"><span class="pre">Function*</span></tt> named <tt class="docutils literal"><span class="pre">F</span></tt> to a particular function <tt class="docutils literal"><span class="pre">foo</span></tt>.  Finding all of the
instructions that <em>use</em> <tt class="docutils literal"><span class="pre">foo</span></tt> is as simple as iterating over the <em>def-use</em>
chain of <tt class="docutils literal"><span class="pre">F</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Function</span> <span class="o">*</span><span class="n">F</span> <span class="o">=</span> <span class="p">...;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">Value</span><span class="o">::</span><span class="n">use_iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">F</span><span class="o">-&gt;</span><span class="n">use_begin</span><span class="p">(),</span> <span class="n">e</span> <span class="o">=</span> <span class="n">F</span><span class="o">-&gt;</span><span class="n">use_end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Instruction</span> <span class="o">*</span><span class="n">Inst</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">Instruction</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;F is used in instruction:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">Inst</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>Note that dereferencing a <tt class="docutils literal"><span class="pre">Value::use_iterator</span></tt> is not a very cheap operation.
Instead of performing <tt class="docutils literal"><span class="pre">*i</span></tt> above several times, consider doing it only once in
the loop body and reusing its result.</p>
<p>Alternatively, it&#8217;s common to have an instance of the <tt class="docutils literal"><span class="pre">User</span></tt> Class (<a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1User.html">doxygen</a>) and need to know what
<tt class="docutils literal"><span class="pre">Value</span></tt>s are used by it.  The list of all <tt class="docutils literal"><span class="pre">Value</span></tt>s used by a <tt class="docutils literal"><span class="pre">User</span></tt> is
known as a <em>use-def</em> chain.  Instances of class <tt class="docutils literal"><span class="pre">Instruction</span></tt> are common
<tt class="docutils literal"><span class="pre">User</span></tt> s, so we might want to iterate over all of the values that a particular
instruction uses (that is, the operands of the particular <tt class="docutils literal"><span class="pre">Instruction</span></tt>):</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Instruction</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="p">...;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">User</span><span class="o">::</span><span class="n">op_iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">op_begin</span><span class="p">(),</span> <span class="n">e</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">op_end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Value</span> <span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Declaring objects as <tt class="docutils literal"><span class="pre">const</span></tt> is an important tool of enforcing mutation free
algorithms (such as analyses, etc.).  For this purpose above iterators come in
constant flavors as <tt class="docutils literal"><span class="pre">Value::const_use_iterator</span></tt> and
<tt class="docutils literal"><span class="pre">Value::const_op_iterator</span></tt>.  They automatically arise when calling
<tt class="docutils literal"><span class="pre">use/op_begin()</span></tt> on <tt class="docutils literal"><span class="pre">const</span> <span class="pre">Value*</span></tt>s or <tt class="docutils literal"><span class="pre">const</span> <span class="pre">User*</span></tt>s respectively.
Upon dereferencing, they return <tt class="docutils literal"><span class="pre">const</span> <span class="pre">Use*</span></tt>s.  Otherwise the above patterns
remain unchanged.</p>
</div>
<div class="section" id="iterating-over-predecessors-successors-of-blocks">
<span id="iterate-preds"></span><h4><a class="toc-backref" href="#id79">Iterating over predecessors &amp; successors of blocks</a><a class="headerlink" href="#iterating-over-predecessors-successors-of-blocks" title="Permalink to this headline">¶</a></h4>
<p>Iterating over the predecessors and successors of a block is quite easy with the
routines defined in <tt class="docutils literal"><span class="pre">&quot;llvm/Support/CFG.h&quot;</span></tt>.  Just use code like this to
iterate over all predecessors of BB:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;llvm/Support/CFG.h&quot;</span>
<span class="n">BasicBlock</span> <span class="o">*</span><span class="n">BB</span> <span class="o">=</span> <span class="p">...;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">pred_iterator</span> <span class="n">PI</span> <span class="o">=</span> <span class="n">pred_begin</span><span class="p">(</span><span class="n">BB</span><span class="p">),</span> <span class="n">E</span> <span class="o">=</span> <span class="n">pred_end</span><span class="p">(</span><span class="n">BB</span><span class="p">);</span> <span class="n">PI</span> <span class="o">!=</span> <span class="n">E</span><span class="p">;</span> <span class="o">++</span><span class="n">PI</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">BasicBlock</span> <span class="o">*</span><span class="n">Pred</span> <span class="o">=</span> <span class="o">*</span><span class="n">PI</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Similarly, to iterate over successors use <tt class="docutils literal"><span class="pre">succ_iterator/succ_begin/succ_end</span></tt>.</p>
</div>
</div>
<div class="section" id="making-simple-changes">
<span id="simplechanges"></span><h3><a class="toc-backref" href="#id80">Making simple changes</a><a class="headerlink" href="#making-simple-changes" title="Permalink to this headline">¶</a></h3>
<p>There are some primitive transformation operations present in the LLVM
infrastructure that are worth knowing about.  When performing transformations,
it&#8217;s fairly common to manipulate the contents of basic blocks.  This section
describes some of the common methods for doing so and gives example code.</p>
<div class="section" id="creating-and-inserting-new-instructions">
<span id="schanges-creating"></span><h4><a class="toc-backref" href="#id81">Creating and inserting new <tt class="docutils literal"><span class="pre">Instruction</span></tt>s</a><a class="headerlink" href="#creating-and-inserting-new-instructions" title="Permalink to this headline">¶</a></h4>
<p><em>Instantiating Instructions</em></p>
<p>Creation of <tt class="docutils literal"><span class="pre">Instruction</span></tt>s is straight-forward: simply call the constructor
for the kind of instruction to instantiate and provide the necessary parameters.
For example, an <tt class="docutils literal"><span class="pre">AllocaInst</span></tt> only <em>requires</em> a (const-ptr-to) <tt class="docutils literal"><span class="pre">Type</span></tt>.  Thus:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">AllocaInst</span><span class="o">*</span> <span class="n">ai</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AllocaInst</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">Int32Ty</span><span class="p">);</span>
</pre></div>
</div>
<p>will create an <tt class="docutils literal"><span class="pre">AllocaInst</span></tt> instance that represents the allocation of one
integer in the current stack frame, at run time.  Each <tt class="docutils literal"><span class="pre">Instruction</span></tt> subclass
is likely to have varying default parameters which change the semantics of the
instruction, so refer to the <a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Instruction.html">doxygen documentation for the subclass of
Instruction</a> that
you&#8217;re interested in instantiating.</p>
<p><em>Naming values</em></p>
<p>It is very useful to name the values of instructions when you&#8217;re able to, as
this facilitates the debugging of your transformations.  If you end up looking
at generated LLVM machine code, you definitely want to have logical names
associated with the results of instructions!  By supplying a value for the
<tt class="docutils literal"><span class="pre">Name</span></tt> (default) parameter of the <tt class="docutils literal"><span class="pre">Instruction</span></tt> constructor, you associate a
logical name with the result of the instruction&#8217;s execution at run time.  For
example, say that I&#8217;m writing a transformation that dynamically allocates space
for an integer on the stack, and that integer is going to be used as some kind
of index by some other code.  To accomplish this, I place an <tt class="docutils literal"><span class="pre">AllocaInst</span></tt> at
the first point in the first <tt class="docutils literal"><span class="pre">BasicBlock</span></tt> of some <tt class="docutils literal"><span class="pre">Function</span></tt>, and I&#8217;m
intending to use it within the same <tt class="docutils literal"><span class="pre">Function</span></tt>.  I might do:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">AllocaInst</span><span class="o">*</span> <span class="n">pa</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AllocaInst</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">Int32Ty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;indexLoc&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">indexLoc</span></tt> is now the logical name of the instruction&#8217;s execution value,
which is a pointer to an integer on the run time stack.</p>
<p><em>Inserting instructions</em></p>
<p>There are essentially two ways to insert an <tt class="docutils literal"><span class="pre">Instruction</span></tt> into an existing
sequence of instructions that form a <tt class="docutils literal"><span class="pre">BasicBlock</span></tt>:</p>
<ul>
<li><p class="first">Insertion into an explicit instruction list</p>
<p>Given a <tt class="docutils literal"><span class="pre">BasicBlock*</span> <span class="pre">pb</span></tt>, an <tt class="docutils literal"><span class="pre">Instruction*</span> <span class="pre">pi</span></tt> within that <tt class="docutils literal"><span class="pre">BasicBlock</span></tt>,
and a newly-created instruction we wish to insert before <tt class="docutils literal"><span class="pre">*pi</span></tt>, we do the
following:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">BasicBlock</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">Instruction</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">Instruction</span> <span class="o">*</span><span class="n">newInst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Instruction</span><span class="p">(...);</span>

<span class="n">pb</span><span class="o">-&gt;</span><span class="n">getInstList</span><span class="p">().</span><span class="n">insert</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">newInst</span><span class="p">);</span> <span class="c1">// Inserts newInst before pi in pb</span>
</pre></div>
</div>
<p>Appending to the end of a <tt class="docutils literal"><span class="pre">BasicBlock</span></tt> is so common that the <tt class="docutils literal"><span class="pre">Instruction</span></tt>
class and <tt class="docutils literal"><span class="pre">Instruction</span></tt>-derived classes provide constructors which take a
pointer to a <tt class="docutils literal"><span class="pre">BasicBlock</span></tt> to be appended to.  For example code that looked
like:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">BasicBlock</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">Instruction</span> <span class="o">*</span><span class="n">newInst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Instruction</span><span class="p">(...);</span>

<span class="n">pb</span><span class="o">-&gt;</span><span class="n">getInstList</span><span class="p">().</span><span class="n">push_back</span><span class="p">(</span><span class="n">newInst</span><span class="p">);</span> <span class="c1">// Appends newInst to pb</span>
</pre></div>
</div>
<p>becomes:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">BasicBlock</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">Instruction</span> <span class="o">*</span><span class="n">newInst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Instruction</span><span class="p">(...,</span> <span class="n">pb</span><span class="p">);</span>
</pre></div>
</div>
<p>which is much cleaner, especially if you are creating long instruction
streams.</p>
</li>
<li><p class="first">Insertion into an implicit instruction list</p>
<p><tt class="docutils literal"><span class="pre">Instruction</span></tt> instances that are already in <tt class="docutils literal"><span class="pre">BasicBlock</span></tt>s are implicitly
associated with an existing instruction list: the instruction list of the
enclosing basic block.  Thus, we could have accomplished the same thing as the
above code without being given a <tt class="docutils literal"><span class="pre">BasicBlock</span></tt> by doing:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Instruction</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">Instruction</span> <span class="o">*</span><span class="n">newInst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Instruction</span><span class="p">(...);</span>

<span class="n">pi</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getInstList</span><span class="p">().</span><span class="n">insert</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">newInst</span><span class="p">);</span>
</pre></div>
</div>
<p>In fact, this sequence of steps occurs so frequently that the <tt class="docutils literal"><span class="pre">Instruction</span></tt>
class and <tt class="docutils literal"><span class="pre">Instruction</span></tt>-derived classes provide constructors which take (as
a default parameter) a pointer to an <tt class="docutils literal"><span class="pre">Instruction</span></tt> which the newly-created
<tt class="docutils literal"><span class="pre">Instruction</span></tt> should precede.  That is, <tt class="docutils literal"><span class="pre">Instruction</span></tt> constructors are
capable of inserting the newly-created instance into the <tt class="docutils literal"><span class="pre">BasicBlock</span></tt> of a
provided instruction, immediately before that instruction.  Using an
<tt class="docutils literal"><span class="pre">Instruction</span></tt> constructor with a <tt class="docutils literal"><span class="pre">insertBefore</span></tt> (default) parameter, the
above code becomes:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Instruction</span><span class="o">*</span> <span class="n">pi</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">Instruction</span><span class="o">*</span> <span class="n">newInst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Instruction</span><span class="p">(...,</span> <span class="n">pi</span><span class="p">);</span>
</pre></div>
</div>
<p>which is much cleaner, especially if you&#8217;re creating a lot of instructions and
adding them to <tt class="docutils literal"><span class="pre">BasicBlock</span></tt>s.</p>
</li>
</ul>
</div>
<div class="section" id="deleting-instructions">
<span id="schanges-deleting"></span><h4><a class="toc-backref" href="#id82">Deleting Instructions</a><a class="headerlink" href="#deleting-instructions" title="Permalink to this headline">¶</a></h4>
<p>Deleting an instruction from an existing sequence of instructions that form a
<a class="reference internal" href="#basicblock">BasicBlock</a> is very straight-forward: just call the instruction&#8217;s
<tt class="docutils literal"><span class="pre">eraseFromParent()</span></tt> method.  For example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Instruction</span> <span class="o">*</span><span class="n">I</span> <span class="o">=</span> <span class="p">..</span> <span class="p">;</span>
<span class="n">I</span><span class="o">-&gt;</span><span class="n">eraseFromParent</span><span class="p">();</span>
</pre></div>
</div>
<p>This unlinks the instruction from its containing basic block and deletes it.  If
you&#8217;d just like to unlink the instruction from its containing basic block but
not delete it, you can use the <tt class="docutils literal"><span class="pre">removeFromParent()</span></tt> method.</p>
</div>
<div class="section" id="replacing-an-instruction-with-another-value">
<span id="schanges-replacing"></span><h4><a class="toc-backref" href="#id83">Replacing an Instruction with another Value</a><a class="headerlink" href="#replacing-an-instruction-with-another-value" title="Permalink to this headline">¶</a></h4>
<div class="section" id="replacing-individual-instructions">
<h5><a class="toc-backref" href="#id84">Replacing individual instructions</a><a class="headerlink" href="#replacing-individual-instructions" title="Permalink to this headline">¶</a></h5>
<p>Including &#8220;<a class="reference external" href="http://llvm.org/doxygen/BasicBlockUtils_8h-source.html">llvm/Transforms/Utils/BasicBlockUtils.h</a>&#8221; permits use of two
very useful replace functions: <tt class="docutils literal"><span class="pre">ReplaceInstWithValue</span></tt> and
<tt class="docutils literal"><span class="pre">ReplaceInstWithInst</span></tt>.</p>
</div>
<div class="section" id="schanges-deleting-sub">
<span id="id3"></span><h5><a class="toc-backref" href="#id85">Deleting Instructions</a><a class="headerlink" href="#schanges-deleting-sub" title="Permalink to this headline">¶</a></h5>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">ReplaceInstWithValue</span></tt></p>
<p>This function replaces all uses of a given instruction with a value, and then
removes the original instruction.  The following example illustrates the
replacement of the result of a particular <tt class="docutils literal"><span class="pre">AllocaInst</span></tt> that allocates memory
for a single integer with a null pointer to an integer.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">AllocaInst</span><span class="o">*</span> <span class="n">instToReplace</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">BasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">ii</span><span class="p">(</span><span class="n">instToReplace</span><span class="p">);</span>

<span class="n">ReplaceInstWithValue</span><span class="p">(</span><span class="n">instToReplace</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getInstList</span><span class="p">(),</span> <span class="n">ii</span><span class="p">,</span>
                     <span class="n">Constant</span><span class="o">::</span><span class="n">getNullValue</span><span class="p">(</span><span class="n">PointerType</span><span class="o">::</span><span class="n">getUnqual</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">Int32Ty</span><span class="p">)));</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">ReplaceInstWithInst</span></tt></p>
<p>This function replaces a particular instruction with another instruction,
inserting the new instruction into the basic block at the location where the
old instruction was, and replacing any uses of the old instruction with the
new instruction.  The following example illustrates the replacement of one
<tt class="docutils literal"><span class="pre">AllocaInst</span></tt> with another.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">AllocaInst</span><span class="o">*</span> <span class="n">instToReplace</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">BasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">ii</span><span class="p">(</span><span class="n">instToReplace</span><span class="p">);</span>

<span class="n">ReplaceInstWithInst</span><span class="p">(</span><span class="n">instToReplace</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getInstList</span><span class="p">(),</span> <span class="n">ii</span><span class="p">,</span>
                    <span class="k">new</span> <span class="n">AllocaInst</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">Int32Ty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;ptrToReplacedInt&quot;</span><span class="p">));</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="replacing-multiple-uses-of-users-and-values">
<h5><a class="toc-backref" href="#id86">Replacing multiple uses of Users and Values</a><a class="headerlink" href="#replacing-multiple-uses-of-users-and-values" title="Permalink to this headline">¶</a></h5>
<p>You can use <tt class="docutils literal"><span class="pre">Value::replaceAllUsesWith</span></tt> and <tt class="docutils literal"><span class="pre">User::replaceUsesOfWith</span></tt> to
change more than one use at a time.  See the doxygen documentation for the
<a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Value.html">Value Class</a> and <a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1User.html">User Class</a>, respectively, for more
information.</p>
</div>
</div>
<div class="section" id="deleting-globalvariables">
<span id="schanges-deletinggv"></span><h4><a class="toc-backref" href="#id87">Deleting GlobalVariables</a><a class="headerlink" href="#deleting-globalvariables" title="Permalink to this headline">¶</a></h4>
<p>Deleting a global variable from a module is just as easy as deleting an
Instruction.  First, you must have a pointer to the global variable that you
wish to delete.  You use this pointer to erase it from its parent, the module.
For example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">GlobalVariable</span> <span class="o">*</span><span class="n">GV</span> <span class="o">=</span> <span class="p">..</span> <span class="p">;</span>

<span class="n">GV</span><span class="o">-&gt;</span><span class="n">eraseFromParent</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="how-to-create-types">
<span id="create-types"></span><h3><a class="toc-backref" href="#id88">How to Create Types</a><a class="headerlink" href="#how-to-create-types" title="Permalink to this headline">¶</a></h3>
<p>In generating IR, you may need some complex types.  If you know these types
statically, you can use <tt class="docutils literal"><span class="pre">TypeBuilder&lt;...&gt;::get()</span></tt>, defined in
<tt class="docutils literal"><span class="pre">llvm/Support/TypeBuilder.h</span></tt>, to retrieve them.  <tt class="docutils literal"><span class="pre">TypeBuilder</span></tt> has two forms
depending on whether you&#8217;re building types for cross-compilation or native
library use.  <tt class="docutils literal"><span class="pre">TypeBuilder&lt;T,</span> <span class="pre">true&gt;</span></tt> requires that <tt class="docutils literal"><span class="pre">T</span></tt> be independent of the
host environment, meaning that it&#8217;s built out of types from the <tt class="docutils literal"><span class="pre">llvm::types</span></tt>
(<a class="reference external" href="http://llvm.org/doxygen/namespacellvm_1_1types.html">doxygen</a>) namespace
and pointers, functions, arrays, etc. built of those.  <tt class="docutils literal"><span class="pre">TypeBuilder&lt;T,</span> <span class="pre">false&gt;</span></tt>
additionally allows native C types whose size may depend on the host compiler.
For example,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">FunctionType</span> <span class="o">*</span><span class="n">ft</span> <span class="o">=</span> <span class="n">TypeBuilder</span><span class="o">&lt;</span><span class="n">types</span><span class="o">::</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span><span class="p">(</span><span class="n">types</span><span class="o">::</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;*</span><span class="p">),</span> <span class="nb">true</span><span class="o">&gt;::</span><span class="n">get</span><span class="p">();</span>
</pre></div>
</div>
<p>is easier to read and write than the equivalent</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Type</span><span class="o">*&gt;</span> <span class="n">params</span><span class="p">;</span>
<span class="n">params</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">PointerType</span><span class="o">::</span><span class="n">getUnqual</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">Int32Ty</span><span class="p">));</span>
<span class="n">FunctionType</span> <span class="o">*</span><span class="n">ft</span> <span class="o">=</span> <span class="n">FunctionType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">Int8Ty</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</pre></div>
</div>
<p>See the <a class="reference external" href="http://llvm.org/doxygen/TypeBuilder_8h-source.html#l00001">class comment</a> for more details.</p>
</div>
</div>
<div class="section" id="threads-and-llvm">
<span id="threading"></span><h2><a class="toc-backref" href="#id89">Threads and LLVM</a><a class="headerlink" href="#threads-and-llvm" title="Permalink to this headline">¶</a></h2>
<p>This section describes the interaction of the LLVM APIs with multithreading,
both on the part of client applications, and in the JIT, in the hosted
application.</p>
<p>Note that LLVM&#8217;s support for multithreading is still relatively young.  Up
through version 2.5, the execution of threaded hosted applications was
supported, but not threaded client access to the APIs.  While this use case is
now supported, clients <em>must</em> adhere to the guidelines specified below to ensure
proper operation in multithreaded mode.</p>
<p>Note that, on Unix-like platforms, LLVM requires the presence of GCC&#8217;s atomic
intrinsics in order to support threaded operation.  If you need a
multhreading-capable LLVM on a platform without a suitably modern system
compiler, consider compiling LLVM and LLVM-GCC in single-threaded mode, and
using the resultant compiler to build a copy of LLVM with multithreading
support.</p>
<div class="section" id="entering-and-exiting-multithreaded-mode">
<span id="startmultithreaded"></span><h3><a class="toc-backref" href="#id90">Entering and Exiting Multithreaded Mode</a><a class="headerlink" href="#entering-and-exiting-multithreaded-mode" title="Permalink to this headline">¶</a></h3>
<p>In order to properly protect its internal data structures while avoiding
excessive locking overhead in the single-threaded case, the LLVM must intialize
certain data structures necessary to provide guards around its internals.  To do
so, the client program must invoke <tt class="docutils literal"><span class="pre">llvm_start_multithreaded()</span></tt> before making
any concurrent LLVM API calls.  To subsequently tear down these structures, use
the <tt class="docutils literal"><span class="pre">llvm_stop_multithreaded()</span></tt> call.  You can also use the
<tt class="docutils literal"><span class="pre">llvm_is_multithreaded()</span></tt> call to check the status of multithreaded mode.</p>
<p>Note that both of these calls must be made <em>in isolation</em>.  That is to say that
no other LLVM API calls may be executing at any time during the execution of
<tt class="docutils literal"><span class="pre">llvm_start_multithreaded()</span></tt> or <tt class="docutils literal"><span class="pre">llvm_stop_multithreaded</span></tt>.  It is the
client&#8217;s responsibility to enforce this isolation.</p>
<p>The return value of <tt class="docutils literal"><span class="pre">llvm_start_multithreaded()</span></tt> indicates the success or
failure of the initialization.  Failure typically indicates that your copy of
LLVM was built without multithreading support, typically because GCC atomic
intrinsics were not found in your system compiler.  In this case, the LLVM API
will not be safe for concurrent calls.  However, it <em>will</em> be safe for hosting
threaded applications in the JIT, though <a class="reference internal" href="#jitthreading"><em>care must be taken</em></a> to ensure that side exits and the like do not accidentally
result in concurrent LLVM API calls.</p>
</div>
<div class="section" id="ending-execution-with-llvm-shutdown">
<span id="shutdown"></span><h3><a class="toc-backref" href="#id91">Ending Execution with <tt class="docutils literal"><span class="pre">llvm_shutdown()</span></tt></a><a class="headerlink" href="#ending-execution-with-llvm-shutdown" title="Permalink to this headline">¶</a></h3>
<p>When you are done using the LLVM APIs, you should call <tt class="docutils literal"><span class="pre">llvm_shutdown()</span></tt> to
deallocate memory used for internal structures.  This will also invoke
<tt class="docutils literal"><span class="pre">llvm_stop_multithreaded()</span></tt> if LLVM is operating in multithreaded mode.  As
such, <tt class="docutils literal"><span class="pre">llvm_shutdown()</span></tt> requires the same isolation guarantees as
<tt class="docutils literal"><span class="pre">llvm_stop_multithreaded()</span></tt>.</p>
<p>Note that, if you use scope-based shutdown, you can use the
<tt class="docutils literal"><span class="pre">llvm_shutdown_obj</span></tt> class, which calls <tt class="docutils literal"><span class="pre">llvm_shutdown()</span></tt> in its destructor.</p>
</div>
<div class="section" id="lazy-initialization-with-managedstatic">
<span id="managedstatic"></span><h3><a class="toc-backref" href="#id92">Lazy Initialization with <tt class="docutils literal"><span class="pre">ManagedStatic</span></tt></a><a class="headerlink" href="#lazy-initialization-with-managedstatic" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">ManagedStatic</span></tt> is a utility class in LLVM used to implement static
initialization of static resources, such as the global type tables.  Before the
invocation of <tt class="docutils literal"><span class="pre">llvm_shutdown()</span></tt>, it implements a simple lazy initialization
scheme.  Once <tt class="docutils literal"><span class="pre">llvm_start_multithreaded()</span></tt> returns, however, it uses
double-checked locking to implement thread-safe lazy initialization.</p>
<p>Note that, because no other threads are allowed to issue LLVM API calls before
<tt class="docutils literal"><span class="pre">llvm_start_multithreaded()</span></tt> returns, it is possible to have
<tt class="docutils literal"><span class="pre">ManagedStatic</span></tt>s of <tt class="docutils literal"><span class="pre">llvm::sys::Mutex</span></tt>s.</p>
<p>The <tt class="docutils literal"><span class="pre">llvm_acquire_global_lock()</span></tt> and <tt class="docutils literal"><span class="pre">llvm_release_global_lock</span></tt> APIs provide
access to the global lock used to implement the double-checked locking for lazy
initialization.  These should only be used internally to LLVM, and only if you
know what you&#8217;re doing!</p>
</div>
<div class="section" id="achieving-isolation-with-llvmcontext">
<span id="llvmcontext"></span><h3><a class="toc-backref" href="#id93">Achieving Isolation with <tt class="docutils literal"><span class="pre">LLVMContext</span></tt></a><a class="headerlink" href="#achieving-isolation-with-llvmcontext" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">LLVMContext</span></tt> is an opaque class in the LLVM API which clients can use to
operate multiple, isolated instances of LLVM concurrently within the same
address space.  For instance, in a hypothetical compile-server, the compilation
of an individual translation unit is conceptually independent from all the
others, and it would be desirable to be able to compile incoming translation
units concurrently on independent server threads.  Fortunately, <tt class="docutils literal"><span class="pre">LLVMContext</span></tt>
exists to enable just this kind of scenario!</p>
<p>Conceptually, <tt class="docutils literal"><span class="pre">LLVMContext</span></tt> provides isolation.  Every LLVM entity
(<tt class="docutils literal"><span class="pre">Module</span></tt>s, <tt class="docutils literal"><span class="pre">Value</span></tt>s, <tt class="docutils literal"><span class="pre">Type</span></tt>s, <tt class="docutils literal"><span class="pre">Constant</span></tt>s, etc.) in LLVM&#8217;s
in-memory IR belongs to an <tt class="docutils literal"><span class="pre">LLVMContext</span></tt>.  Entities in different contexts
<em>cannot</em> interact with each other: <tt class="docutils literal"><span class="pre">Module</span></tt>s in different contexts cannot be
linked together, <tt class="docutils literal"><span class="pre">Function</span></tt>s cannot be added to <tt class="docutils literal"><span class="pre">Module</span></tt>s in different
contexts, etc.  What this means is that is is safe to compile on multiple
threads simultaneously, as long as no two threads operate on entities within the
same context.</p>
<p>In practice, very few places in the API require the explicit specification of a
<tt class="docutils literal"><span class="pre">LLVMContext</span></tt>, other than the <tt class="docutils literal"><span class="pre">Type</span></tt> creation/lookup APIs.  Because every
<tt class="docutils literal"><span class="pre">Type</span></tt> carries a reference to its owning context, most other entities can
determine what context they belong to by looking at their own <tt class="docutils literal"><span class="pre">Type</span></tt>.  If you
are adding new entities to LLVM IR, please try to maintain this interface
design.</p>
<p>For clients that do <em>not</em> require the benefits of isolation, LLVM provides a
convenience API <tt class="docutils literal"><span class="pre">getGlobalContext()</span></tt>.  This returns a global, lazily
initialized <tt class="docutils literal"><span class="pre">LLVMContext</span></tt> that may be used in situations where isolation is
not a concern.</p>
</div>
<div class="section" id="threads-and-the-jit">
<span id="jitthreading"></span><h3><a class="toc-backref" href="#id94">Threads and the JIT</a><a class="headerlink" href="#threads-and-the-jit" title="Permalink to this headline">¶</a></h3>
<p>LLVM&#8217;s &#8220;eager&#8221; JIT compiler is safe to use in threaded programs.  Multiple
threads can call <tt class="docutils literal"><span class="pre">ExecutionEngine::getPointerToFunction()</span></tt> or
<tt class="docutils literal"><span class="pre">ExecutionEngine::runFunction()</span></tt> concurrently, and multiple threads can run
code output by the JIT concurrently.  The user must still ensure that only one
thread accesses IR in a given <tt class="docutils literal"><span class="pre">LLVMContext</span></tt> while another thread might be
modifying it.  One way to do that is to always hold the JIT lock while accessing
IR outside the JIT (the JIT <em>modifies</em> the IR by adding <tt class="docutils literal"><span class="pre">CallbackVH</span></tt>s).
Another way is to only call <tt class="docutils literal"><span class="pre">getPointerToFunction()</span></tt> from the
<tt class="docutils literal"><span class="pre">LLVMContext</span></tt>&#8216;s thread.</p>
<p>When the JIT is configured to compile lazily (using
<tt class="docutils literal"><span class="pre">ExecutionEngine::DisableLazyCompilation(false)</span></tt>), there is currently a <a class="reference external" href="http://llvm.org/bugs/show_bug.cgi?id=5184">race
condition</a> in updating call sites
after a function is lazily-jitted.  It&#8217;s still possible to use the lazy JIT in a
threaded program if you ensure that only one thread at a time can call any
particular lazy stub and that the JIT lock guards any IR access, but we suggest
using only the eager JIT in threaded programs.</p>
</div>
</div>
<div class="section" id="advanced-topics">
<span id="advanced"></span><h2><a class="toc-backref" href="#id95">Advanced Topics</a><a class="headerlink" href="#advanced-topics" title="Permalink to this headline">¶</a></h2>
<p>This section describes some of the advanced or obscure API&#8217;s that most clients
do not need to be aware of.  These API&#8217;s tend manage the inner workings of the
LLVM system, and only need to be accessed in unusual circumstances.</p>
<div class="section" id="the-valuesymboltable-class">
<span id="symboltable"></span><h3><a class="toc-backref" href="#id96">The <tt class="docutils literal"><span class="pre">ValueSymbolTable</span></tt> class</a><a class="headerlink" href="#the-valuesymboltable-class" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">ValueSymbolTable</span></tt> (<a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1ValueSymbolTable.html">doxygen</a>) class provides
a symbol table that the <a class="reference internal" href="#c-function"><em>Function</em></a> and <a class="reference internal" href="#module">Module</a> classes use for
naming value definitions.  The symbol table can provide a name for any <a class="reference internal" href="#value">Value</a>.</p>
<p>Note that the <tt class="docutils literal"><span class="pre">SymbolTable</span></tt> class should not be directly accessed by most
clients.  It should only be used when iteration over the symbol table names
themselves are required, which is very special purpose.  Note that not all LLVM
<a class="reference internal" href="#value">Value</a>s have names, and those without names (i.e. they have an empty name) do
not exist in the symbol table.</p>
<p>Symbol tables support iteration over the values in the symbol table with
<tt class="docutils literal"><span class="pre">begin/end/iterator</span></tt> and supports querying to see if a specific name is in the
symbol table (with <tt class="docutils literal"><span class="pre">lookup</span></tt>).  The <tt class="docutils literal"><span class="pre">ValueSymbolTable</span></tt> class exposes no
public mutator methods, instead, simply call <tt class="docutils literal"><span class="pre">setName</span></tt> on a value, which will
autoinsert it into the appropriate symbol table.</p>
</div>
<div class="section" id="the-user-and-owned-use-classes-memory-layout">
<span id="userlayout"></span><h3><a class="toc-backref" href="#id97">The <tt class="docutils literal"><span class="pre">User</span></tt> and owned <tt class="docutils literal"><span class="pre">Use</span></tt> classes&#8217; memory layout</a><a class="headerlink" href="#the-user-and-owned-use-classes-memory-layout" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">User</span></tt> (<a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1User.html">doxygen</a>)
class provides a basis for expressing the ownership of <tt class="docutils literal"><span class="pre">User</span></tt> towards other
<a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Value.html">Value instance</a>s.  The
<tt class="docutils literal"><span class="pre">Use</span></tt> (<a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Use.html">doxygen</a>) helper
class is employed to do the bookkeeping and to facilitate <em>O(1)</em> addition and
removal.</p>
<div class="section" id="interaction-and-relationship-between-user-and-use-objects">
<span id="use2user"></span><h4><a class="toc-backref" href="#id98">Interaction and relationship between <tt class="docutils literal"><span class="pre">User</span></tt> and <tt class="docutils literal"><span class="pre">Use</span></tt> objects</a><a class="headerlink" href="#interaction-and-relationship-between-user-and-use-objects" title="Permalink to this headline">¶</a></h4>
<p>A subclass of <tt class="docutils literal"><span class="pre">User</span></tt> can choose between incorporating its <tt class="docutils literal"><span class="pre">Use</span></tt> objects or
refer to them out-of-line by means of a pointer.  A mixed variant (some <tt class="docutils literal"><span class="pre">Use</span></tt>
s inline others hung off) is impractical and breaks the invariant that the
<tt class="docutils literal"><span class="pre">Use</span></tt> objects belonging to the same <tt class="docutils literal"><span class="pre">User</span></tt> form a contiguous array.</p>
<p>We have 2 different layouts in the <tt class="docutils literal"><span class="pre">User</span></tt> (sub)classes:</p>
<ul>
<li><p class="first">Layout a)</p>
<p>The <tt class="docutils literal"><span class="pre">Use</span></tt> object(s) are inside (resp. at fixed offset) of the <tt class="docutils literal"><span class="pre">User</span></tt>
object and there are a fixed number of them.</p>
</li>
<li><p class="first">Layout b)</p>
<p>The <tt class="docutils literal"><span class="pre">Use</span></tt> object(s) are referenced by a pointer to an array from the
<tt class="docutils literal"><span class="pre">User</span></tt> object and there may be a variable number of them.</p>
</li>
</ul>
<p>As of v2.4 each layout still possesses a direct pointer to the start of the
array of <tt class="docutils literal"><span class="pre">Use</span></tt>s.  Though not mandatory for layout a), we stick to this
redundancy for the sake of simplicity.  The <tt class="docutils literal"><span class="pre">User</span></tt> object also stores the
number of <tt class="docutils literal"><span class="pre">Use</span></tt> objects it has. (Theoretically this information can also be
calculated given the scheme presented below.)</p>
<p>Special forms of allocation operators (<tt class="docutils literal"><span class="pre">operator</span> <span class="pre">new</span></tt>) enforce the following
memory layouts:</p>
<ul>
<li><p class="first">Layout a) is modelled by prepending the <tt class="docutils literal"><span class="pre">User</span></tt> object by the <tt class="docutils literal"><span class="pre">Use[]</span></tt>
array.</p>
<div class="highlight-none"><div class="highlight"><pre>...---.---.---.---.-------...
  | P | P | P | P | User
&#39;&#39;&#39;---&#39;---&#39;---&#39;---&#39;-------&#39;&#39;&#39;
</pre></div>
</div>
</li>
<li><p class="first">Layout b) is modelled by pointing at the <tt class="docutils literal"><span class="pre">Use[]</span></tt> array.</p>
<div class="highlight-none"><div class="highlight"><pre>.-------...
| User
&#39;-------&#39;&#39;&#39;
    |
    v
    .---.---.---.---...
    | P | P | P | P |
    &#39;---&#39;---&#39;---&#39;---&#39;&#39;&#39;
</pre></div>
</div>
</li>
</ul>
<p><em>(In the above figures</em> &#8216;<tt class="docutils literal"><span class="pre">P</span></tt>&#8216; <em>stands for the</em> <tt class="docutils literal"><span class="pre">Use**</span></tt> <em>that is stored in
each</em> <tt class="docutils literal"><span class="pre">Use</span></tt> <em>object in the member</em> <tt class="docutils literal"><span class="pre">Use::Prev</span></tt> <em>)</em></p>
</div>
<div class="section" id="the-waymarking-algorithm">
<span id="waymarking"></span><h4><a class="toc-backref" href="#id99">The waymarking algorithm</a><a class="headerlink" href="#the-waymarking-algorithm" title="Permalink to this headline">¶</a></h4>
<p>Since the <tt class="docutils literal"><span class="pre">Use</span></tt> objects are deprived of the direct (back)pointer to their
<tt class="docutils literal"><span class="pre">User</span></tt> objects, there must be a fast and exact method to recover it.  This is
accomplished by the following scheme:</p>
<p>A bit-encoding in the 2 LSBits (least significant bits) of the <tt class="docutils literal"><span class="pre">Use::Prev</span></tt>
allows to find the start of the <tt class="docutils literal"><span class="pre">User</span></tt> object:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">00</span></tt> &#8212; binary digit 0</li>
<li><tt class="docutils literal"><span class="pre">01</span></tt> &#8212; binary digit 1</li>
<li><tt class="docutils literal"><span class="pre">10</span></tt> &#8212; stop and calculate (<tt class="docutils literal"><span class="pre">s</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">11</span></tt> &#8212; full stop (<tt class="docutils literal"><span class="pre">S</span></tt>)</li>
</ul>
<p>Given a <tt class="docutils literal"><span class="pre">Use*</span></tt>, all we have to do is to walk till we get a stop and we either
have a <tt class="docutils literal"><span class="pre">User</span></tt> immediately behind or we have to walk to the next stop picking
up digits and calculating the offset:</p>
<div class="highlight-none"><div class="highlight"><pre>.---.---.---.---.---.---.---.---.---.---.---.---.---.---.---.---.----------------
| 1 | s | 1 | 0 | 1 | 0 | s | 1 | 1 | 0 | s | 1 | 1 | s | 1 | S | User (or User*)
&#39;---&#39;---&#39;---&#39;---&#39;---&#39;---&#39;---&#39;---&#39;---&#39;---&#39;---&#39;---&#39;---&#39;---&#39;---&#39;---&#39;----------------
    |+15                |+10            |+6         |+3     |+1
    |                   |               |           |       | __&gt;
    |                   |               |           | __________&gt;
    |                   |               | ______________________&gt;
    |                   | ______________________________________&gt;
    | __________________________________________________________&gt;
</pre></div>
</div>
<p>Only the significant number of bits need to be stored between the stops, so that
the <em>worst case is 20 memory accesses</em> when there are 1000 <tt class="docutils literal"><span class="pre">Use</span></tt> objects
associated with a <tt class="docutils literal"><span class="pre">User</span></tt>.</p>
</div>
<div class="section" id="reference-implementation">
<span id="referenceimpl"></span><h4><a class="toc-backref" href="#id100">Reference implementation</a><a class="headerlink" href="#reference-implementation" title="Permalink to this headline">¶</a></h4>
<p>The following literate Haskell fragment demonstrates the concept:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Test.QuickCheck</span>
<span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="n">digits</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="n">digits</span> <span class="mi">0</span> <span class="n">acc</span> <span class="ow">=</span> <span class="sc">&#39;0&#39;</span> <span class="kt">:</span> <span class="n">acc</span>
<span class="o">&gt;</span> <span class="n">digits</span> <span class="mi">1</span> <span class="n">acc</span> <span class="ow">=</span> <span class="sc">&#39;1&#39;</span> <span class="kt">:</span> <span class="n">acc</span>
<span class="o">&gt;</span> <span class="n">digits</span> <span class="n">n</span> <span class="n">acc</span> <span class="ow">=</span> <span class="n">digits</span> <span class="p">(</span><span class="n">n</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">2</span><span class="p">)</span> <span class="o">$</span> <span class="n">digits</span> <span class="p">(</span><span class="n">n</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">2</span><span class="p">)</span> <span class="n">acc</span>
<span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="n">dist</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="n">dist</span> <span class="mi">0</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="p">[</span><span class="sc">&#39;S&#39;</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="n">dist</span> <span class="mi">0</span> <span class="n">acc</span> <span class="ow">=</span> <span class="n">acc</span>
<span class="o">&gt;</span> <span class="n">dist</span> <span class="mi">1</span> <span class="n">acc</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">dist</span> <span class="mi">0</span> <span class="n">acc</span> <span class="kr">in</span> <span class="n">&#39;s&#39;</span> <span class="kt">:</span> <span class="n">digits</span> <span class="p">(</span><span class="n">length</span> <span class="n">r</span><span class="p">)</span> <span class="n">r</span>
<span class="o">&gt;</span> <span class="n">dist</span> <span class="n">n</span> <span class="n">acc</span> <span class="ow">=</span> <span class="n">dist</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">$</span> <span class="n">dist</span> <span class="mi">1</span> <span class="n">acc</span>
<span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="n">takeLast</span> <span class="n">n</span> <span class="n">ss</span> <span class="ow">=</span> <span class="n">reverse</span> <span class="o">$</span> <span class="n">take</span> <span class="n">n</span> <span class="o">$</span> <span class="n">reverse</span> <span class="n">ss</span>
<span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="n">test</span> <span class="ow">=</span> <span class="n">takeLast</span> <span class="mi">40</span> <span class="o">$</span> <span class="n">dist</span> <span class="mi">20</span> <span class="kt">[]</span>
<span class="o">&gt;</span>
</pre></div>
</div>
<p>Printing &lt;test&gt; gives: <tt class="docutils literal"><span class="pre">&quot;1s100000s11010s10100s1111s1010s110s11s1S&quot;</span></tt></p>
<p>The reverse algorithm computes the length of the string just by examining a
certain prefix:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">&gt;</span> <span class="n">pref</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="o">&gt;</span> <span class="n">pref</span> <span class="s">&quot;S&quot;</span> <span class="ow">=</span> <span class="mi">1</span>
<span class="o">&gt;</span> <span class="n">pref</span> <span class="p">(</span><span class="n">&#39;s&#39;</span><span class="kt">:</span><span class="sc">&#39;1&#39;</span><span class="kt">:</span><span class="n">rest</span><span class="p">)</span> <span class="ow">=</span> <span class="n">decode</span> <span class="mi">2</span> <span class="mi">1</span> <span class="n">rest</span>
<span class="o">&gt;</span> <span class="n">pref</span> <span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="n">rest</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">pref</span> <span class="n">rest</span>
<span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="n">decode</span> <span class="n">walk</span> <span class="n">acc</span> <span class="p">(</span><span class="sc">&#39;0&#39;</span><span class="kt">:</span><span class="n">rest</span><span class="p">)</span> <span class="ow">=</span> <span class="n">decode</span> <span class="p">(</span><span class="n">walk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">acc</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="n">rest</span>
<span class="o">&gt;</span> <span class="n">decode</span> <span class="n">walk</span> <span class="n">acc</span> <span class="p">(</span><span class="sc">&#39;1&#39;</span><span class="kt">:</span><span class="n">rest</span><span class="p">)</span> <span class="ow">=</span> <span class="n">decode</span> <span class="p">(</span><span class="n">walk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">acc</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">rest</span>
<span class="o">&gt;</span> <span class="n">decode</span> <span class="n">walk</span> <span class="n">acc</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">walk</span> <span class="o">+</span> <span class="n">acc</span>
<span class="o">&gt;</span>
</pre></div>
</div>
<p>Now, as expected, printing &lt;pref test&gt; gives <tt class="docutils literal"><span class="pre">40</span></tt>.</p>
<p>We can <em>quickCheck</em> this with following property:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">&gt;</span> <span class="n">testcase</span> <span class="ow">=</span> <span class="n">dist</span> <span class="mi">2000</span> <span class="kt">[]</span>
<span class="o">&gt;</span> <span class="n">testcaseLength</span> <span class="ow">=</span> <span class="n">length</span> <span class="n">testcase</span>
<span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="n">identityProp</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">testcaseLength</span> <span class="o">==&gt;</span> <span class="n">length</span> <span class="n">arr</span> <span class="o">==</span> <span class="n">pref</span> <span class="n">arr</span>
<span class="o">&gt;</span>     <span class="kr">where</span> <span class="n">arr</span> <span class="ow">=</span> <span class="n">takeLast</span> <span class="n">n</span> <span class="n">testcase</span>
<span class="o">&gt;</span>
</pre></div>
</div>
<p>As expected &lt;quickCheck identityProp&gt; gives:</p>
<div class="highlight-python"><pre>*Main&gt; quickCheck identityProp
OK, passed 100 tests.</pre>
</div>
<p>Let&#8217;s be a bit more exhaustive:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="n">deepCheck</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">check</span> <span class="p">(</span><span class="n">defaultConfig</span> <span class="p">{</span> <span class="n">configMaxTest</span> <span class="ow">=</span> <span class="mi">500</span> <span class="p">})</span> <span class="n">p</span>
<span class="o">&gt;</span>
</pre></div>
</div>
<p>And here is the result of &lt;deepCheck identityProp&gt;:</p>
<div class="highlight-python"><pre>*Main&gt; deepCheck identityProp
OK, passed 500 tests.</pre>
</div>
</div>
<div class="section" id="tagging-considerations">
<span id="tagging"></span><h4><a class="toc-backref" href="#id101">Tagging considerations</a><a class="headerlink" href="#tagging-considerations" title="Permalink to this headline">¶</a></h4>
<p>To maintain the invariant that the 2 LSBits of each <tt class="docutils literal"><span class="pre">Use**</span></tt> in <tt class="docutils literal"><span class="pre">Use</span></tt> never
change after being set up, setters of <tt class="docutils literal"><span class="pre">Use::Prev</span></tt> must re-tag the new
<tt class="docutils literal"><span class="pre">Use**</span></tt> on every modification.  Accordingly getters must strip the tag bits.</p>
<p>For layout b) instead of the <tt class="docutils literal"><span class="pre">User</span></tt> we find a pointer (<tt class="docutils literal"><span class="pre">User*</span></tt> with LSBit
set).  Following this pointer brings us to the <tt class="docutils literal"><span class="pre">User</span></tt>.  A portable trick
ensures that the first bytes of <tt class="docutils literal"><span class="pre">User</span></tt> (if interpreted as a pointer) never has
the LSBit set. (Portability is relying on the fact that all known compilers
place the <tt class="docutils literal"><span class="pre">vptr</span></tt> in the first word of the instances.)</p>
</div>
</div>
</div>
<div class="section" id="the-core-llvm-class-hierarchy-reference">
<span id="coreclasses"></span><h2><a class="toc-backref" href="#id102">The Core LLVM Class Hierarchy Reference</a><a class="headerlink" href="#the-core-llvm-class-hierarchy-reference" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">#include</span> <span class="pre">&quot;llvm/IR/Type.h&quot;</span></tt></p>
<p>header source: <a class="reference external" href="http://llvm.org/doxygen/Type_8h-source.html">Type.h</a></p>
<p>doxygen info: <a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Type.html">Type Clases</a></p>
<p>The Core LLVM classes are the primary means of representing the program being
inspected or transformed.  The core LLVM classes are defined in header files in
the <tt class="docutils literal"><span class="pre">include/llvm/</span></tt> directory, and implemented in the <tt class="docutils literal"><span class="pre">lib/VMCore</span></tt>
directory.</p>
<div class="section" id="the-type-class-and-derived-types">
<span id="type"></span><h3><a class="toc-backref" href="#id103">The Type class and Derived Types</a><a class="headerlink" href="#the-type-class-and-derived-types" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">Type</span></tt> is a superclass of all type classes.  Every <tt class="docutils literal"><span class="pre">Value</span></tt> has a <tt class="docutils literal"><span class="pre">Type</span></tt>.
<tt class="docutils literal"><span class="pre">Type</span></tt> cannot be instantiated directly but only through its subclasses.
Certain primitive types (<tt class="docutils literal"><span class="pre">VoidType</span></tt>, <tt class="docutils literal"><span class="pre">LabelType</span></tt>, <tt class="docutils literal"><span class="pre">FloatType</span></tt> and
<tt class="docutils literal"><span class="pre">DoubleType</span></tt>) have hidden subclasses.  They are hidden because they offer no
useful functionality beyond what the <tt class="docutils literal"><span class="pre">Type</span></tt> class offers except to distinguish
themselves from other subclasses of <tt class="docutils literal"><span class="pre">Type</span></tt>.</p>
<p>All other types are subclasses of <tt class="docutils literal"><span class="pre">DerivedType</span></tt>.  Types can be named, but this
is not a requirement.  There exists exactly one instance of a given shape at any
one time.  This allows type equality to be performed with address equality of
the Type Instance.  That is, given two <tt class="docutils literal"><span class="pre">Type*</span></tt> values, the types are identical
if the pointers are identical.</p>
<div class="section" id="important-public-methods">
<span id="m-type"></span><h4><a class="toc-backref" href="#id104">Important Public Methods</a><a class="headerlink" href="#important-public-methods" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">isIntegerTy()</span> <span class="pre">const</span></tt>: Returns true for any integer type.</li>
<li><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">isFloatingPointTy()</span></tt>: Return true if this is one of the five
floating point types.</li>
<li><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">isSized()</span></tt>: Return true if the type has known size.  Things
that don&#8217;t have a size are abstract types, labels and void.</li>
</ul>
</div>
<div class="section" id="important-derived-types">
<span id="derivedtypes"></span><h4><a class="toc-backref" href="#id105">Important Derived Types</a><a class="headerlink" href="#important-derived-types" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">IntegerType</span></tt></dt>
<dd><p class="first">Subclass of DerivedType that represents integer types of any bit width.  Any
bit width between <tt class="docutils literal"><span class="pre">IntegerType::MIN_INT_BITS</span></tt> (1) and
<tt class="docutils literal"><span class="pre">IntegerType::MAX_INT_BITS</span></tt> (~8 million) can be represented.</p>
<ul class="last simple">
<li><tt class="docutils literal"><span class="pre">static</span> <span class="pre">const</span> <span class="pre">IntegerType*</span> <span class="pre">get(unsigned</span> <span class="pre">NumBits)</span></tt>: get an integer
type of a specific bit width.</li>
<li><tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">getBitWidth()</span> <span class="pre">const</span></tt>: Get the bit width of an integer type.</li>
</ul>
</dd>
<dt><tt class="docutils literal"><span class="pre">SequentialType</span></tt></dt>
<dd><p class="first">This is subclassed by ArrayType, PointerType and VectorType.</p>
<ul class="last simple">
<li><tt class="docutils literal"><span class="pre">const</span> <span class="pre">Type</span> <span class="pre">*</span> <span class="pre">getElementType()</span> <span class="pre">const</span></tt>: Returns the type of each
of the elements in the sequential type.</li>
</ul>
</dd>
<dt><tt class="docutils literal"><span class="pre">ArrayType</span></tt></dt>
<dd><p class="first">This is a subclass of SequentialType and defines the interface for array
types.</p>
<ul class="last simple">
<li><tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">getNumElements()</span> <span class="pre">const</span></tt>: Returns the number of elements
in the array.</li>
</ul>
</dd>
<dt><tt class="docutils literal"><span class="pre">PointerType</span></tt></dt>
<dd>Subclass of SequentialType for pointer types.</dd>
<dt><tt class="docutils literal"><span class="pre">VectorType</span></tt></dt>
<dd>Subclass of SequentialType for vector types.  A vector type is similar to an
ArrayType but is distinguished because it is a first class type whereas
ArrayType is not.  Vector types are used for vector operations and are usually
small vectors of of an integer or floating point type.</dd>
<dt><tt class="docutils literal"><span class="pre">StructType</span></tt></dt>
<dd>Subclass of DerivedTypes for struct types.</dd>
</dl>
<dl class="docutils" id="functiontype">
<dt><tt class="docutils literal"><span class="pre">FunctionType</span></tt></dt>
<dd><p class="first">Subclass of DerivedTypes for function types.</p>
<ul class="last simple">
<li><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">isVarArg()</span> <span class="pre">const</span></tt>: Returns true if it&#8217;s a vararg function.</li>
<li><tt class="docutils literal"><span class="pre">const</span> <span class="pre">Type</span> <span class="pre">*</span> <span class="pre">getReturnType()</span> <span class="pre">const</span></tt>: Returns the return type of the
function.</li>
<li><tt class="docutils literal"><span class="pre">const</span> <span class="pre">Type</span> <span class="pre">*</span> <span class="pre">getParamType</span> <span class="pre">(unsigned</span> <span class="pre">i)</span></tt>: Returns the type of the ith
parameter.</li>
<li><tt class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">getNumParams()</span> <span class="pre">const</span></tt>: Returns the number of formal
parameters.</li>
</ul>
</dd>
</dl>
</div>
</div>
<div class="section" id="the-module-class">
<span id="module"></span><h3><a class="toc-backref" href="#id106">The <tt class="docutils literal"><span class="pre">Module</span></tt> class</a><a class="headerlink" href="#the-module-class" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">#include</span> <span class="pre">&quot;llvm/IR/Module.h&quot;</span></tt></p>
<p>header source: <a class="reference external" href="http://llvm.org/doxygen/Module_8h-source.html">Module.h</a></p>
<p>doxygen info: <a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Module.html">Module Class</a></p>
<p>The <tt class="docutils literal"><span class="pre">Module</span></tt> class represents the top level structure present in LLVM
programs.  An LLVM module is effectively either a translation unit of the
original program or a combination of several translation units merged by the
linker.  The <tt class="docutils literal"><span class="pre">Module</span></tt> class keeps track of a list of <a class="reference internal" href="#c-function"><em>Function</em></a>s, a list of <a class="reference internal" href="#globalvariable">GlobalVariable</a>s, and a <a class="reference internal" href="#symboltable">SymbolTable</a>.
Additionally, it contains a few helpful member functions that try to make common
operations easy.</p>
<div class="section" id="important-public-members-of-the-module-class">
<span id="m-module"></span><h4><a class="toc-backref" href="#id107">Important Public Members of the <tt class="docutils literal"><span class="pre">Module</span></tt> class</a><a class="headerlink" href="#important-public-members-of-the-module-class" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">Module::Module(std::string</span> <span class="pre">name</span> <span class="pre">=</span> <span class="pre">&quot;&quot;)</span></tt></p>
<p>Constructing a <a class="reference internal" href="#module">Module</a> is easy.  You can optionally provide a name for it
(probably based on the name of the translation unit).</p>
</li>
<li><div class="first line-block">
<div class="line"><tt class="docutils literal"><span class="pre">Module::iterator</span></tt> - Typedef for function list iterator</div>
<div class="line"><tt class="docutils literal"><span class="pre">Module::const_iterator</span></tt> - Typedef for const_iterator.</div>
<div class="line"><tt class="docutils literal"><span class="pre">begin()</span></tt>, <tt class="docutils literal"><span class="pre">end()</span></tt>, <tt class="docutils literal"><span class="pre">size()</span></tt>, <tt class="docutils literal"><span class="pre">empty()</span></tt></div>
</div>
<p>These are forwarding methods that make it easy to access the contents of a
<tt class="docutils literal"><span class="pre">Module</span></tt> object&#8217;s <a class="reference internal" href="#c-function"><em>Function</em></a> list.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Module::FunctionListType</span> <span class="pre">&amp;getFunctionList()</span></tt></p>
<p>Returns the list of <a class="reference internal" href="#c-function"><em>Function</em></a>s.  This is necessary to use
when you need to update the list or perform a complex action that doesn&#8217;t have
a forwarding method.</p>
</li>
</ul>
<hr class="docutils" />
<ul>
<li><div class="first line-block">
<div class="line"><tt class="docutils literal"><span class="pre">Module::global_iterator</span></tt> - Typedef for global variable list iterator</div>
<div class="line"><tt class="docutils literal"><span class="pre">Module::const_global_iterator</span></tt> - Typedef for const_iterator.</div>
<div class="line"><tt class="docutils literal"><span class="pre">global_begin()</span></tt>, <tt class="docutils literal"><span class="pre">global_end()</span></tt>, <tt class="docutils literal"><span class="pre">global_size()</span></tt>, <tt class="docutils literal"><span class="pre">global_empty()</span></tt></div>
</div>
<p>These are forwarding methods that make it easy to access the contents of a
<tt class="docutils literal"><span class="pre">Module</span></tt> object&#8217;s <a class="reference internal" href="#globalvariable">GlobalVariable</a> list.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Module::GlobalListType</span> <span class="pre">&amp;getGlobalList()</span></tt></p>
<p>Returns the list of <a class="reference internal" href="#globalvariable">GlobalVariable</a>s.  This is necessary to use when you
need to update the list or perform a complex action that doesn&#8217;t have a
forwarding method.</p>
</li>
</ul>
<hr class="docutils" />
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">SymbolTable</span> <span class="pre">*getSymbolTable()</span></tt></p>
<p>Return a reference to the <a class="reference internal" href="#symboltable">SymbolTable</a> for this <tt class="docutils literal"><span class="pre">Module</span></tt>.</p>
</li>
</ul>
<hr class="docutils" />
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">Function</span> <span class="pre">*getFunction(StringRef</span> <span class="pre">Name)</span> <span class="pre">const</span></tt></p>
<p>Look up the specified function in the <tt class="docutils literal"><span class="pre">Module</span></tt> <a class="reference internal" href="#symboltable">SymbolTable</a>.  If it does not
exist, return <tt class="docutils literal"><span class="pre">null</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Function</span> <span class="pre">*getOrInsertFunction(const</span> <span class="pre">std::string</span> <span class="pre">&amp;Name,</span> <span class="pre">const</span> <span class="pre">FunctionType</span>
<span class="pre">*T)</span></tt></p>
<p>Look up the specified function in the <tt class="docutils literal"><span class="pre">Module</span></tt> <a class="reference internal" href="#symboltable">SymbolTable</a>.  If it does not
exist, add an external declaration for the function and return it.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">std::string</span> <span class="pre">getTypeName(const</span> <span class="pre">Type</span> <span class="pre">*Ty)</span></tt></p>
<p>If there is at least one entry in the <a class="reference internal" href="#symboltable">SymbolTable</a> for the specified <a class="reference internal" href="#type">Type</a>,
return it.  Otherwise return the empty string.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">addTypeName(const</span> <span class="pre">std::string</span> <span class="pre">&amp;Name,</span> <span class="pre">const</span> <span class="pre">Type</span> <span class="pre">*Ty)</span></tt></p>
<p>Insert an entry in the <a class="reference internal" href="#symboltable">SymbolTable</a> mapping <tt class="docutils literal"><span class="pre">Name</span></tt> to <tt class="docutils literal"><span class="pre">Ty</span></tt>.  If there is
already an entry for this name, true is returned and the <a class="reference internal" href="#symboltable">SymbolTable</a> is not
modified.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="the-value-class">
<span id="value"></span><h3><a class="toc-backref" href="#id108">The <tt class="docutils literal"><span class="pre">Value</span></tt> class</a><a class="headerlink" href="#the-value-class" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">#include</span> <span class="pre">&quot;llvm/IR/Value.h&quot;</span></tt></p>
<p>header source: <a class="reference external" href="http://llvm.org/doxygen/Value_8h-source.html">Value.h</a></p>
<p>doxygen info: <a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Value.html">Value Class</a></p>
<p>The <tt class="docutils literal"><span class="pre">Value</span></tt> class is the most important class in the LLVM Source base.  It
represents a typed value that may be used (among other things) as an operand to
an instruction.  There are many different types of <tt class="docutils literal"><span class="pre">Value</span></tt>s, such as
<a class="reference internal" href="#constant">Constant</a>s, <a class="reference internal" href="#argument">Argument</a>s.  Even <a class="reference internal" href="#instruction">Instruction</a>s and <a class="reference internal" href="#c-function"><em>Function</em></a>s are <tt class="docutils literal"><span class="pre">Value</span></tt>s.</p>
<p>A particular <tt class="docutils literal"><span class="pre">Value</span></tt> may be used many times in the LLVM representation for a
program.  For example, an incoming argument to a function (represented with an
instance of the <a class="reference internal" href="#argument">Argument</a> class) is &#8220;used&#8221; by every instruction in the function
that references the argument.  To keep track of this relationship, the <tt class="docutils literal"><span class="pre">Value</span></tt>
class keeps a list of all of the <tt class="docutils literal"><span class="pre">User</span></tt>s that is using it (the <a class="reference internal" href="#user">User</a> class
is a base class for all nodes in the LLVM graph that can refer to <tt class="docutils literal"><span class="pre">Value</span></tt>s).
This use list is how LLVM represents def-use information in the program, and is
accessible through the <tt class="docutils literal"><span class="pre">use_*</span></tt> methods, shown below.</p>
<p>Because LLVM is a typed representation, every LLVM <tt class="docutils literal"><span class="pre">Value</span></tt> is typed, and this
<a class="reference internal" href="#type">Type</a> is available through the <tt class="docutils literal"><span class="pre">getType()</span></tt> method.  In addition, all LLVM
values can be named.  The &#8220;name&#8221; of the <tt class="docutils literal"><span class="pre">Value</span></tt> is a symbolic string printed
in the LLVM code:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span class="nv">%foo</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span>
</pre></div>
</div>
<p id="namewarning">The name of this instruction is &#8220;foo&#8221;. <strong>NOTE</strong> that the name of any value may
be missing (an empty string), so names should <strong>ONLY</strong> be used for debugging
(making the source code easier to read, debugging printouts), they should not be
used to keep track of values or map between them.  For this purpose, use a
<tt class="docutils literal"><span class="pre">std::map</span></tt> of pointers to the <tt class="docutils literal"><span class="pre">Value</span></tt> itself instead.</p>
<p>One important aspect of LLVM is that there is no distinction between an SSA
variable and the operation that produces it.  Because of this, any reference to
the value produced by an instruction (or the value available as an incoming
argument, for example) is represented as a direct pointer to the instance of the
class that represents this value.  Although this may take some getting used to,
it simplifies the representation and makes it easier to manipulate.</p>
<div class="section" id="important-public-members-of-the-value-class">
<span id="m-value"></span><h4><a class="toc-backref" href="#id109">Important Public Members of the <tt class="docutils literal"><span class="pre">Value</span></tt> class</a><a class="headerlink" href="#important-public-members-of-the-value-class" title="Permalink to this headline">¶</a></h4>
<ul>
<li><div class="first line-block">
<div class="line"><tt class="docutils literal"><span class="pre">Value::use_iterator</span></tt> - Typedef for iterator over the use-list</div>
<div class="line"><tt class="docutils literal"><span class="pre">Value::const_use_iterator</span></tt> - Typedef for const_iterator over the
use-list</div>
<div class="line"><tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">use_size()</span></tt> - Returns the number of users of the value.</div>
<div class="line"><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">use_empty()</span></tt> - Returns true if there are no users.</div>
<div class="line"><tt class="docutils literal"><span class="pre">use_iterator</span> <span class="pre">use_begin()</span></tt> - Get an iterator to the start of the
use-list.</div>
<div class="line"><tt class="docutils literal"><span class="pre">use_iterator</span> <span class="pre">use_end()</span></tt> - Get an iterator to the end of the use-list.</div>
<div class="line"><tt class="docutils literal"><span class="pre">User</span> <span class="pre">*use_back()</span></tt> - Returns the last element in the list.</div>
</div>
<p>These methods are the interface to access the def-use information in LLVM.
As with all other iterators in LLVM, the naming conventions follow the
conventions defined by the <a class="reference internal" href="#stl">STL</a>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Type</span> <span class="pre">*getType()</span> <span class="pre">const</span></tt>
This method returns the Type of the Value.</p>
</li>
<li><div class="first line-block">
<div class="line"><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">hasName()</span> <span class="pre">const</span></tt></div>
<div class="line"><tt class="docutils literal"><span class="pre">std::string</span> <span class="pre">getName()</span> <span class="pre">const</span></tt></div>
<div class="line"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">setName(const</span> <span class="pre">std::string</span> <span class="pre">&amp;Name)</span></tt></div>
</div>
<p>This family of methods is used to access and assign a name to a <tt class="docutils literal"><span class="pre">Value</span></tt>, be
aware of the <a class="reference internal" href="#namewarning"><em>precaution above</em></a>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">replaceAllUsesWith(Value</span> <span class="pre">*V)</span></tt></p>
<p>This method traverses the use list of a <tt class="docutils literal"><span class="pre">Value</span></tt> changing all <a class="reference internal" href="#user">User</a>s of the
current value to refer to &#8220;<tt class="docutils literal"><span class="pre">V</span></tt>&#8221; instead.  For example, if you detect that an
instruction always produces a constant value (for example through constant
folding), you can replace all uses of the instruction with the constant like
this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Inst</span><span class="o">-&gt;</span><span class="n">replaceAllUsesWith</span><span class="p">(</span><span class="n">ConstVal</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="the-user-class">
<span id="user"></span><h3><a class="toc-backref" href="#id110">The <tt class="docutils literal"><span class="pre">User</span></tt> class</a><a class="headerlink" href="#the-user-class" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">#include</span> <span class="pre">&quot;llvm/IR/User.h&quot;</span></tt></p>
<p>header source: <a class="reference external" href="http://llvm.org/doxygen/User_8h-source.html">User.h</a></p>
<p>doxygen info: <a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1User.html">User Class</a></p>
<p>Superclass: <a class="reference internal" href="#value">Value</a></p>
<p>The <tt class="docutils literal"><span class="pre">User</span></tt> class is the common base class of all LLVM nodes that may refer to
<tt class="docutils literal"><span class="pre">Value</span></tt>s.  It exposes a list of &#8220;Operands&#8221; that are all of the <tt class="docutils literal"><span class="pre">Value</span></tt>s
that the User is referring to.  The <tt class="docutils literal"><span class="pre">User</span></tt> class itself is a subclass of
<tt class="docutils literal"><span class="pre">Value</span></tt>.</p>
<p>The operands of a <tt class="docutils literal"><span class="pre">User</span></tt> point directly to the LLVM <tt class="docutils literal"><span class="pre">Value</span></tt> that it refers
to.  Because LLVM uses Static Single Assignment (SSA) form, there can only be
one definition referred to, allowing this direct connection.  This connection
provides the use-def information in LLVM.</p>
<div class="section" id="important-public-members-of-the-user-class">
<span id="m-user"></span><h4><a class="toc-backref" href="#id111">Important Public Members of the <tt class="docutils literal"><span class="pre">User</span></tt> class</a><a class="headerlink" href="#important-public-members-of-the-user-class" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="docutils literal"><span class="pre">User</span></tt> class exposes the operand list in two ways: through an index access
interface and through an iterator based interface.</p>
<ul>
<li><div class="first line-block">
<div class="line"><tt class="docutils literal"><span class="pre">Value</span> <span class="pre">*getOperand(unsigned</span> <span class="pre">i)</span></tt></div>
<div class="line"><tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">getNumOperands()</span></tt></div>
</div>
<p>These two methods expose the operands of the <tt class="docutils literal"><span class="pre">User</span></tt> in a convenient form for
direct access.</p>
</li>
<li><div class="first line-block">
<div class="line"><tt class="docutils literal"><span class="pre">User::op_iterator</span></tt> - Typedef for iterator over the operand list</div>
<div class="line"><tt class="docutils literal"><span class="pre">op_iterator</span> <span class="pre">op_begin()</span></tt> - Get an iterator to the start of the operand
list.</div>
<div class="line"><tt class="docutils literal"><span class="pre">op_iterator</span> <span class="pre">op_end()</span></tt> - Get an iterator to the end of the operand list.</div>
</div>
<p>Together, these methods make up the iterator based interface to the operands
of a <tt class="docutils literal"><span class="pre">User</span></tt>.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="the-instruction-class">
<span id="instruction"></span><h3><a class="toc-backref" href="#id112">The <tt class="docutils literal"><span class="pre">Instruction</span></tt> class</a><a class="headerlink" href="#the-instruction-class" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">#include</span> <span class="pre">&quot;llvm/IR/Instruction.h&quot;</span></tt></p>
<p>header source: <a class="reference external" href="http://llvm.org/doxygen/Instruction_8h-source.html">Instruction.h</a></p>
<p>doxygen info: <a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Instruction.html">Instruction Class</a></p>
<p>Superclasses: <a class="reference internal" href="#user">User</a>, <a class="reference internal" href="#value">Value</a></p>
<p>The <tt class="docutils literal"><span class="pre">Instruction</span></tt> class is the common base class for all LLVM instructions.
It provides only a few methods, but is a very commonly used class.  The primary
data tracked by the <tt class="docutils literal"><span class="pre">Instruction</span></tt> class itself is the opcode (instruction
type) and the parent <a class="reference internal" href="#basicblock">BasicBlock</a> the <tt class="docutils literal"><span class="pre">Instruction</span></tt> is embedded into.  To
represent a specific type of instruction, one of many subclasses of
<tt class="docutils literal"><span class="pre">Instruction</span></tt> are used.</p>
<p>Because the <tt class="docutils literal"><span class="pre">Instruction</span></tt> class subclasses the <a class="reference internal" href="#user">User</a> class, its operands can
be accessed in the same way as for other <tt class="docutils literal"><span class="pre">User</span></tt>s (with the
<tt class="docutils literal"><span class="pre">getOperand()</span></tt>/<tt class="docutils literal"><span class="pre">getNumOperands()</span></tt> and <tt class="docutils literal"><span class="pre">op_begin()</span></tt>/<tt class="docutils literal"><span class="pre">op_end()</span></tt> methods).
An important file for the <tt class="docutils literal"><span class="pre">Instruction</span></tt> class is the <tt class="docutils literal"><span class="pre">llvm/Instruction.def</span></tt>
file.  This file contains some meta-data about the various different types of
instructions in LLVM.  It describes the enum values that are used as opcodes
(for example <tt class="docutils literal"><span class="pre">Instruction::Add</span></tt> and <tt class="docutils literal"><span class="pre">Instruction::ICmp</span></tt>), as well as the
concrete sub-classes of <tt class="docutils literal"><span class="pre">Instruction</span></tt> that implement the instruction (for
example <a class="reference internal" href="#binaryoperator">BinaryOperator</a> and <a class="reference internal" href="#cmpinst">CmpInst</a>).  Unfortunately, the use of macros in this
file confuses doxygen, so these enum values don&#8217;t show up correctly in the
<a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Instruction.html">doxygen output</a>.</p>
<div class="section" id="important-subclasses-of-the-instruction-class">
<span id="s-instruction"></span><h4><a class="toc-backref" href="#id113">Important Subclasses of the <tt class="docutils literal"><span class="pre">Instruction</span></tt> class</a><a class="headerlink" href="#important-subclasses-of-the-instruction-class" title="Permalink to this headline">¶</a></h4>
<ul id="binaryoperator">
<li><p class="first"><tt class="docutils literal"><span class="pre">BinaryOperator</span></tt></p>
<p>This subclasses represents all two operand instructions whose operands must be
the same type, except for the comparison instructions.</p>
</li>
</ul>
<ul class="simple" id="castinst">
<li><tt class="docutils literal"><span class="pre">CastInst</span></tt>
This subclass is the parent of the 12 casting instructions.  It provides
common operations on cast instructions.</li>
</ul>
<ul id="cmpinst">
<li><p class="first"><tt class="docutils literal"><span class="pre">CmpInst</span></tt></p>
<p>This subclass respresents the two comparison instructions,
<a class="reference external" href="LangRef.html#i_icmp">ICmpInst</a> (integer opreands), and
<a class="reference external" href="LangRef.html#i_fcmp">FCmpInst</a> (floating point operands).</p>
</li>
</ul>
<ul id="terminatorinst">
<li><p class="first"><tt class="docutils literal"><span class="pre">TerminatorInst</span></tt></p>
<p>This subclass is the parent of all terminator instructions (those which can
terminate a block).</p>
</li>
</ul>
</div>
<div class="section" id="important-public-members-of-the-instruction-class">
<span id="m-instruction"></span><h4><a class="toc-backref" href="#id114">Important Public Members of the <tt class="docutils literal"><span class="pre">Instruction</span></tt> class</a><a class="headerlink" href="#important-public-members-of-the-instruction-class" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">BasicBlock</span> <span class="pre">*getParent()</span></tt></p>
<p>Returns the <a class="reference internal" href="#basicblock">BasicBlock</a> that this
<tt class="docutils literal"><span class="pre">Instruction</span></tt> is embedded into.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">mayWriteToMemory()</span></tt></p>
<p>Returns true if the instruction writes to memory, i.e. it is a <tt class="docutils literal"><span class="pre">call</span></tt>,
<tt class="docutils literal"><span class="pre">free</span></tt>, <tt class="docutils literal"><span class="pre">invoke</span></tt>, or <tt class="docutils literal"><span class="pre">store</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">getOpcode()</span></tt></p>
<p>Returns the opcode for the <tt class="docutils literal"><span class="pre">Instruction</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Instruction</span> <span class="pre">*clone()</span> <span class="pre">const</span></tt></p>
<p>Returns another instance of the specified instruction, identical in all ways
to the original except that the instruction has no parent (i.e. it&#8217;s not
embedded into a <a class="reference internal" href="#basicblock">BasicBlock</a>), and it has no name.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="the-constant-class-and-subclasses">
<span id="constant"></span><h3><a class="toc-backref" href="#id115">The <tt class="docutils literal"><span class="pre">Constant</span></tt> class and subclasses</a><a class="headerlink" href="#the-constant-class-and-subclasses" title="Permalink to this headline">¶</a></h3>
<p>Constant represents a base class for different types of constants.  It is
subclassed by ConstantInt, ConstantArray, etc. for representing the various
types of Constants.  <a class="reference internal" href="#globalvalue">GlobalValue</a> is also a subclass, which represents the
address of a global variable or function.</p>
<div class="section" id="important-subclasses-of-constant">
<span id="s-constant"></span><h4><a class="toc-backref" href="#id116">Important Subclasses of Constant</a><a class="headerlink" href="#important-subclasses-of-constant" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>ConstantInt : This subclass of Constant represents an integer constant of
any width.<ul>
<li><tt class="docutils literal"><span class="pre">const</span> <span class="pre">APInt&amp;</span> <span class="pre">getValue()</span> <span class="pre">const</span></tt>: Returns the underlying
value of this constant, an APInt value.</li>
<li><tt class="docutils literal"><span class="pre">int64_t</span> <span class="pre">getSExtValue()</span> <span class="pre">const</span></tt>: Converts the underlying APInt value to an
int64_t via sign extension.  If the value (not the bit width) of the APInt
is too large to fit in an int64_t, an assertion will result.  For this
reason, use of this method is discouraged.</li>
<li><tt class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">getZExtValue()</span> <span class="pre">const</span></tt>: Converts the underlying APInt value
to a uint64_t via zero extension.  IF the value (not the bit width) of the
APInt is too large to fit in a uint64_t, an assertion will result.  For this
reason, use of this method is discouraged.</li>
<li><tt class="docutils literal"><span class="pre">static</span> <span class="pre">ConstantInt*</span> <span class="pre">get(const</span> <span class="pre">APInt&amp;</span> <span class="pre">Val)</span></tt>: Returns the ConstantInt
object that represents the value provided by <tt class="docutils literal"><span class="pre">Val</span></tt>.  The type is implied
as the IntegerType that corresponds to the bit width of <tt class="docutils literal"><span class="pre">Val</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">static</span> <span class="pre">ConstantInt*</span> <span class="pre">get(const</span> <span class="pre">Type</span> <span class="pre">*Ty,</span> <span class="pre">uint64_t</span> <span class="pre">Val)</span></tt>: Returns the
ConstantInt object that represents the value provided by <tt class="docutils literal"><span class="pre">Val</span></tt> for integer
type <tt class="docutils literal"><span class="pre">Ty</span></tt>.</li>
</ul>
</li>
<li>ConstantFP : This class represents a floating point constant.<ul>
<li><tt class="docutils literal"><span class="pre">double</span> <span class="pre">getValue()</span> <span class="pre">const</span></tt>: Returns the underlying value of this constant.</li>
</ul>
</li>
<li>ConstantArray : This represents a constant array.<ul>
<li><tt class="docutils literal"><span class="pre">const</span> <span class="pre">std::vector&lt;Use&gt;</span> <span class="pre">&amp;getValues()</span> <span class="pre">const</span></tt>: Returns a vector of
component constants that makeup this array.</li>
</ul>
</li>
<li>ConstantStruct : This represents a constant struct.<ul>
<li><tt class="docutils literal"><span class="pre">const</span> <span class="pre">std::vector&lt;Use&gt;</span> <span class="pre">&amp;getValues()</span> <span class="pre">const</span></tt>: Returns a vector of
component constants that makeup this array.</li>
</ul>
</li>
<li>GlobalValue : This represents either a global variable or a function.  In
either case, the value is a constant fixed address (after linking).</li>
</ul>
</div>
</div>
<div class="section" id="the-globalvalue-class">
<span id="globalvalue"></span><h3><a class="toc-backref" href="#id117">The <tt class="docutils literal"><span class="pre">GlobalValue</span></tt> class</a><a class="headerlink" href="#the-globalvalue-class" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">#include</span> <span class="pre">&quot;llvm/IR/GlobalValue.h&quot;</span></tt></p>
<p>header source: <a class="reference external" href="http://llvm.org/doxygen/GlobalValue_8h-source.html">GlobalValue.h</a></p>
<p>doxygen info: <a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1GlobalValue.html">GlobalValue Class</a></p>
<p>Superclasses: <a class="reference internal" href="#constant">Constant</a>, <a class="reference internal" href="#user">User</a>, <a class="reference internal" href="#value">Value</a></p>
<p>Global values ( <a class="reference internal" href="#globalvariable">GlobalVariable</a>s or <a class="reference internal" href="#c-function"><em>Function</em></a>s) are the
only LLVM values that are visible in the bodies of all <a class="reference internal" href="#c-function"><em>Function</em></a>s.  Because they are visible at global scope, they are also
subject to linking with other globals defined in different translation units.
To control the linking process, <tt class="docutils literal"><span class="pre">GlobalValue</span></tt>s know their linkage rules.
Specifically, <tt class="docutils literal"><span class="pre">GlobalValue</span></tt>s know whether they have internal or external
linkage, as defined by the <tt class="docutils literal"><span class="pre">LinkageTypes</span></tt> enumeration.</p>
<p>If a <tt class="docutils literal"><span class="pre">GlobalValue</span></tt> has internal linkage (equivalent to being <tt class="docutils literal"><span class="pre">static</span></tt> in C),
it is not visible to code outside the current translation unit, and does not
participate in linking.  If it has external linkage, it is visible to external
code, and does participate in linking.  In addition to linkage information,
<tt class="docutils literal"><span class="pre">GlobalValue</span></tt>s keep track of which <a class="reference internal" href="#module">Module</a> they are currently part of.</p>
<p>Because <tt class="docutils literal"><span class="pre">GlobalValue</span></tt>s are memory objects, they are always referred to by
their <strong>address</strong>.  As such, the <a class="reference internal" href="#type">Type</a> of a global is always a pointer to its
contents.  It is important to remember this when using the <tt class="docutils literal"><span class="pre">GetElementPtrInst</span></tt>
instruction because this pointer must be dereferenced first.  For example, if
you have a <tt class="docutils literal"><span class="pre">GlobalVariable</span></tt> (a subclass of <tt class="docutils literal"><span class="pre">GlobalValue)</span></tt> that is an array
of 24 ints, type <tt class="docutils literal"><span class="pre">[24</span> <span class="pre">x</span> <span class="pre">i32]</span></tt>, then the <tt class="docutils literal"><span class="pre">GlobalVariable</span></tt> is a pointer to
that array.  Although the address of the first element of this array and the
value of the <tt class="docutils literal"><span class="pre">GlobalVariable</span></tt> are the same, they have different types.  The
<tt class="docutils literal"><span class="pre">GlobalVariable</span></tt>&#8216;s type is <tt class="docutils literal"><span class="pre">[24</span> <span class="pre">x</span> <span class="pre">i32]</span></tt>.  The first element&#8217;s type is
<tt class="docutils literal"><span class="pre">i32.</span></tt> Because of this, accessing a global value requires you to dereference
the pointer with <tt class="docutils literal"><span class="pre">GetElementPtrInst</span></tt> first, then its elements can be accessed.
This is explained in the <a class="reference external" href="LangRef.html#globalvars">LLVM Language Reference Manual</a>.</p>
<div class="section" id="important-public-members-of-the-globalvalue-class">
<span id="m-globalvalue"></span><h4><a class="toc-backref" href="#id118">Important Public Members of the <tt class="docutils literal"><span class="pre">GlobalValue</span></tt> class</a><a class="headerlink" href="#important-public-members-of-the-globalvalue-class" title="Permalink to this headline">¶</a></h4>
<ul>
<li><div class="first line-block">
<div class="line"><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">hasInternalLinkage()</span> <span class="pre">const</span></tt></div>
<div class="line"><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">hasExternalLinkage()</span> <span class="pre">const</span></tt></div>
<div class="line"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">setInternalLinkage(bool</span> <span class="pre">HasInternalLinkage)</span></tt></div>
</div>
<p>These methods manipulate the linkage characteristics of the <tt class="docutils literal"><span class="pre">GlobalValue</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Module</span> <span class="pre">*getParent()</span></tt></p>
<p>This returns the <a class="reference internal" href="#module">Module</a> that the
GlobalValue is currently embedded into.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="the-function-class">
<span id="c-function"></span><h3><a class="toc-backref" href="#id119">The <tt class="docutils literal"><span class="pre">Function</span></tt> class</a><a class="headerlink" href="#the-function-class" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">#include</span> <span class="pre">&quot;llvm/IR/Function.h&quot;</span></tt></p>
<p>header source: <a class="reference external" href="http://llvm.org/doxygen/Function_8h-source.html">Function.h</a></p>
<p>doxygen info: <a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1Function.html">Function Class</a></p>
<p>Superclasses: <a class="reference internal" href="#globalvalue">GlobalValue</a>, <a class="reference internal" href="#constant">Constant</a>, <a class="reference internal" href="#user">User</a>, <a class="reference internal" href="#value">Value</a></p>
<p>The <tt class="docutils literal"><span class="pre">Function</span></tt> class represents a single procedure in LLVM.  It is actually
one of the more complex classes in the LLVM hierarchy because it must keep track
of a large amount of data.  The <tt class="docutils literal"><span class="pre">Function</span></tt> class keeps track of a list of
<a class="reference internal" href="#basicblock">BasicBlock</a>s, a list of formal <a class="reference internal" href="#argument">Argument</a>s, and a <a class="reference internal" href="#symboltable">SymbolTable</a>.</p>
<p>The list of <a class="reference internal" href="#basicblock">BasicBlock</a>s is the most commonly used part of <tt class="docutils literal"><span class="pre">Function</span></tt>
objects.  The list imposes an implicit ordering of the blocks in the function,
which indicate how the code will be laid out by the backend.  Additionally, the
first <a class="reference internal" href="#basicblock">BasicBlock</a> is the implicit entry node for the <tt class="docutils literal"><span class="pre">Function</span></tt>.  It is not
legal in LLVM to explicitly branch to this initial block.  There are no implicit
exit nodes, and in fact there may be multiple exit nodes from a single
<tt class="docutils literal"><span class="pre">Function</span></tt>.  If the <a class="reference internal" href="#basicblock">BasicBlock</a> list is empty, this indicates that the
<tt class="docutils literal"><span class="pre">Function</span></tt> is actually a function declaration: the actual body of the function
hasn&#8217;t been linked in yet.</p>
<p>In addition to a list of <a class="reference internal" href="#basicblock">BasicBlock</a>s, the <tt class="docutils literal"><span class="pre">Function</span></tt> class also keeps track
of the list of formal <a class="reference internal" href="#argument">Argument</a>s that the function receives.  This container
manages the lifetime of the <a class="reference internal" href="#argument">Argument</a> nodes, just like the <a class="reference internal" href="#basicblock">BasicBlock</a> list does
for the <a class="reference internal" href="#basicblock">BasicBlock</a>s.</p>
<p>The <a class="reference internal" href="#symboltable">SymbolTable</a> is a very rarely used LLVM feature that is only used when you
have to look up a value by name.  Aside from that, the <a class="reference internal" href="#symboltable">SymbolTable</a> is used
internally to make sure that there are not conflicts between the names of
<a class="reference internal" href="#instruction">Instruction</a>s, <a class="reference internal" href="#basicblock">BasicBlock</a>s, or <a class="reference internal" href="#argument">Argument</a>s in the function body.</p>
<p>Note that <tt class="docutils literal"><span class="pre">Function</span></tt> is a <a class="reference internal" href="#globalvalue">GlobalValue</a> and therefore also a <a class="reference internal" href="#constant">Constant</a>.  The
value of the function is its address (after linking) which is guaranteed to be
constant.</p>
<div class="section" id="important-public-members-of-the-function">
<span id="m-function"></span><h4><a class="toc-backref" href="#id120">Important Public Members of the <tt class="docutils literal"><span class="pre">Function</span></tt></a><a class="headerlink" href="#important-public-members-of-the-function" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">Function(const</span> <span class="pre">FunctionType</span> <span class="pre">*Ty,</span> <span class="pre">LinkageTypes</span> <span class="pre">Linkage,</span>
<span class="pre">const</span> <span class="pre">std::string</span> <span class="pre">&amp;N</span> <span class="pre">=</span> <span class="pre">&quot;&quot;,</span> <span class="pre">Module*</span> <span class="pre">Parent</span> <span class="pre">=</span> <span class="pre">0)</span></tt></p>
<p>Constructor used when you need to create new <tt class="docutils literal"><span class="pre">Function</span></tt>s to add the
program.  The constructor must specify the type of the function to create and
what type of linkage the function should have.  The <a class="reference internal" href="#functiontype">FunctionType</a> argument
specifies the formal arguments and return value for the function.  The same
<a class="reference internal" href="#functiontype">FunctionType</a> value can be used to create multiple functions.  The <tt class="docutils literal"><span class="pre">Parent</span></tt>
argument specifies the Module in which the function is defined.  If this
argument is provided, the function will automatically be inserted into that
module&#8217;s list of functions.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">isDeclaration()</span></tt></p>
<p>Return whether or not the <tt class="docutils literal"><span class="pre">Function</span></tt> has a body defined.  If the function is
&#8220;external&#8221;, it does not have a body, and thus must be resolved by linking with
a function defined in a different translation unit.</p>
</li>
<li><div class="first line-block">
<div class="line"><tt class="docutils literal"><span class="pre">Function::iterator</span></tt> - Typedef for basic block list iterator</div>
<div class="line"><tt class="docutils literal"><span class="pre">Function::const_iterator</span></tt> - Typedef for const_iterator.</div>
<div class="line"><tt class="docutils literal"><span class="pre">begin()</span></tt>, <tt class="docutils literal"><span class="pre">end()</span></tt>, <tt class="docutils literal"><span class="pre">size()</span></tt>, <tt class="docutils literal"><span class="pre">empty()</span></tt></div>
</div>
<p>These are forwarding methods that make it easy to access the contents of a
<tt class="docutils literal"><span class="pre">Function</span></tt> object&#8217;s <a class="reference internal" href="#basicblock">BasicBlock</a> list.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Function::BasicBlockListType</span> <span class="pre">&amp;getBasicBlockList()</span></tt></p>
<p>Returns the list of <a class="reference internal" href="#basicblock">BasicBlock</a>s.  This is necessary to use when you need to
update the list or perform a complex action that doesn&#8217;t have a forwarding
method.</p>
</li>
<li><div class="first line-block">
<div class="line"><tt class="docutils literal"><span class="pre">Function::arg_iterator</span></tt> - Typedef for the argument list iterator</div>
<div class="line"><tt class="docutils literal"><span class="pre">Function::const_arg_iterator</span></tt> - Typedef for const_iterator.</div>
<div class="line"><tt class="docutils literal"><span class="pre">arg_begin()</span></tt>, <tt class="docutils literal"><span class="pre">arg_end()</span></tt>, <tt class="docutils literal"><span class="pre">arg_size()</span></tt>, <tt class="docutils literal"><span class="pre">arg_empty()</span></tt></div>
</div>
<p>These are forwarding methods that make it easy to access the contents of a
<tt class="docutils literal"><span class="pre">Function</span></tt> object&#8217;s <a class="reference internal" href="#argument">Argument</a> list.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Function::ArgumentListType</span> <span class="pre">&amp;getArgumentList()</span></tt></p>
<p>Returns the list of <a class="reference internal" href="#argument">Argument</a>.  This is necessary to use when you need to
update the list or perform a complex action that doesn&#8217;t have a forwarding
method.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">BasicBlock</span> <span class="pre">&amp;getEntryBlock()</span></tt></p>
<p>Returns the entry <tt class="docutils literal"><span class="pre">BasicBlock</span></tt> for the function.  Because the entry block
for the function is always the first block, this returns the first block of
the <tt class="docutils literal"><span class="pre">Function</span></tt>.</p>
</li>
<li><div class="first line-block">
<div class="line"><tt class="docutils literal"><span class="pre">Type</span> <span class="pre">*getReturnType()</span></tt></div>
<div class="line"><tt class="docutils literal"><span class="pre">FunctionType</span> <span class="pre">*getFunctionType()</span></tt></div>
</div>
<p>This traverses the <a class="reference internal" href="#type">Type</a> of the <tt class="docutils literal"><span class="pre">Function</span></tt> and returns the return type of
the function, or the <a class="reference internal" href="#functiontype">FunctionType</a> of the actual function.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">SymbolTable</span> <span class="pre">*getSymbolTable()</span></tt></p>
<p>Return a pointer to the <a class="reference internal" href="#symboltable">SymbolTable</a> for this <tt class="docutils literal"><span class="pre">Function</span></tt>.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="the-globalvariable-class">
<span id="globalvariable"></span><h3><a class="toc-backref" href="#id121">The <tt class="docutils literal"><span class="pre">GlobalVariable</span></tt> class</a><a class="headerlink" href="#the-globalvariable-class" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">#include</span> <span class="pre">&quot;llvm/IR/GlobalVariable.h&quot;</span></tt></p>
<p>header source: <a class="reference external" href="http://llvm.org/doxygen/GlobalVariable_8h-source.html">GlobalVariable.h</a></p>
<p>doxygen info: <a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1GlobalVariable.html">GlobalVariable Class</a></p>
<p>Superclasses: <a class="reference internal" href="#globalvalue">GlobalValue</a>, <a class="reference internal" href="#constant">Constant</a>, <a class="reference internal" href="#user">User</a>, <a class="reference internal" href="#value">Value</a></p>
<p>Global variables are represented with the (surprise surprise) <tt class="docutils literal"><span class="pre">GlobalVariable</span></tt>
class.  Like functions, <tt class="docutils literal"><span class="pre">GlobalVariable</span></tt>s are also subclasses of
<a class="reference internal" href="#globalvalue">GlobalValue</a>, and as such are always referenced by their address (global values
must live in memory, so their &#8220;name&#8221; refers to their constant address).  See
<a class="reference internal" href="#globalvalue">GlobalValue</a> for more on this.  Global variables may have an initial value
(which must be a <a class="reference internal" href="#constant">Constant</a>), and if they have an initializer, they may be marked
as &#8220;constant&#8221; themselves (indicating that their contents never change at
runtime).</p>
<div class="section" id="important-public-members-of-the-globalvariable-class">
<span id="m-globalvariable"></span><h4><a class="toc-backref" href="#id122">Important Public Members of the <tt class="docutils literal"><span class="pre">GlobalVariable</span></tt> class</a><a class="headerlink" href="#important-public-members-of-the-globalvariable-class" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">GlobalVariable(const</span> <span class="pre">Type</span> <span class="pre">*Ty,</span> <span class="pre">bool</span> <span class="pre">isConstant,</span> <span class="pre">LinkageTypes</span> <span class="pre">&amp;Linkage,</span>
<span class="pre">Constant</span> <span class="pre">*Initializer</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">const</span> <span class="pre">std::string</span> <span class="pre">&amp;Name</span> <span class="pre">=</span> <span class="pre">&quot;&quot;,</span> <span class="pre">Module*</span> <span class="pre">Parent</span> <span class="pre">=</span> <span class="pre">0)</span></tt></p>
<p>Create a new global variable of the specified type.  If <tt class="docutils literal"><span class="pre">isConstant</span></tt> is true
then the global variable will be marked as unchanging for the program.  The
Linkage parameter specifies the type of linkage (internal, external, weak,
linkonce, appending) for the variable.  If the linkage is InternalLinkage,
WeakAnyLinkage, WeakODRLinkage, LinkOnceAnyLinkage or LinkOnceODRLinkage, then
the resultant global variable will have internal linkage.  AppendingLinkage
concatenates together all instances (in different translation units) of the
variable into a single variable but is only applicable to arrays.  See the
<a class="reference external" href="LangRef.html#modulestructure">LLVM Language Reference</a> for further details
on linkage types.  Optionally an initializer, a name, and the module to put
the variable into may be specified for the global variable as well.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">isConstant()</span> <span class="pre">const</span></tt></p>
<p>Returns true if this is a global variable that is known not to be modified at
runtime.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">hasInitializer()</span></tt></p>
<p>Returns true if this <tt class="docutils literal"><span class="pre">GlobalVariable</span></tt> has an intializer.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Constant</span> <span class="pre">*getInitializer()</span></tt></p>
<p>Returns the initial value for a <tt class="docutils literal"><span class="pre">GlobalVariable</span></tt>.  It is not legal to call
this method if there is no initializer.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="the-basicblock-class">
<span id="basicblock"></span><h3><a class="toc-backref" href="#id123">The <tt class="docutils literal"><span class="pre">BasicBlock</span></tt> class</a><a class="headerlink" href="#the-basicblock-class" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">#include</span> <span class="pre">&quot;llvm/IR/BasicBlock.h&quot;</span></tt></p>
<p>header source: <a class="reference external" href="http://llvm.org/doxygen/BasicBlock_8h-source.html">BasicBlock.h</a></p>
<p>doxygen info: <a class="reference external" href="http://llvm.org/doxygen/classllvm_1_1BasicBlock.html">BasicBlock Class</a></p>
<p>Superclass: <a class="reference internal" href="#value">Value</a></p>
<p>This class represents a single entry single exit section of the code, commonly
known as a basic block by the compiler community.  The <tt class="docutils literal"><span class="pre">BasicBlock</span></tt> class
maintains a list of <a class="reference internal" href="#instruction">Instruction</a>s, which form the body of the block.  Matching
the language definition, the last element of this list of instructions is always
a terminator instruction (a subclass of the <a class="reference internal" href="#terminatorinst">TerminatorInst</a> class).</p>
<p>In addition to tracking the list of instructions that make up the block, the
<tt class="docutils literal"><span class="pre">BasicBlock</span></tt> class also keeps track of the <a class="reference internal" href="#c-function"><em>Function</em></a> that
it is embedded into.</p>
<p>Note that <tt class="docutils literal"><span class="pre">BasicBlock</span></tt>s themselves are <a class="reference internal" href="#value">Value</a>s, because they are
referenced by instructions like branches and can go in the switch tables.
<tt class="docutils literal"><span class="pre">BasicBlock</span></tt>s have type <tt class="docutils literal"><span class="pre">label</span></tt>.</p>
<div class="section" id="important-public-members-of-the-basicblock-class">
<span id="m-basicblock"></span><h4><a class="toc-backref" href="#id124">Important Public Members of the <tt class="docutils literal"><span class="pre">BasicBlock</span></tt> class</a><a class="headerlink" href="#important-public-members-of-the-basicblock-class" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">BasicBlock(const</span> <span class="pre">std::string</span> <span class="pre">&amp;Name</span> <span class="pre">=</span> <span class="pre">&quot;&quot;,</span> <span class="pre">Function</span> <span class="pre">*Parent</span> <span class="pre">=</span> <span class="pre">0)</span></tt></p>
<p>The <tt class="docutils literal"><span class="pre">BasicBlock</span></tt> constructor is used to create new basic blocks for
insertion into a function.  The constructor optionally takes a name for the
new block, and a <a class="reference internal" href="#c-function"><em>Function</em></a> to insert it into.  If the
<tt class="docutils literal"><span class="pre">Parent</span></tt> parameter is specified, the new <tt class="docutils literal"><span class="pre">BasicBlock</span></tt> is automatically
inserted at the end of the specified <a class="reference internal" href="#c-function"><em>Function</em></a>, if not
specified, the BasicBlock must be manually inserted into the <a class="reference internal" href="#c-function"><em>Function</em></a>.</p>
</li>
<li><div class="first line-block">
<div class="line"><tt class="docutils literal"><span class="pre">BasicBlock::iterator</span></tt> - Typedef for instruction list iterator</div>
<div class="line"><tt class="docutils literal"><span class="pre">BasicBlock::const_iterator</span></tt> - Typedef for const_iterator.</div>
<div class="line"><tt class="docutils literal"><span class="pre">begin()</span></tt>, <tt class="docutils literal"><span class="pre">end()</span></tt>, <tt class="docutils literal"><span class="pre">front()</span></tt>, <tt class="docutils literal"><span class="pre">back()</span></tt>,
<tt class="docutils literal"><span class="pre">size()</span></tt>, <tt class="docutils literal"><span class="pre">empty()</span></tt>
STL-style functions for accessing the instruction list.</div>
</div>
<p>These methods and typedefs are forwarding functions that have the same
semantics as the standard library methods of the same names.  These methods
expose the underlying instruction list of a basic block in a way that is easy
to manipulate.  To get the full complement of container operations (including
operations to update the list), you must use the <tt class="docutils literal"><span class="pre">getInstList()</span></tt> method.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">BasicBlock::InstListType</span> <span class="pre">&amp;getInstList()</span></tt></p>
<p>This method is used to get access to the underlying container that actually
holds the Instructions.  This method must be used when there isn&#8217;t a
forwarding function in the <tt class="docutils literal"><span class="pre">BasicBlock</span></tt> class for the operation that you
would like to perform.  Because there are no forwarding functions for
&#8220;updating&#8221; operations, you need to use this if you want to update the contents
of a <tt class="docutils literal"><span class="pre">BasicBlock</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Function</span> <span class="pre">*getParent()</span></tt></p>
<p>Returns a pointer to <a class="reference internal" href="#c-function"><em>Function</em></a> the block is embedded into,
or a null pointer if it is homeless.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">TerminatorInst</span> <span class="pre">*getTerminator()</span></tt></p>
<p>Returns a pointer to the terminator instruction that appears at the end of the
<tt class="docutils literal"><span class="pre">BasicBlock</span></tt>.  If there is no terminator instruction, or if the last
instruction in the block is not a terminator, then a null pointer is returned.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="the-argument-class">
<span id="argument"></span><h3><a class="toc-backref" href="#id125">The <tt class="docutils literal"><span class="pre">Argument</span></tt> class</a><a class="headerlink" href="#the-argument-class" title="Permalink to this headline">¶</a></h3>
<p>This subclass of Value defines the interface for incoming formal arguments to a
function.  A Function maintains a list of its formal arguments.  An argument has
a pointer to the parent Function.</p>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="Extensions.html" title="LLVM Extensions"
             >next</a> |</li>
        <li class="right" >
          <a href="HowToSetUpLLVMStyleRTTI.html" title="How to set up LLVM-style RTTI for your class hierarchy"
             >previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index-2.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2003-2014, LLVM Project.
      Last updated on 2014-04-24.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>

<!-- Mirrored from llvm.org/docs/ProgrammersManual.html by HTTrack Website Copier/3.x [XR&CO'2013], Sat, 26 Apr 2014 21:32:25 GMT -->
</html>