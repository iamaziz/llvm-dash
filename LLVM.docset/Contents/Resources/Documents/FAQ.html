

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Frequently Asked Questions (FAQ) &#8212; LLVM 9 documentation</title>
    <link rel="stylesheet" href="_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="The LLVM Lexicon" href="Lexicon.html" />
    <link rel="prev" title="Getting Started with the LLVM System using Microsoft Visual Studio" href="GettingStartedVS.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="Lexicon.html" title="The LLVM Lexicon"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="GettingStartedVS.html" title="Getting Started with the LLVM System using Microsoft Visual Studio"
             accesskey="P">previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="frequently-asked-questions-faq">
<h1>Frequently Asked Questions (FAQ)<a class="headerlink" href="#frequently-asked-questions-faq" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#license" id="id1">License</a></p>
<ul>
<li><p><a class="reference internal" href="#does-the-university-of-illinois-open-source-license-really-qualify-as-an-open-source-license" id="id2">Does the University of Illinois Open Source License really qualify as an “open source” license?</a></p></li>
<li><p><a class="reference internal" href="#can-i-modify-llvm-source-code-and-redistribute-the-modified-source" id="id3">Can I modify LLVM source code and redistribute the modified source?</a></p></li>
<li><p><a class="reference internal" href="#can-i-modify-the-llvm-source-code-and-redistribute-binaries-or-other-tools-based-on-it-without-redistributing-the-source" id="id4">Can I modify the LLVM source code and redistribute binaries or other tools based on it, without redistributing the source?</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#source-code" id="id5">Source Code</a></p>
<ul>
<li><p><a class="reference internal" href="#in-what-language-is-llvm-written" id="id6">In what language is LLVM written?</a></p></li>
<li><p><a class="reference internal" href="#how-portable-is-the-llvm-source-code" id="id7">How portable is the LLVM source code?</a></p></li>
<li><p><a class="reference internal" href="#what-api-do-i-use-to-store-a-value-to-one-of-the-virtual-registers-in-llvm-ir-s-ssa-representation" id="id8">What API do I use to store a value to one of the virtual registers in LLVM IR’s SSA representation?</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#source-languages" id="id9">Source Languages</a></p>
<ul>
<li><p><a class="reference internal" href="#what-source-languages-are-supported" id="id10">What source languages are supported?</a></p></li>
<li><p><a class="reference internal" href="#i-d-like-to-write-a-self-hosting-llvm-compiler-how-should-i-interface-with-the-llvm-middle-end-optimizers-and-back-end-code-generators" id="id11">I’d like to write a self-hosting LLVM compiler. How should I interface with the LLVM middle-end optimizers and back-end code generators?</a></p></li>
<li><p><a class="reference internal" href="#what-support-is-there-for-a-higher-level-source-language-constructs-for-building-a-compiler" id="id12">What support is there for a higher level source language constructs for building a compiler?</a></p></li>
<li><p><a class="reference internal" href="#i-don-t-understand-the-getelementptr-instruction-help" id="id13">I don’t understand the <code class="docutils literal notranslate"><span class="pre">GetElementPtr</span></code> instruction. Help!</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#using-the-c-and-c-front-ends" id="id14">Using the C and C++ Front Ends</a></p>
<ul>
<li><p><a class="reference internal" href="#can-i-compile-c-or-c-code-to-platform-independent-llvm-bitcode" id="id15">Can I compile C or C++ code to platform-independent LLVM bitcode?</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#questions-about-code-generated-by-the-demo-page" id="id16">Questions about code generated by the demo page</a></p>
<ul>
<li><p><a class="reference internal" href="#what-is-this-llvm-global-ctors-and-global-i-a-stuff-that-happens-when-i-include-iostream" id="id17">What is this <code class="docutils literal notranslate"><span class="pre">llvm.global_ctors</span></code> and <code class="docutils literal notranslate"><span class="pre">_GLOBAL__I_a...</span></code> stuff that happens when I <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;iostream&gt;</span></code>?</a></p></li>
<li><p><a class="reference internal" href="#where-did-all-of-my-code-go" id="id18">Where did all of my code go??</a></p></li>
<li><p><a class="reference internal" href="#what-is-this-undef-thing-that-shows-up-in-my-code" id="id19">What is this “<code class="docutils literal notranslate"><span class="pre">undef</span></code>” thing that shows up in my code?</a></p></li>
<li><p><a class="reference internal" href="#why-does-instcombine-simplifycfg-turn-a-call-to-a-function-with-a-mismatched-calling-convention-into-unreachable-why-not-make-the-verifier-reject-it" id="id20">Why does instcombine + simplifycfg turn a call to a function with a mismatched calling convention into “unreachable”? Why not make the verifier reject it?</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="license">
<h2><a class="toc-backref" href="#id1">License</a><a class="headerlink" href="#license" title="Permalink to this headline">¶</a></h2>
<div class="section" id="does-the-university-of-illinois-open-source-license-really-qualify-as-an-open-source-license">
<h3><a class="toc-backref" href="#id2">Does the University of Illinois Open Source License really qualify as an “open source” license?</a><a class="headerlink" href="#does-the-university-of-illinois-open-source-license-really-qualify-as-an-open-source-license" title="Permalink to this headline">¶</a></h3>
<p>Yes, the license is <a class="reference external" href="http://www.opensource.org/licenses/UoI-NCSA.php">certified</a> by the Open Source
Initiative (OSI).</p>
</div>
<div class="section" id="can-i-modify-llvm-source-code-and-redistribute-the-modified-source">
<h3><a class="toc-backref" href="#id3">Can I modify LLVM source code and redistribute the modified source?</a><a class="headerlink" href="#can-i-modify-llvm-source-code-and-redistribute-the-modified-source" title="Permalink to this headline">¶</a></h3>
<p>Yes.  The modified source distribution must retain the copyright notice and
follow the three bulleted conditions listed in the <a class="reference external" href="http://llvm.org/svn/llvm-project/llvm/trunk/LICENSE.TXT">LLVM license</a>.</p>
</div>
<div class="section" id="can-i-modify-the-llvm-source-code-and-redistribute-binaries-or-other-tools-based-on-it-without-redistributing-the-source">
<h3><a class="toc-backref" href="#id4">Can I modify the LLVM source code and redistribute binaries or other tools based on it, without redistributing the source?</a><a class="headerlink" href="#can-i-modify-the-llvm-source-code-and-redistribute-binaries-or-other-tools-based-on-it-without-redistributing-the-source" title="Permalink to this headline">¶</a></h3>
<p>Yes. This is why we distribute LLVM under a less restrictive license than GPL,
as explained in the first question above.</p>
</div>
</div>
<div class="section" id="source-code">
<h2><a class="toc-backref" href="#id5">Source Code</a><a class="headerlink" href="#source-code" title="Permalink to this headline">¶</a></h2>
<div class="section" id="in-what-language-is-llvm-written">
<h3><a class="toc-backref" href="#id6">In what language is LLVM written?</a><a class="headerlink" href="#in-what-language-is-llvm-written" title="Permalink to this headline">¶</a></h3>
<p>All of the LLVM tools and libraries are written in C++ with extensive use of
the STL.</p>
</div>
<div class="section" id="how-portable-is-the-llvm-source-code">
<h3><a class="toc-backref" href="#id7">How portable is the LLVM source code?</a><a class="headerlink" href="#how-portable-is-the-llvm-source-code" title="Permalink to this headline">¶</a></h3>
<p>The LLVM source code should be portable to most modern Unix-like operating
systems.  Most of the code is written in standard C++ with operating system
services abstracted to a support library.  The tools required to build and
test LLVM have been ported to a plethora of platforms.</p>
</div>
<div class="section" id="what-api-do-i-use-to-store-a-value-to-one-of-the-virtual-registers-in-llvm-ir-s-ssa-representation">
<h3><a class="toc-backref" href="#id8">What API do I use to store a value to one of the virtual registers in LLVM IR’s SSA representation?</a><a class="headerlink" href="#what-api-do-i-use-to-store-a-value-to-one-of-the-virtual-registers-in-llvm-ir-s-ssa-representation" title="Permalink to this headline">¶</a></h3>
<p>In short: you can’t. It’s actually kind of a silly question once you grok
what’s going on. Basically, in code like:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">%result</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="nv">%foo</span><span class="p">,</span> <span class="nv">%bar</span>
</pre></div>
</div>
<p>, <code class="docutils literal notranslate"><span class="pre">%result</span></code> is just a name given to the <code class="docutils literal notranslate"><span class="pre">Value</span></code> of the <code class="docutils literal notranslate"><span class="pre">add</span></code>
instruction. In other words, <code class="docutils literal notranslate"><span class="pre">%result</span></code> <em>is</em> the add instruction. The
“assignment” doesn’t explicitly “store” anything to any “virtual register”;
the “<code class="docutils literal notranslate"><span class="pre">=</span></code>” is more like the mathematical sense of equality.</p>
<p>Longer explanation: In order to generate a textual representation of the
IR, some kind of name has to be given to each instruction so that other
instructions can textually reference it. However, the isomorphic in-memory
representation that you manipulate from C++ has no such restriction since
instructions can simply keep pointers to any other <code class="docutils literal notranslate"><span class="pre">Value</span></code>’s that they
reference. In fact, the names of dummy numbered temporaries like <code class="docutils literal notranslate"><span class="pre">%1</span></code> are
not explicitly represented in the in-memory representation at all (see
<code class="docutils literal notranslate"><span class="pre">Value::getName()</span></code>).</p>
</div>
</div>
<div class="section" id="source-languages">
<h2><a class="toc-backref" href="#id9">Source Languages</a><a class="headerlink" href="#source-languages" title="Permalink to this headline">¶</a></h2>
<div class="section" id="what-source-languages-are-supported">
<h3><a class="toc-backref" href="#id10">What source languages are supported?</a><a class="headerlink" href="#what-source-languages-are-supported" title="Permalink to this headline">¶</a></h3>
<p>LLVM currently has full support for C and C++ source languages through
<a class="reference external" href="http://clang.llvm.org/">Clang</a>. Many other language frontends have
been written using LLVM, and an incomplete list is available at
<a class="reference external" href="http://llvm.org/ProjectsWithLLVM/">projects with LLVM</a>.</p>
</div>
<div class="section" id="i-d-like-to-write-a-self-hosting-llvm-compiler-how-should-i-interface-with-the-llvm-middle-end-optimizers-and-back-end-code-generators">
<h3><a class="toc-backref" href="#id11">I’d like to write a self-hosting LLVM compiler. How should I interface with the LLVM middle-end optimizers and back-end code generators?</a><a class="headerlink" href="#i-d-like-to-write-a-self-hosting-llvm-compiler-how-should-i-interface-with-the-llvm-middle-end-optimizers-and-back-end-code-generators" title="Permalink to this headline">¶</a></h3>
<p>Your compiler front-end will communicate with LLVM by creating a module in the
LLVM intermediate representation (IR) format. Assuming you want to write your
language’s compiler in the language itself (rather than C++), there are 3
major ways to tackle generating LLVM IR from a front-end:</p>
<ol class="arabic simple">
<li><p><strong>Call into the LLVM libraries code using your language’s FFI (foreign
function interface).</strong></p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p><em>for:</em> best tracks changes to the LLVM IR, .ll syntax, and .bc format</p></li>
<li><p><em>for:</em> enables running LLVM optimization passes without a emit/parse
overhead</p></li>
<li><p><em>for:</em> adapts well to a JIT context</p></li>
<li><p><em>against:</em> lots of ugly glue code to write</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p><strong>Emit LLVM assembly from your compiler’s native language.</strong></p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p><em>for:</em> very straightforward to get started</p></li>
<li><p><em>against:</em> the .ll parser is slower than the bitcode reader when
interfacing to the middle end</p></li>
<li><p><em>against:</em> it may be harder to track changes to the IR</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p><strong>Emit LLVM bitcode from your compiler’s native language.</strong></p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p><em>for:</em> can use the more-efficient bitcode reader when interfacing to the
middle end</p></li>
<li><p><em>against:</em> you’ll have to re-engineer the LLVM IR object model and bitcode
writer in your language</p></li>
<li><p><em>against:</em> it may be harder to track changes to the IR</p></li>
</ul>
</div></blockquote>
<p>If you go with the first option, the C bindings in include/llvm-c should help
a lot, since most languages have strong support for interfacing with C. The
most common hurdle with calling C from managed code is interfacing with the
garbage collector. The C interface was designed to require very little memory
management, and so is straightforward in this regard.</p>
</div>
<div class="section" id="what-support-is-there-for-a-higher-level-source-language-constructs-for-building-a-compiler">
<h3><a class="toc-backref" href="#id12">What support is there for a higher level source language constructs for building a compiler?</a><a class="headerlink" href="#what-support-is-there-for-a-higher-level-source-language-constructs-for-building-a-compiler" title="Permalink to this headline">¶</a></h3>
<p>Currently, there isn’t much. LLVM supports an intermediate representation
which is useful for code representation but will not support the high level
(abstract syntax tree) representation needed by most compilers. There are no
facilities for lexical nor semantic analysis.</p>
</div>
<div class="section" id="i-don-t-understand-the-getelementptr-instruction-help">
<h3><a class="toc-backref" href="#id13">I don’t understand the <code class="docutils literal notranslate"><span class="pre">GetElementPtr</span></code> instruction. Help!</a><a class="headerlink" href="#i-don-t-understand-the-getelementptr-instruction-help" title="Permalink to this headline">¶</a></h3>
<p>See <a class="reference external" href="GetElementPtr.html">The Often Misunderstood GEP Instruction</a>.</p>
</div>
</div>
<div class="section" id="using-the-c-and-c-front-ends">
<h2><a class="toc-backref" href="#id14">Using the C and C++ Front Ends</a><a class="headerlink" href="#using-the-c-and-c-front-ends" title="Permalink to this headline">¶</a></h2>
<div class="section" id="can-i-compile-c-or-c-code-to-platform-independent-llvm-bitcode">
<h3><a class="toc-backref" href="#id15">Can I compile C or C++ code to platform-independent LLVM bitcode?</a><a class="headerlink" href="#can-i-compile-c-or-c-code-to-platform-independent-llvm-bitcode" title="Permalink to this headline">¶</a></h3>
<p>No. C and C++ are inherently platform-dependent languages. The most obvious
example of this is the preprocessor. A very common way that C code is made
portable is by using the preprocessor to include platform-specific code. In
practice, information about other platforms is lost after preprocessing, so
the result is inherently dependent on the platform that the preprocessing was
targeting.</p>
<p>Another example is <code class="docutils literal notranslate"><span class="pre">sizeof</span></code>. It’s common for <code class="docutils literal notranslate"><span class="pre">sizeof(long)</span></code> to vary
between platforms. In most C front-ends, <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> is expanded to a
constant immediately, thus hard-wiring a platform-specific detail.</p>
<p>Also, since many platforms define their ABIs in terms of C, and since LLVM is
lower-level than C, front-ends currently must emit platform-specific IR in
order to have the result conform to the platform ABI.</p>
</div>
</div>
<div class="section" id="questions-about-code-generated-by-the-demo-page">
<h2><a class="toc-backref" href="#id16">Questions about code generated by the demo page</a><a class="headerlink" href="#questions-about-code-generated-by-the-demo-page" title="Permalink to this headline">¶</a></h2>
<div class="section" id="what-is-this-llvm-global-ctors-and-global-i-a-stuff-that-happens-when-i-include-iostream">
<h3><a class="toc-backref" href="#id17">What is this <code class="docutils literal notranslate"><span class="pre">llvm.global_ctors</span></code> and <code class="docutils literal notranslate"><span class="pre">_GLOBAL__I_a...</span></code> stuff that happens when I <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;iostream&gt;</span></code>?</a><a class="headerlink" href="#what-is-this-llvm-global-ctors-and-global-i-a-stuff-that-happens-when-i-include-iostream" title="Permalink to this headline">¶</a></h3>
<p>If you <code class="docutils literal notranslate"><span class="pre">#include</span></code> the <code class="docutils literal notranslate"><span class="pre">&lt;iostream&gt;</span></code> header into a C++ translation unit,
the file will probably use the <code class="docutils literal notranslate"><span class="pre">std::cin</span></code>/<code class="docutils literal notranslate"><span class="pre">std::cout</span></code>/… global objects.
However, C++ does not guarantee an order of initialization between static
objects in different translation units, so if a static ctor/dtor in your .cpp
file used <code class="docutils literal notranslate"><span class="pre">std::cout</span></code>, for example, the object would not necessarily be
automatically initialized before your use.</p>
<p>To make <code class="docutils literal notranslate"><span class="pre">std::cout</span></code> and friends work correctly in these scenarios, the STL
that we use declares a static object that gets created in every translation
unit that includes <code class="docutils literal notranslate"><span class="pre">&lt;iostream&gt;</span></code>.  This object has a static constructor
and destructor that initializes and destroys the global iostream objects
before they could possibly be used in the file.  The code that you see in the
<code class="docutils literal notranslate"><span class="pre">.ll</span></code> file corresponds to the constructor and destructor registration code.</p>
<p>If you would like to make it easier to <em>understand</em> the LLVM code generated
by the compiler in the demo page, consider using <code class="docutils literal notranslate"><span class="pre">printf()</span></code> instead of
<code class="docutils literal notranslate"><span class="pre">iostream</span></code>s to print values.</p>
</div>
<div class="section" id="where-did-all-of-my-code-go">
<h3><a class="toc-backref" href="#id18">Where did all of my code go??</a><a class="headerlink" href="#where-did-all-of-my-code-go" title="Permalink to this headline">¶</a></h3>
<p>If you are using the LLVM demo page, you may often wonder what happened to
all of the code that you typed in.  Remember that the demo script is running
the code through the LLVM optimizers, so if your code doesn’t actually do
anything useful, it might all be deleted.</p>
<p>To prevent this, make sure that the code is actually needed.  For example, if
you are computing some expression, return the value from the function instead
of leaving it in a local variable.  If you really want to constrain the
optimizer, you can read from and assign to <code class="docutils literal notranslate"><span class="pre">volatile</span></code> global variables.</p>
</div>
<div class="section" id="what-is-this-undef-thing-that-shows-up-in-my-code">
<h3><a class="toc-backref" href="#id19">What is this “<code class="docutils literal notranslate"><span class="pre">undef</span></code>” thing that shows up in my code?</a><a class="headerlink" href="#what-is-this-undef-thing-that-shows-up-in-my-code" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">undef</span></code> is the LLVM way of representing a value that is not defined.  You
can get these if you do not initialize a variable before you use it.  For
example, the C function:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">X</span><span class="p">()</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>Is compiled to “<code class="docutils literal notranslate"><span class="pre">ret</span> <span class="pre">i32</span> <span class="pre">undef</span></code>” because “<code class="docutils literal notranslate"><span class="pre">i</span></code>” never has a value specified
for it.</p>
</div>
<div class="section" id="why-does-instcombine-simplifycfg-turn-a-call-to-a-function-with-a-mismatched-calling-convention-into-unreachable-why-not-make-the-verifier-reject-it">
<h3><a class="toc-backref" href="#id20">Why does instcombine + simplifycfg turn a call to a function with a mismatched calling convention into “unreachable”? Why not make the verifier reject it?</a><a class="headerlink" href="#why-does-instcombine-simplifycfg-turn-a-call-to-a-function-with-a-mismatched-calling-convention-into-unreachable-why-not-make-the-verifier-reject-it" title="Permalink to this headline">¶</a></h3>
<p>This is a common problem run into by authors of front-ends that are using
custom calling conventions: you need to make sure to set the right calling
convention on both the function and on each call to the function.  For
example, this code:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="k">fastcc</span> <span class="k">void</span> <span class="vg">@foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">ret</span> <span class="k">void</span>
<span class="p">}</span>
<span class="k">define</span> <span class="k">void</span> <span class="vg">@bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">call</span> <span class="k">void</span> <span class="vg">@foo</span><span class="p">()</span>
    <span class="k">ret</span> <span class="k">void</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Is optimized to:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="k">fastcc</span> <span class="k">void</span> <span class="vg">@foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">ret</span> <span class="k">void</span>
<span class="p">}</span>
<span class="k">define</span> <span class="k">void</span> <span class="vg">@bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">unreachable</span>
<span class="p">}</span>
</pre></div>
</div>
<p>… with “<code class="docutils literal notranslate"><span class="pre">opt</span> <span class="pre">-instcombine</span> <span class="pre">-simplifycfg</span></code>”.  This often bites people because
“all their code disappears”.  Setting the calling convention on the caller and
callee is required for indirect calls to work, so people often ask why not
make the verifier reject this sort of thing.</p>
<p>The answer is that this code has undefined behavior, but it is not illegal.
If we made it illegal, then every transformation that could potentially create
this would have to ensure that it doesn’t, and there is valid code that can
create this sort of construct (in dead code).  The sorts of things that can
cause this to happen are fairly contrived, but we still need to accept them.
Here’s an example:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="k">fastcc</span> <span class="k">void</span> <span class="vg">@foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">ret</span> <span class="k">void</span>
<span class="p">}</span>
<span class="k">define</span> <span class="k">internal</span> <span class="k">void</span> <span class="vg">@bar</span><span class="p">(</span><span class="k">void</span><span class="p">()*</span> <span class="nv">%FP</span><span class="p">,</span> <span class="k">i1</span> <span class="nv">%cond</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">br</span> <span class="k">i1</span> <span class="nv">%cond</span><span class="p">,</span> <span class="k">label</span> <span class="nv">%T</span><span class="p">,</span> <span class="k">label</span> <span class="nv">%F</span>
<span class="nl">T:</span>
    <span class="k">call</span> <span class="k">void</span> <span class="nv">%FP</span><span class="p">()</span>
    <span class="k">ret</span> <span class="k">void</span>
<span class="nl">F:</span>
    <span class="k">call</span> <span class="k">fastcc</span> <span class="k">void</span> <span class="nv">%FP</span><span class="p">()</span>
    <span class="k">ret</span> <span class="k">void</span>
<span class="p">}</span>
<span class="k">define</span> <span class="k">void</span> <span class="vg">@test</span><span class="p">()</span> <span class="p">{</span>
    <span class="nv">%X</span> <span class="p">=</span> <span class="k">or</span> <span class="k">i1</span> <span class="k">false</span><span class="p">,</span> <span class="k">false</span>
    <span class="k">call</span> <span class="k">void</span> <span class="vg">@bar</span><span class="p">(</span><span class="k">void</span><span class="p">()*</span> <span class="vg">@foo</span><span class="p">,</span> <span class="k">i1</span> <span class="nv">%X</span><span class="p">)</span>
    <span class="k">ret</span> <span class="k">void</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, “test” always passes <code class="docutils literal notranslate"><span class="pre">&#64;foo</span></code>/<code class="docutils literal notranslate"><span class="pre">false</span></code> into <code class="docutils literal notranslate"><span class="pre">bar</span></code>, which
ensures that it is dynamically called with the right calling conv (thus, the
code is perfectly well defined).  If you run this through the inliner, you
get this (the explicit “or” is there so that the inliner doesn’t dead code
eliminate a bunch of stuff):</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="k">fastcc</span> <span class="k">void</span> <span class="vg">@foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">ret</span> <span class="k">void</span>
<span class="p">}</span>
<span class="k">define</span> <span class="k">void</span> <span class="vg">@test</span><span class="p">()</span> <span class="p">{</span>
    <span class="nv">%X</span> <span class="p">=</span> <span class="k">or</span> <span class="k">i1</span> <span class="k">false</span><span class="p">,</span> <span class="k">false</span>
    <span class="k">br</span> <span class="k">i1</span> <span class="nv">%X</span><span class="p">,</span> <span class="k">label</span> <span class="nv">%T.i</span><span class="p">,</span> <span class="k">label</span> <span class="nv">%F.i</span>
<span class="nl">T.i:</span>
    <span class="k">call</span> <span class="k">void</span> <span class="vg">@foo</span><span class="p">()</span>
    <span class="k">br</span> <span class="k">label</span> <span class="nv">%bar.exit</span>
<span class="nl">F.i:</span>
    <span class="k">call</span> <span class="k">fastcc</span> <span class="k">void</span> <span class="vg">@foo</span><span class="p">()</span>
    <span class="k">br</span> <span class="k">label</span> <span class="nv">%bar.exit</span>
<span class="nl">bar.exit:</span>
    <span class="k">ret</span> <span class="k">void</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here you can see that the inlining pass made an undefined call to <code class="docutils literal notranslate"><span class="pre">&#64;foo</span></code>
with the wrong calling convention.  We really don’t want to make the inliner
have to know about this sort of thing, so it needs to be valid code.  In this
case, dead code elimination can trivially remove the undefined code.  However,
if <code class="docutils literal notranslate"><span class="pre">%X</span></code> was an input argument to <code class="docutils literal notranslate"><span class="pre">&#64;test</span></code>, the inliner would produce this:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="k">fastcc</span> <span class="k">void</span> <span class="vg">@foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">ret</span> <span class="k">void</span>
<span class="p">}</span>

<span class="k">define</span> <span class="k">void</span> <span class="vg">@test</span><span class="p">(</span><span class="k">i1</span> <span class="nv">%X</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">br</span> <span class="k">i1</span> <span class="nv">%X</span><span class="p">,</span> <span class="k">label</span> <span class="nv">%T.i</span><span class="p">,</span> <span class="k">label</span> <span class="nv">%F.i</span>
<span class="nl">T.i:</span>
    <span class="k">call</span> <span class="k">void</span> <span class="vg">@foo</span><span class="p">()</span>
    <span class="k">br</span> <span class="k">label</span> <span class="nv">%bar.exit</span>
<span class="nl">F.i:</span>
    <span class="k">call</span> <span class="k">fastcc</span> <span class="k">void</span> <span class="vg">@foo</span><span class="p">()</span>
    <span class="k">br</span> <span class="k">label</span> <span class="nv">%bar.exit</span>
<span class="nl">bar.exit:</span>
    <span class="k">ret</span> <span class="k">void</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The interesting thing about this is that <code class="docutils literal notranslate"><span class="pre">%X</span></code> <em>must</em> be false for the
code to be well-defined, but no amount of dead code elimination will be able
to delete the broken call as unreachable.  However, since
<code class="docutils literal notranslate"><span class="pre">instcombine</span></code>/<code class="docutils literal notranslate"><span class="pre">simplifycfg</span></code> turns the undefined call into unreachable, we
end up with a branch on a condition that goes to unreachable: a branch to
unreachable can never happen, so “<code class="docutils literal notranslate"><span class="pre">-inline</span> <span class="pre">-instcombine</span> <span class="pre">-simplifycfg</span></code>” is
able to produce:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="k">fastcc</span> <span class="k">void</span> <span class="vg">@foo</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">ret</span> <span class="k">void</span>
<span class="p">}</span>
<span class="k">define</span> <span class="k">void</span> <span class="vg">@test</span><span class="p">(</span><span class="k">i1</span> <span class="nv">%X</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">F.i:</span>
   <span class="k">call</span> <span class="k">fastcc</span> <span class="k">void</span> <span class="vg">@foo</span><span class="p">()</span>
   <span class="k">ret</span> <span class="k">void</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="Lexicon.html" title="The LLVM Lexicon"
             >next</a> |</li>
        <li class="right" >
          <a href="GettingStartedVS.html" title="Getting Started with the LLVM System using Microsoft Visual Studio"
             >previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2003-2020, LLVM Project.
      Last updated on 2020-01-13.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.3.1.
    </div>
  </body>
</html>